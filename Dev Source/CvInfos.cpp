//  $Header:
//------------------------------------------------------------------------------------------------
//
//  FILE:    CvInfos.cpp
//
//  PURPOSE: The base class for all info classes to inherit from.  This gives us the base description
//				and type strings
//
//------------------------------------------------------------------------------------------------
//  Copyright (c) 2003 Firaxis Games, Inc. All rights reserved.
//------------------------------------------------------------------------------------------------
#include "CvGameCoreDLL.h"
#include "CvInfos.h"
#include "CvGlobals.h"
#include "CvArtFileMgr.h"
#include "CvXMLLoadUtility.h"
#include "CvDLLXMLIFaceBase.h"
#include "CvGameTextMgr.h"
#include "CvGameCoreUtils.h"

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CInfoBase()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvInfoBase::CvInfoBase() :
m_bGraphicalOnly(false)
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
,m_bForceOverwrite(false)
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CInfoBase()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvInfoBase::~CvInfoBase()
{
}

void CvInfoBase::read(FDataStreamBase* pStream)
{
	reset();

	pStream->Read(&m_bGraphicalOnly);
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		Possibly this doesn't need saved as it is useless data once XML is done loading			**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pStream->Read(&m_bForceOverwrite);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pStream->ReadString(m_szType);
	pStream->ReadString(m_szCivilopediaKey);
	pStream->ReadString(m_szHelpKey);
	pStream->ReadString(m_szStrategyKey);
	pStream->ReadString(m_szButton);
	pStream->ReadString(m_szTextKey);
}

void CvInfoBase::write(FDataStreamBase* pStream)
{
	pStream->Write(m_bGraphicalOnly);
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pStream->Write(m_bForceOverwrite);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pStream->WriteString(m_szType);
	pStream->WriteString(m_szCivilopediaKey);
	pStream->WriteString(m_szHelpKey);
	pStream->WriteString(m_szStrategyKey);
	pStream->WriteString(m_szButton);
	pStream->WriteString(m_szTextKey);
}

void CvInfoBase::reset()
{
	//clear cache
	m_aCachedDescriptions.clear();
	m_szCachedText.clear();
	m_szCachedHelp.clear();
	m_szCachedStrategy.clear();
	m_szCachedCivilopedia.clear();
}

bool CvInfoBase::isGraphicalOnly() const
{
	return m_bGraphicalOnly;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
const TCHAR* CvInfoBase::getType() const
{
/**								----  End Original Code  ----									**/
bool CvInfoBase::isForceOverwrite() const
{
	return m_bForceOverwrite;
}

const wchar* CvInfoBase::getCivilopediaKey() const
{
	return m_szCivilopediaKey;
}

const wchar* CvInfoBase::getHelpKey() const
{
	return m_szHelpKey;
}

const wchar* CvInfoBase::getStrategyKey() const
{
	return m_szStrategyKey;
}

const TCHAR* CvInfoBase::getType() const
{
	if (m_szType == NULL)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	if (m_szType.empty())
	{
		return NULL;
	}

	return m_szType;
}

const TCHAR* CvInfoBase::getButton() const
{
	if (m_szButton.empty())
	{
		return NULL;
	}

	return m_szButton;
}

const wchar* CvInfoBase::getTextKeyWide() const
{
	return m_szTextKey;
}

const wchar* CvInfoBase::getDescription(uint uiForm) const
{
	while(m_aCachedDescriptions.size() <= uiForm)
	{
		m_aCachedDescriptions.push_back(gDLL->getObjectText(m_szTextKey, m_aCachedDescriptions.size()));
	}

	return m_aCachedDescriptions[uiForm];
}

const wchar* CvInfoBase::getText() const
{
	// used instead of getDescription for Info entries that are not objects
	// so they do not have gender/plurality/forms defined in the Translator system
	if(m_szCachedText.empty())
	{
		m_szCachedText = gDLL->getText(m_szTextKey);
	}

	return m_szCachedText;
}

const wchar* CvInfoBase::getCivilopedia() const
{
	if(m_szCachedCivilopedia.empty())
	{
		m_szCachedCivilopedia = gDLL->getText(m_szCivilopediaKey);
	}

	return m_szCachedCivilopedia;
}

const wchar*  CvInfoBase::getHelp() const
{
	if (m_szCachedHelp.empty())
	{
		m_szCachedHelp = gDLL->getText(m_szHelpKey);
	}

	return m_szCachedHelp;
}

const wchar* CvInfoBase::getStrategy() const
{
	if (m_szCachedStrategy.empty())
	{
		m_szCachedStrategy = gDLL->getText(m_szStrategyKey);
	}

	return m_szCachedStrategy;
}

bool CvInfoBase::isMatchForLink(std::wstring szLink, bool bKeysOnly) const
{
	if (szLink == CvWString(getType()).GetCString())
	{
		return true;
	}

	if (!bKeysOnly)
	{
		uint iNumForms = gDLL->getNumForms(getTextKeyWide());
		for (uint i = 0; i < iNumForms; i++)
		{
			if (szLink == getDescription(i))
			{
				return true;
			}
		}
	}

	return false;
}

//
// read from XML
// TYPE, DESC, BUTTON
//
bool CvInfoBase::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	// Skip any comments and stop at the next value we might want
	if (!pXML->SkipToNextVal())
	{
		return false;
	}

	pXML->MapChildren();	// try to hash children for fast lookup by name

	// GRAPHICAL ONLY
	pXML->GetChildXmlValByName(&m_bGraphicalOnly, "bGraphicalOnly");

	// TYPE
	pXML->GetChildXmlValByName(m_szType, "Type");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	Most of this data is read and used immediately, rather than the typical "read and stored"	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bForceOverwrite, "bForceOverwrite");

	if (!GC.isAnyDependency() )
	{
		GC.resetDependencies(); //make sure this always starts empty!

		pXML->GetChildXmlValByName(&GC.getTypeDependency(), "bTypeDependency");
		if ( GC.getTypeDependency() )
		{
			GC.setAnyDependency(true);
		}

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AndDependencyTypes"))
		{
			GC.setAnyDependency(true);

			int iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (pXML->GetChildXmlVal(szTextVal))
			{
				GC.setAndDependencyTypes(szTextVal);

				for ( int iI = 1; iI < iNumChildren; iI++ )
				{
					if (pXML->GetNextXmlVal(szTextVal))
					{
						GC.setAndDependencyTypes(szTextVal);
					}
					else
					{
						break;
					}
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"OrDependencyTypes"))
		{
			GC.setAnyDependency(true);

			int iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (pXML->GetChildXmlVal(szTextVal))
			{
				GC.setOrDependencyTypes(szTextVal);

				for ( int iI = 1; iI < iNumChildren; iI++ )
				{
					if (pXML->GetNextXmlVal(szTextVal))
					{
						GC.setOrDependencyTypes(szTextVal);
					}
					else
					{
						break;
					}
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		if ( GC.isAnyDependency() )
		{
			return false;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	// DESCRIPTION
	pXML->GetChildXmlValByName(m_szTextKey, "Description");

	// CIVILOPEDIA
	pXML->GetChildXmlValByName(m_szCivilopediaKey, "Civilopedia");

	// HELP
	pXML->GetChildXmlValByName(m_szHelpKey, "Help");

	// STRATEGY
	pXML->GetChildXmlValByName(m_szStrategyKey, "Strategy");

	// BUTTON
	pXML->GetChildXmlValByName(m_szButton, "Button");

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**																								**/
/**			Note:  These functions are best understood by looking at CvXMLLoadUtilitySet.		**/
/**					Few of them include new functions from FfH/FF so far						**/
/**	The basic gist of it is that we are going to use the Module, but this function lets us 		**/
/**	save some data from whatever was loaded previously, unless told not to include it all		**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvInfoBase::copyNonDefaults(CvInfoBase* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if(m_bGraphicalOnly	== false)											m_bGraphicalOnly	= pClassInfo->isGraphicalOnly();
	if(getType()			== NULL)				{FAssertMsg(false, "MrGenie Critical error Message! Type MUST be set! iIndex will be illegal without it");}
	else if(getType()		== cDefault)									{m_szType			= pClassInfo->getType();}

	if(getCivilopediaKey()	== NULL || getCivilopediaKey()	== wDefault)	m_szCivilopediaKey	= pClassInfo->getCivilopediaKey();
	if(getHelpKey()			== NULL || getHelpKey()			== wDefault)	m_szHelpKey			= pClassInfo->getHelpKey();
	if(getStrategyKey()		== NULL || getStrategyKey()		== wDefault)	m_szStrategyKey		= pClassInfo->getStrategyKey();
	if(getButton()			== NULL || getButton()			== cDefault)	m_szButton			= pClassInfo->getButton();
	if(getTextKeyWide()		== NULL || getTextKeyWide()		== wDefault)	m_szTextKey			= pClassInfo->getTextKeyWide();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
//======================================================================================================
//					CvScalableInfo
//======================================================================================================
bool CvScalableInfo::read(CvXMLLoadUtility* pXML)
{
	float fScale;
	pXML->GetChildXmlValByName(&fScale, "fScale");
	setScale(fScale);
	pXML->GetChildXmlValByName(&fScale, "fInterfaceScale", 1.0f);
	setInterfaceScale(fScale);
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvScalableInfo::copyNonDefaults(CvScalableInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
    if (GC.getGameINLINE().isOption(GAMEOPTION_ADVENTURE_MODE))
    {
		if (getScale()			== 0.0f)	setScale(				pClassInfo->getScale()/2);
		if (getInterfaceScale()	== 0.5f)	setInterfaceScale(		pClassInfo->getInterfaceScale()*2);
    }
	else
	{
		if (getScale()			== 0.0f)	setScale(				pClassInfo->getScale());
		if (getInterfaceScale()	== 1.0f)	setInterfaceScale(		pClassInfo->getInterfaceScale());
	}
	if (getInterfaceScale()	== 1.0f)	setInterfaceScale(		pClassInfo->getInterfaceScale());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

float CvScalableInfo::getScale() const
{

//FfH Review: Added by Kael 03/15/2008
    if (GC.getGameINLINE().isOption(GAMEOPTION_ADVENTURE_MODE))
    {
        return (m_fScale * 2);
    }
//FfH: End Add

	return m_fScale;
}

void CvScalableInfo::setScale(float fScale)
{
	m_fScale = fScale;
}

float CvScalableInfo::getInterfaceScale() const
{

//FfH: Added by Kael 03/15/2008
    if (GC.getGameINLINE().isOption(GAMEOPTION_ADVENTURE_MODE))
    {
        return (m_fInterfaceScale / 2);
    }
//FfH: End Add

	return m_fInterfaceScale;
}

void CvScalableInfo::setInterfaceScale(float fInterfaceScale)
{
	m_fInterfaceScale = fInterfaceScale;
}


//======================================================================================================
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvHotkeyInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvHotkeyInfo::CvHotkeyInfo() :
m_iActionInfoIndex(-1),
m_iHotKeyVal(-1),
m_iHotKeyPriority(-1),
m_iHotKeyValAlt(-1),
m_iHotKeyPriorityAlt(-1),
m_iOrderPriority(0),
m_bAltDown(false),
m_bShiftDown(false),
m_bCtrlDown(false),
m_bAltDownAlt(false),
m_bShiftDownAlt(false),
m_bCtrlDownAlt(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvHotkeyInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvHotkeyInfo::~CvHotkeyInfo()
{
}

bool CvHotkeyInfo::read(CvXMLLoadUtility* pXML)
{
	int iVal;
	bool bVal;
	CvString szTextVal;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	if (pXML->GetChildXmlValByName(szTextVal, "HotKey"))
	{
		setHotKey(szTextVal);
	}
	else
	{
		setHotKey("");
	}
	iVal = pXML->GetHotKeyInt(szTextVal);
	setHotKeyVal(iVal);
  if (pXML->GetChildXmlValByName(&iVal, "iHotKeyPriority"))
	{
		setHotKeyPriority(iVal);
	}
	else
	{
		setHotKeyPriority(-1);
	}

	if (pXML->GetChildXmlValByName(szTextVal, "HotKeyAlt"))
	{
		iVal = pXML->GetHotKeyInt(szTextVal);
	}
	else
	{
		iVal = pXML->GetHotKeyInt("");
	}
	setHotKeyValAlt(iVal);
	if (pXML->GetChildXmlValByName(&iVal, "iHotKeyPriorityAlt"))
	{
		setHotKeyPriorityAlt(iVal);
	}
	else
	{
		setHotKeyPriorityAlt(-1);
	}

	if (pXML->GetChildXmlValByName(&bVal, "bAltDown"))
	{
		setAltDown(bVal);
	}
	else
	{
		setAltDown(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bShiftDown"))
	{
		setShiftDown(bVal);
	}
	else
	{
		setShiftDown(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bCtrlDown"))
	{
		setCtrlDown(bVal);
	}
	else
	{
		setCtrlDown(false);
	}

	if (pXML->GetChildXmlValByName(&bVal, "bAltDownAlt"))
	{
		setAltDownAlt(bVal);
	}
	else
	{
		setAltDownAlt(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bShiftDownAlt"))
	{
		setShiftDownAlt(bVal);
	}
	else
	{
		setShiftDownAlt(false);
	}
	if (pXML->GetChildXmlValByName(&bVal, "bCtrlDownAlt"))
	{
		setCtrlDownAlt(bVal);
	}
	else
	{
		setCtrlDownAlt(false);
	}
	if (pXML->GetChildXmlValByName(&iVal, "iOrderPriority"))
	{
		setOrderPriority(iVal);
	}
	else
	{
		setOrderPriority(5);
	}

	setHotKeyDescription(getTextKeyWide(), NULL, pXML->CreateHotKeyFromDescription(getHotKey(), m_bShiftDown, m_bAltDown, m_bCtrlDown));

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvHotkeyInfo::copyNonDefaults(CvHotkeyInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if(getHotKeyVal()				== 0)				m_iHotKeyVal					= pClassInfo->getHotKeyVal();
	if(getHotKeyPriority()			== 0)				m_iHotKeyPriority				= pClassInfo->getHotKeyPriority();
	if(getHotKeyValAlt()			== 0)				m_iHotKeyValAlt					= pClassInfo->getHotKeyValAlt();
	if(getHotKeyPriorityAlt()		== 0)				m_iHotKeyPriorityAlt			= pClassInfo->getHotKeyPriorityAlt();
	if(getOrderPriority()			== 0)				m_iOrderPriority				= pClassInfo->getOrderPriority();
	if(isAltDown()					== false)			m_bAltDown						= pClassInfo->isAltDown();
	if(isShiftDown()				== false)			m_bShiftDown					= pClassInfo->isShiftDown();
	if(isCtrlDown()					== false)			m_bCtrlDown						= pClassInfo->isCtrlDown();
	if(isAltDownAlt()				== false)			m_bAltDownAlt					= pClassInfo->isAltDownAlt();
	if(isShiftDownAlt()				== false)			m_bShiftDownAlt					= pClassInfo->isShiftDownAlt();
	if(isCtrlDownAlt()				== false)			m_bCtrlDownAlt					= pClassInfo->isCtrlDownAlt();
	if(getHotKey()					== cDefault)		m_szHotKey						= pClassInfo->getHotKey();
	if(getHotKeyDescriptionKey()	== wDefault)		m_szHotKeyDescriptionKey		= pClassInfo->getHotKeyDescriptionKey();
	if(getHotKeyAltDescriptionKey()	== wDefault)		m_szHotKeyAltDescriptionKey		= pClassInfo->getHotKeyAltDescriptionKey();
	if(getHotKeyString()			== wDefault)		m_szHotKeyString				= pClassInfo->getHotKeyString();
}
const WCHAR* CvHotkeyInfo::getHotKeyDescriptionKey() const		{return m_szHotKeyDescriptionKey;}
const WCHAR* CvHotkeyInfo::getHotKeyAltDescriptionKey() const	{return m_szHotKeyAltDescriptionKey;}
const WCHAR* CvHotkeyInfo::getHotKeyString() const				{return m_szHotKeyString;}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
void CvHotkeyInfo::read(FDataStreamBase* pStream)
{
	CvInfoBase::read(pStream);

	uint uiFlag=0;
	pStream->Read(&uiFlag);	// flags for expansion

	pStream->Read(&m_iHotKeyVal);
	pStream->Read(&m_iHotKeyPriority);
	pStream->Read(&m_iHotKeyValAlt);
	pStream->Read(&m_iHotKeyPriorityAlt);
	pStream->Read(&m_iOrderPriority);
	pStream->Read(&m_bAltDown);
	pStream->Read(&m_bShiftDown);
	pStream->Read(&m_bCtrlDown);
	pStream->Read(&m_bAltDownAlt);
	pStream->Read(&m_bShiftDownAlt);
	pStream->Read(&m_bCtrlDownAlt);
	pStream->ReadString(m_szHotKey);
	pStream->ReadString(m_szHotKeyDescriptionKey);
	pStream->ReadString(m_szHotKeyAltDescriptionKey);
	pStream->ReadString(m_szHotKeyString);
}

void CvHotkeyInfo::write(FDataStreamBase* pStream)
{
	CvInfoBase::write(pStream);

	uint uiFlag = 0;
	pStream->Write(uiFlag);		// flag for expansion

	pStream->Write(m_iHotKeyVal);
	pStream->Write(m_iHotKeyPriority);
	pStream->Write(m_iHotKeyValAlt);
	pStream->Write(m_iHotKeyPriorityAlt);
	pStream->Write(m_iOrderPriority);
	pStream->Write(m_bAltDown);
	pStream->Write(m_bShiftDown);
	pStream->Write(m_bCtrlDown);
	pStream->Write(m_bAltDownAlt);
	pStream->Write(m_bShiftDownAlt);
	pStream->Write(m_bCtrlDownAlt);
	pStream->WriteString(m_szHotKey);
	pStream->WriteString(m_szHotKeyDescriptionKey);
	pStream->WriteString(m_szHotKeyAltDescriptionKey);
	pStream->WriteString(m_szHotKeyString);
}

int CvHotkeyInfo::getActionInfoIndex() const
{
	return m_iActionInfoIndex;
}

void CvHotkeyInfo::setActionInfoIndex(int i)
{
	m_iActionInfoIndex = i;
}

int CvHotkeyInfo::getHotKeyVal() const
{
	return m_iHotKeyVal;
}

void CvHotkeyInfo::setHotKeyVal(int i)
{
	m_iHotKeyVal = i;
}

int CvHotkeyInfo::getHotKeyPriority() const
{
	return m_iHotKeyPriority;
}

void CvHotkeyInfo::setHotKeyPriority(int i)
{
	m_iHotKeyPriority = i;
}

int CvHotkeyInfo::getHotKeyValAlt() const
{
	return m_iHotKeyValAlt;
}

void CvHotkeyInfo::setHotKeyValAlt(int i)
{
	m_iHotKeyValAlt = i;
}

int CvHotkeyInfo::getHotKeyPriorityAlt() const
{
	return m_iHotKeyPriorityAlt;
}

void CvHotkeyInfo::setHotKeyPriorityAlt(int i)
{
	m_iHotKeyPriorityAlt = i;
}

int CvHotkeyInfo::getOrderPriority() const
{
	return m_iOrderPriority;
}

void CvHotkeyInfo::setOrderPriority(int i)
{
	m_iOrderPriority = i;
}

bool CvHotkeyInfo::isAltDown() const
{
	return m_bAltDown;
}

void CvHotkeyInfo::setAltDown(bool b)
{
	m_bAltDown = b;
}

bool CvHotkeyInfo::isShiftDown() const
{
	return m_bShiftDown;
}

void CvHotkeyInfo::setShiftDown(bool b)
{
	m_bShiftDown = b;
}

bool CvHotkeyInfo::isCtrlDown() const
{
	return m_bCtrlDown;
}

void CvHotkeyInfo::setCtrlDown(bool b)
{
	m_bCtrlDown = b;
}

bool CvHotkeyInfo::isAltDownAlt() const
{
	return m_bAltDownAlt;
}

void CvHotkeyInfo::setAltDownAlt(bool b)
{
	m_bAltDownAlt = b;
}

bool CvHotkeyInfo::isShiftDownAlt() const
{
	return m_bShiftDownAlt;
}

void CvHotkeyInfo::setShiftDownAlt(bool b)
{
	m_bShiftDownAlt = b;
}

bool CvHotkeyInfo::isCtrlDownAlt() const
{
	return m_bCtrlDownAlt;
}

void CvHotkeyInfo::setCtrlDownAlt(bool b)
{
	m_bCtrlDownAlt = b;
}

const TCHAR* CvHotkeyInfo::getHotKey() const
{
	return m_szHotKey;
}

void CvHotkeyInfo::setHotKey(const TCHAR* szVal)
{
	m_szHotKey = szVal;
}

std::wstring CvHotkeyInfo::getHotKeyDescription() const
{
	CvWString szTemptext;
	if (!m_szHotKeyAltDescriptionKey.empty())
	{
		szTemptext.Format(L"%s (%s)", gDLL->getObjectText(m_szHotKeyAltDescriptionKey, 0).GetCString(), gDLL->getObjectText(m_szHotKeyDescriptionKey, 0).GetCString());
	}
	else
	{
		szTemptext = gDLL->getObjectText(m_szHotKeyDescriptionKey, 0);
	}

	if (!m_szHotKeyString.empty())
	{
		szTemptext += m_szHotKeyString;
	}

	return szTemptext;
}

void CvHotkeyInfo::setHotKeyDescription(const wchar* szHotKeyDescKey, const wchar* szHotKeyAltDescKey, const wchar* szHotKeyString)
{
	m_szHotKeyDescriptionKey = szHotKeyDescKey;
	m_szHotKeyAltDescriptionKey = szHotKeyAltDescKey;
	m_szHotKeyString = szHotKeyString;
}

//======================================================================================================
//					CvDiplomacyResponse
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvDiplomacyResponse()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyResponse::CvDiplomacyResponse() :
m_iNumDiplomacyText(0),
m_pbCivilizationTypes(NULL),
m_pbLeaderHeadTypes(NULL),
m_pbAttitudeTypes(NULL),
m_pbDiplomacyPowerTypes(NULL),
m_paszDiplomacyText(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDiplomacyResponse()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyResponse::~CvDiplomacyResponse()
{
	SAFE_DELETE_ARRAY(m_pbCivilizationTypes);
	SAFE_DELETE_ARRAY(m_pbLeaderHeadTypes);
	SAFE_DELETE_ARRAY(m_pbAttitudeTypes);
	SAFE_DELETE_ARRAY(m_pbDiplomacyPowerTypes);
	SAFE_DELETE_ARRAY(m_paszDiplomacyText);
}

int CvDiplomacyResponse::getNumDiplomacyText()
{
	return m_iNumDiplomacyText;
}

void CvDiplomacyResponse::setNumDiplomacyText(int i)
{
	m_iNumDiplomacyText = i;
}

bool CvDiplomacyResponse::getCivilizationTypes(int i)
{
	FAssertMsg(i < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationTypes[i];
}

bool* CvDiplomacyResponse::getCivilizationTypes() const
{
	return m_pbCivilizationTypes;
}

void CvDiplomacyResponse::setCivilizationTypes(int i, bool bVal)
{
	FAssertMsg(i < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbCivilizationTypes[i] = bVal;
}

bool CvDiplomacyResponse::getLeaderHeadTypes(int i)
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbLeaderHeadTypes[i];
}

bool* CvDiplomacyResponse::getLeaderHeadTypes() const
{
	return m_pbLeaderHeadTypes;
}

void CvDiplomacyResponse::setLeaderHeadTypes(int i, bool bVal)
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbLeaderHeadTypes[i] = bVal;
}

bool CvDiplomacyResponse::getAttitudeTypes(int i) const
{
	FAssertMsg(i < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbAttitudeTypes[i];
}

bool* CvDiplomacyResponse::getAttitudeTypes() const
{
	return m_pbAttitudeTypes;
}

void CvDiplomacyResponse::setAttitudeTypes(int i, bool bVal)
{
	FAssertMsg(i < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbAttitudeTypes[i] = bVal;
}

bool CvDiplomacyResponse::getDiplomacyPowerTypes(int i)
{
	FAssertMsg(i < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbDiplomacyPowerTypes[i];
}

bool* CvDiplomacyResponse::getDiplomacyPowerTypes() const
{
	return m_pbDiplomacyPowerTypes;
}

void CvDiplomacyResponse::setDiplomacyPowerTypes(int i, bool bVal)
{
	FAssertMsg(i < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_pbDiplomacyPowerTypes[i] = bVal;
}

const TCHAR* CvDiplomacyResponse::getDiplomacyText(int i) const
{
	return m_paszDiplomacyText[i];
}

const CvString* CvDiplomacyResponse::getDiplomacyText() const
{
	return m_paszDiplomacyText;
}

void CvDiplomacyResponse::setDiplomacyText(int i, CvString szText)
{
	FAssertMsg(i < getNumDiplomacyText(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszDiplomacyText[i] = szText;
}

void CvDiplomacyResponse::read(FDataStreamBase* stream)
{
	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iNumDiplomacyText);

	SAFE_DELETE_ARRAY(m_pbCivilizationTypes);
	m_pbCivilizationTypes = new bool[GC.getNumCivilizationInfos()];
	stream->Read(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);

	SAFE_DELETE_ARRAY(m_pbLeaderHeadTypes);
	m_pbLeaderHeadTypes = new bool[GC.getNumLeaderHeadInfos()];
	stream->Read(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);

	SAFE_DELETE_ARRAY(m_pbAttitudeTypes);
	m_pbAttitudeTypes = new bool[NUM_ATTITUDE_TYPES];
	stream->Read(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);

	SAFE_DELETE_ARRAY(m_pbDiplomacyPowerTypes);
	m_pbDiplomacyPowerTypes = new bool[NUM_DIPLOMACYPOWER_TYPES];
	stream->Read(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);

	SAFE_DELETE_ARRAY(m_paszDiplomacyText);
	m_paszDiplomacyText = new CvString[m_iNumDiplomacyText];
	stream->ReadString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

void CvDiplomacyResponse::write(FDataStreamBase* stream)
{
	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iNumDiplomacyText);

	stream->Write(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);
	stream->Write(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);
	stream->Write(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);
	stream->Write(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);
	stream->WriteString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

bool CvDiplomacyResponse::read(CvXMLLoadUtility* pXML)
{
	pXML->SetVariableListTagPair(&m_pbCivilizationTypes, "Civilizations", sizeof(GC.getCivilizationInfo((CivilizationTypes)0)), GC.getNumCivilizationInfos());
	// Leaders
	pXML->SetVariableListTagPair(&m_pbLeaderHeadTypes, "Leaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());
	// AttitudeTypes
	pXML->SetVariableListTagPair(&m_pbAttitudeTypes, "Attitudes", sizeof(GC.getAttitudeInfo((AttitudeTypes)0)), NUM_ATTITUDE_TYPES);
	// PowerTypes
	pXML->SetVariableListTagPair(&m_pbDiplomacyPowerTypes, "DiplomacyPowers", GC.getDiplomacyPowerTypes(), NUM_DIPLOMACYPOWER_TYPES);
	// DiplomacyText
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"DiplomacyText"))
	{
		pXML->SetStringList(&m_paszDiplomacyText, &m_iNumDiplomacyText);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvDiplomacyResponse::UpdateDiplomacies(CvDiplomacyInfo* pDiplomacyInfo, int iIndex)
{
	bool bDefault = false;
	CvXMLLoadUtilityModTools* pModTools = new CvXMLLoadUtilityModTools;

	// We use the String append mechanism from WOC default = assume the modder added his strings
	// purposly, so those are on the first place, the strings previously are appended after them
	CvString* m_paszNewNames = new CvString[pDiplomacyInfo->getNumDiplomacyText(iIndex)];
	for ( int i = 0; i < pDiplomacyInfo->getNumDiplomacyText(iIndex); i++)
	{
		m_paszNewNames[i] = pDiplomacyInfo->getDiplomacyText(iIndex, i);
	}

	pModTools->StringArrayExtend(&m_paszDiplomacyText, &m_iNumDiplomacyText, &m_paszNewNames, pDiplomacyInfo->getNumDiplomacyText(iIndex));
	SAFE_DELETE_ARRAY(m_paszNewNames);
	SAFE_DELETE(pModTools);

	// if anything is true, we don't overwrite(assuming the modder did set it true purposly
	for ( int i = 0; i < GC.getNumLeaderHeadInfos(); ++i)
	{
		if (m_pbLeaderHeadTypes[i] == bDefault)
		{
			m_pbLeaderHeadTypes[i] = pDiplomacyInfo->getLeaderHeadTypes(iIndex, i);
		}
	}
	for ( int i = 0; i < NUM_ATTITUDE_TYPES; ++i)
	{
		if (m_pbAttitudeTypes[i] == bDefault)
		{
			m_pbAttitudeTypes[i] = pDiplomacyInfo->getAttitudeTypes(iIndex, i);
		}
	}
	for ( int i = 0; i < NUM_DIPLOMACYPOWER_TYPES; ++i)
	{
		if (m_pbDiplomacyPowerTypes[i] == bDefault)
		{
			m_pbDiplomacyPowerTypes[i] = pDiplomacyInfo->getDiplomacyPowerTypes(iIndex, i);
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSpecialistInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpecialistInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialistInfo::CvSpecialistInfo() :
m_iGreatPeopleUnitClass(NO_UNITCLASS),
m_iGreatPeopleRateChange(0),
m_iMissionType(NO_MISSION),
m_bVisible(false),
m_piYieldChange(NULL),
m_piCommerceChange(NULL),
m_piFlavorValue(NULL),
m_iExperience(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpecialistInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialistInfo::~CvSpecialistInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piCommerceChange);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
}

int CvSpecialistInfo::getGreatPeopleUnitClass() const
{
	return m_iGreatPeopleUnitClass;
}

int CvSpecialistInfo::getGreatPeopleRateChange() const
{
	return m_iGreatPeopleRateChange;
}

int CvSpecialistInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvSpecialistInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

bool CvSpecialistInfo::isVisible() const
{
	return m_bVisible;
}

int CvSpecialistInfo::getExperience() const
{
	return m_iExperience;
}

// Arrays

int CvSpecialistInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

const int* CvSpecialistInfo::getYieldChangeArray() const
{
	return m_piYieldChange;
}

int CvSpecialistInfo::getCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceChange ? m_piCommerceChange[i] : -1;
}

int CvSpecialistInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

const TCHAR* CvSpecialistInfo::getTexture() const
{
	return m_szTexture;
}

void CvSpecialistInfo::setTexture(const TCHAR* szVal)
{
	m_szTexture = szVal;
}

//
// read from xml
//
bool CvSpecialistInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Texture");
	setTexture(szTextVal);

	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	pXML->GetChildXmlValByName(szTextVal, "GreatPeopleUnitClass");
	m_iGreatPeopleUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iGreatPeopleRateChange, "iGreatPeopleRateChange");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Yields"))
	{
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Commerces"))
	{
		pXML->SetCommerce(&m_piCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceChange, NUM_COMMERCE_TYPES);
	}

	pXML->GetChildXmlValByName(&m_iExperience, "iExperience");

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpecialistInfo::copyNonDefaults(CvSpecialistInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isVisible()					== false)				m_bVisible					= pClassInfo->isVisible();
	if (getGreatPeopleRateChange()	== 0)					m_iGreatPeopleRateChange	= pClassInfo->getGreatPeopleRateChange();
	if (getExperience()				== 0.0f)				m_iExperience				= pClassInfo->getExperience();
	if (getTexture()				== cDefault)			setTexture(					pClassInfo->getTexture());
	if (getGreatPeopleUnitClass()	== NO_UNITCLASS)		m_iGreatPeopleUnitClass		= pClassInfo->getGreatPeopleUnitClass();
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if(getYieldChange(i)		== 0)					m_piYieldChange[i]			= pClassInfo->getYieldChange(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if(getCommerceChange(i)		== 0)					m_piCommerceChange[i]		= pClassInfo->getCommerceChange(i);
	}
	for ( int i = 0; i < GC.getNumFlavorTypes(); i++ )
	{
		if(getFlavorValue(i)		== 0)					m_piFlavorValue[i]			= pClassInfo->getFlavorValue(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvTechInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTechInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTechInfo::CvTechInfo() :
m_iAdvisorType(NO_ADVISOR),
m_iAIWeight(0),
m_iAITradeModifier(0),
m_iResearchCost(0),
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iEra(NO_ERA),
m_iTradeRoutes(0),
m_iFeatureProductionModifier(0),
m_iWorkerSpeedModifier(0),
m_iFirstFreeUnitClass(NO_UNITCLASS),
m_iFreeUnitClass(NO_UNITCLASS),
m_iHealth(0),
m_iHappiness(0),
m_iFirstFreeTechs(0),
m_iAssetValue(0),
m_iPowerValue(0),
m_iGridX(0),
m_iGridY(0),
m_bRepeat(false),
m_bTrade(false),
m_bDisable(false),
m_bGoodyTech(false),
m_bHolyKnowledge(false),
m_bExtraWaterSeeFrom(false),
m_bMapCentering(false),
m_bMapVisible(false),
m_bMapTrading(false),
m_bTechTrading(false),
m_bGoldTrading(false),
m_bOpenBordersTrading(false),
m_bDefensivePactTrading(false),
m_bPermanentAllianceTrading(false),
m_bVassalStateTrading(false),
m_bBridgeBuilding(false),
m_bIrrigation(false),
m_bIgnoreIrrigation(false),
m_bWaterWork(false),
m_bRiverTrade(false),
m_piDomainExtraMoves(NULL),
m_piFlavorValue(NULL),
m_piPrereqOrTechs(NULL),
m_piPrereqAndTechs(NULL),
m_pbCommerceFlexible(NULL),
m_ppiReligionCommerceModifiers(NULL),
m_pbTerrainTrade(NULL),

//FfH Techs: Added by Kael 08/09/2007
m_bWater(false),
m_iPreferredAlignment(NO_ALIGNMENT),
m_iBlockedbyAlignment(NO_ALIGNMENT),
m_iPrereqReligion(NO_RELIGION),
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
 m_paiCorporationSupport(NULL),
 m_paiCorporationSupportMod(NULL),

m_iReligionType(NO_RELIGION),
m_bAllowAnimalTaming(false),
m_bAllowGuild(false),
m_bAllowReligion(false),
m_bGuild(false),
m_bReligion(false),
m_bCulturalAchievement(false),
m_bDrawNoOrPrereqArrows(false),
m_bDrawNoAndPrereqArrows(false),
m_iArcaneAuraPromotion(NO_PROMOTION),
m_iNumPrereqSpellResearchFromSameSchool(0),
m_iWillpowerChange(0),
m_iReducedTerraformCost(0),
m_iReducedEnchantmentCost(0),
m_iReducedSummonCost(0),
m_bIncreaseTerraformTiles(false),
m_bIncreaseHostileTerraformTiles(false),
m_iIncreaseSummonXP(0),
m_iIncreaseMaxMana(0),
m_iIncreaseMana(0),
m_iIncreaseManaFromNodes(0),
m_iIncreaseStrengthOfRegularUnits(0),
m_iPrereqBonus(NO_BONUS),

m_paiSpellDamageChanges(NULL)

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTechInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTechInfo::~CvTechInfo()
{
	SAFE_DELETE_ARRAY(m_piDomainExtraMoves);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piPrereqOrTechs);
	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);

	if (m_ppiReligionCommerceModifiers != NULL)
	{
		for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiReligionCommerceModifiers[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiReligionCommerceModifiers);
	}

	SAFE_DELETE_ARRAY(m_pbTerrainTrade);
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	SAFE_DELETE_ARRAY(m_paiSpellDamageChanges);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

int CvTechInfo::getAdvisorType() const
{
	return m_iAdvisorType;
}

int CvTechInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvTechInfo::getAITradeModifier() const
{
	return m_iAITradeModifier;
}

int CvTechInfo::getResearchCost() const
{
	//added
	if(!isSpellResearch() && !isCulturalAchievement() && !isDisable() && !isHolyKnowledge())
	{
		if(getEra() != NO_ERA)
		{
			return GC.getEraInfo((EraTypes)getEra()).getBaseTechCost() + m_iResearchCost;
		}
	}
	if(isSpellResearch())
	{
		if(getEra() != NO_ERA)
		{
			return GC.getEraInfo((EraTypes)getEra()).getBaseSpellresearchCost() + m_iResearchCost;
		}
	}
	//added
	return m_iResearchCost;
}

int CvTechInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvTechInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvTechInfo::getEra() const
{
	return m_iEra;
}

int CvTechInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvTechInfo::getFeatureProductionModifier() const
{
	return m_iFeatureProductionModifier;
}

int CvTechInfo::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}

int CvTechInfo::getFirstFreeUnitClass() const
{
	return m_iFirstFreeUnitClass;
}

int CvTechInfo::getFreeUnitClass() const
{
	return m_iFreeUnitClass;
}

int CvTechInfo::getHealth() const
{
	return m_iHealth;
}

int CvTechInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvTechInfo::getFirstFreeTechs() const
{
	return m_iFirstFreeTechs;
}

int CvTechInfo::getAssetValue() const
{
	return m_iAssetValue;
}

int CvTechInfo::getPowerValue() const
{
	return m_iPowerValue;
}

int CvTechInfo::getGridX() const
{
	return m_iGridX;
}

int CvTechInfo::getGridY() const
{
	return m_iGridY;
}

bool CvTechInfo::isRepeat() const
{
	return m_bRepeat;
}

bool CvTechInfo::isTrade() const
{
	return m_bTrade;
}

bool CvTechInfo::isDisable() const
{
	return m_bDisable;
}

bool CvTechInfo::isGoodyTech() const
{
	return m_bGoodyTech;
}

bool CvTechInfo::isHolyKnowledge() const
{
	return m_bHolyKnowledge;
}

bool CvTechInfo::isExtraWaterSeeFrom() const
{
	return m_bExtraWaterSeeFrom;
}

bool CvTechInfo::isMapCentering() const
{
	return m_bMapCentering;
}

bool CvTechInfo::isMapVisible() const
{
	return m_bMapVisible;
}

bool CvTechInfo::isMapTrading() const
{
	return m_bMapTrading;
}

bool CvTechInfo::isTechTrading() const
{
	return m_bTechTrading;
}

bool CvTechInfo::isGoldTrading() const
{
	return m_bGoldTrading;
}

bool CvTechInfo::isOpenBordersTrading() const
{
	return m_bOpenBordersTrading;
}

bool CvTechInfo::isDefensivePactTrading() const
{
	return m_bDefensivePactTrading;
}

bool CvTechInfo::isPermanentAllianceTrading() const
{
	return m_bPermanentAllianceTrading;
}

bool CvTechInfo::isVassalStateTrading() const
{
	return m_bVassalStateTrading;
}

bool CvTechInfo::isBridgeBuilding() const
{
	return m_bBridgeBuilding;
}

bool CvTechInfo::isIrrigation() const
{
	return m_bIrrigation;
}

bool CvTechInfo::isIgnoreIrrigation() const
{
	return m_bIgnoreIrrigation;
}

bool CvTechInfo::isWaterWork() const
{
	return m_bWaterWork;
}

bool CvTechInfo::isRiverTrade() const
{
	return m_bRiverTrade;
}

std::wstring CvTechInfo::getQuote()	const
{
	return gDLL->getText(m_szQuoteKey);
}

void CvTechInfo::setQuoteKey(const TCHAR* szVal)
{
	m_szQuoteKey = szVal;
}

const TCHAR* CvTechInfo::getSound() const
{
	return m_szSound;
}

void CvTechInfo::setSound(const TCHAR* szVal)
{
	m_szSound = szVal;
}

const TCHAR* CvTechInfo::getSoundMP() const
{
	return m_szSoundMP;
}

void CvTechInfo::setSoundMP(const TCHAR* szVal)
{
	m_szSoundMP = szVal;
}

//FfH Techs: Added by Kael 08/09/2007
bool CvTechInfo::isWater() const
{
	return m_bWater;
}

int CvTechInfo::getPreferredAlignment() const
{
	return m_iPreferredAlignment;
}

int CvTechInfo::getBlockedbyAlignment() const
{
	return m_iBlockedbyAlignment;
}

int CvTechInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvTechInfo::getCorporationSupport(int eCorporation) const
{
	return m_paiCorporationSupport[eCorporation];
}

int CvTechInfo::getCorporationSupportMultiplier(int eCorporation) const
{
	return m_paiCorporationSupportMod[eCorporation];
}

int CvTechInfo::getCorporationSupportVectorSize()					{return m_aszCorporationSupportforPass3.size();}
CvString CvTechInfo::getCorporationSupportNamesVectorElement(int i)	{return m_aszCorporationSupportforPass3[i];}
int CvTechInfo::getCorporationSupportValuesVectorElement(int i)		{return m_aiCorporationSupportforPass3[i];}

int CvTechInfo::getCorporationSupportModVectorSize()					{return m_aszCorporationSupportModforPass3.size();}
CvString CvTechInfo::getCorporationSupportModNamesVectorElement(int i)	{return m_aszCorporationSupportModforPass3[i];}
int CvTechInfo::getCorporationSupportModValuesVectorElement(int i)		{return m_aiCorporationSupportModforPass3[i];}


int CvTechInfo::getReligionCommerceTechRateModifier(int religionType, int eIndex) const
{
	FAssertMsg(religionType >= 0, "religionType is expected to be non-negative (invalid Index)");
	FAssertMsg(religionType < GC.getNumReligionInfos(), "religionType is expected to be within maximum bounds (invalid Index)");

	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	FAssertMsg(eIndex < NUM_COMMERCE_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_ppiReligionCommerceModifiers[religionType][eIndex];
}

bool CvTechInfo::isSpellResearch() const
{
	return (getSpellSchool()!=NO_MANASCHOOL);
}

int CvTechInfo::getSpellSchool() const
{
	for(int iI=0;iI<GC.getNumManaschoolInfos();iI++)
	{
		if(GC.getManaschoolInfo((ManaschoolTypes)iI).getTechLevel(GC.getInfoTypeForString(getType()))>0)
		{
			return iI;
		}
	}
	return NO_MANASCHOOL;
}

int CvTechInfo::getSpellResearchLevel()
{
	for(int iI=0;iI<GC.getNumManaschoolInfos();iI++)
	{
		int iLevel=GC.getManaschoolInfo((ManaschoolTypes)iI).getTechLevel(GC.getInfoTypeForString(getType()));
		if(iLevel>0)
		{
			return iLevel;
		}
	}

	return 0;
}

bool CvTechInfo::isTemporaryTech()
{
	for(int iI=0;iI<GC.getNumProjectInfos();iI++)
	{
		if(GC.getProjectInfo((ProjectTypes)iI).getTemporaryTech()==GC.getInfoTypeForString(getType()))
		{
			return true;
		}
	}
	return false;
}

int CvTechInfo::getReligionType()
{
	return m_iReligionType;
}

bool CvTechInfo::isAllowAnimalTaming() const
{
	return m_bAllowAnimalTaming;
}

bool CvTechInfo::isAllowGuild() const
{
	return m_bAllowGuild;
}

bool CvTechInfo::isAllowReligion() const
{
	return m_bAllowReligion;
}

bool CvTechInfo::isGuild() const
{
	return m_bGuild;
}

bool CvTechInfo::isReligion() const
{
	return m_bReligion;
}

bool CvTechInfo::isCulturalAchievement() const
{
	return m_bCulturalAchievement;
}

bool CvTechInfo::isDrawNoOrPrereqArrows()
{
	return m_bDrawNoOrPrereqArrows;
}

bool CvTechInfo::isDrawNoAndPrereqArrows()
{
	return m_bDrawNoAndPrereqArrows;
}

int CvTechInfo::getArcaneAuraPromotion() const
{
	return m_iArcaneAuraPromotion;
}

int CvTechInfo::getNumPrereqSpellResearchFromSameSchool() const
{
	return m_iNumPrereqSpellResearchFromSameSchool;
}

int CvTechInfo::getWillpowerChange() const
{
	return m_iWillpowerChange;
}

int CvTechInfo::getReducedTerraformCost() const
{
	return m_iReducedTerraformCost;
}

int CvTechInfo::getReducedEnchantmentCost() const
{
	return m_iReducedEnchantmentCost;
}

int CvTechInfo::getReducedSummonCost() const
{
	return m_iReducedSummonCost;
}

bool CvTechInfo::isIncreaseTerraformTiles() const
{
	return m_bIncreaseTerraformTiles;
}

bool CvTechInfo::isIncreaseHostileTerraformTiles() const
{
	return m_bIncreaseHostileTerraformTiles;
}

int CvTechInfo::getIncreaseSummonXP() const
{
	return m_iIncreaseSummonXP;
}

int CvTechInfo::getIncreaseMaxMana() const
{
	return m_iIncreaseMaxMana;
}

int CvTechInfo::getIncreaseMana() const
{
	return m_iIncreaseMana;
}

int CvTechInfo::getIncreaseManaFromNodes() const
{
	return m_iIncreaseManaFromNodes;
}

int CvTechInfo::getIncreaseStrengthOfRegularUnits() const
{
	return m_iIncreaseStrengthOfRegularUnits;
}

int CvTechInfo::getPrereqBonus() const
{
	return m_iPrereqBonus;
}

int CvTechInfo::getSpellDamageChange(int iDamagetype) const
{
	return m_paiSpellDamageChanges[iDamagetype];
}

const TCHAR* CvTechInfo::getPyRequirement() const
{
	return m_szPyRequirement;
}

const TCHAR* CvTechInfo::getPicture() const
{
	if(m_szPicture.IsEmpty()) {
		if(getSpellSchool() != NO_MANASCHOOL) {
			return GC.getManaschoolInfo((ManaschoolTypes)getSpellSchool()).getPicture();
		}
		else {
			return NULL;
		}
	}
	return m_szPicture;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Arrays

int CvTechInfo::getDomainExtraMoves(int i) const
{
	return m_piDomainExtraMoves ? m_piDomainExtraMoves[i] : -1;
}

int CvTechInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvTechInfo::getPrereqOrTechs(int i) const
{
	return m_piPrereqOrTechs ? m_piPrereqOrTechs[i] : -1;
}

int CvTechInfo::getPrereqAndTechs(int i) const
{
	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;
}

bool CvTechInfo::isCommerceFlexible(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCommerceFlexible ? m_pbCommerceFlexible[i] : false;
}

bool CvTechInfo::isTerrainTrade(int i) const
{
	return m_pbTerrainTrade ? m_pbTerrainTrade[i] : false;
}

void CvTechInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iAdvisorType);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iAITradeModifier);
	stream->Read(&m_iResearchCost);
	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);
	stream->Read(&m_iEra);
	stream->Read(&m_iFirstFreeUnitClass);
	stream->Read(&m_iFreeUnitClass);
	stream->Read(&m_iFeatureProductionModifier);
	stream->Read(&m_iWorkerSpeedModifier);
	stream->Read(&m_iTradeRoutes);
	stream->Read(&m_iHealth);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iFirstFreeTechs);
	stream->Read(&m_iAssetValue);
	stream->Read(&m_iPowerValue);
	stream->Read(&m_bRepeat);
	stream->Read(&m_bTrade);
	stream->Read(&m_bDisable);
	stream->Read(&m_bGoodyTech);
	stream->Read(&m_bHolyKnowledge);
	stream->Read(&m_bExtraWaterSeeFrom);
	stream->Read(&m_bMapCentering);
	stream->Read(&m_bMapVisible);
	stream->Read(&m_bMapTrading);
	stream->Read(&m_bTechTrading);
	stream->Read(&m_bGoldTrading);
	stream->Read(&m_bOpenBordersTrading);
	stream->Read(&m_bDefensivePactTrading);
	stream->Read(&m_bPermanentAllianceTrading);
	stream->Read(&m_bVassalStateTrading);
	stream->Read(&m_bBridgeBuilding);
	stream->Read(&m_bIrrigation);
	stream->Read(&m_bIgnoreIrrigation);
	stream->Read(&m_bWaterWork);
	stream->Read(&m_bRiverTrade);
	stream->Read(&m_iGridX);
	stream->Read(&m_iGridY);

	SAFE_DELETE_ARRAY(m_piDomainExtraMoves);
	m_piDomainExtraMoves = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainExtraMoves);

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piPrereqOrTechs);
	m_piPrereqOrTechs = new int[GC.getNUM_OR_TECH_PREREQS()];
	stream->Read(GC.getNUM_OR_TECH_PREREQS(), m_piPrereqOrTechs);

	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	m_piPrereqAndTechs = new int[GC.getNUM_AND_TECH_PREREQS()];
	stream->Read(GC.getNUM_AND_TECH_PREREQS(), m_piPrereqAndTechs);

	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);
	m_pbCommerceFlexible = new bool[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);

	int i;
	if (m_ppiReligionCommerceModifiers != NULL)
	{
		for (i = 0; i < GC.getNumReligionInfos(); i++)
		{
			SAFE_DELETE_ARRAY(m_ppiReligionCommerceModifiers[i]);
		}
		SAFE_DELETE_ARRAY(m_ppiReligionCommerceModifiers);
	}
	m_ppiReligionCommerceModifiers = new int* [GC.getNumReligionInfos()];
	for (i = 0; i < GC.getNumReligionInfos(); i++)
	{
		m_ppiReligionCommerceModifiers[i] = new int[NUM_COMMERCE_TYPES];
		stream->Read(NUM_COMMERCE_TYPES, m_ppiReligionCommerceModifiers[i]);
	}

	SAFE_DELETE_ARRAY(m_pbTerrainTrade);
	m_pbTerrainTrade = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainTrade);

	stream->ReadString(m_szQuoteKey);
	stream->ReadString(m_szSound);
	stream->ReadString(m_szSoundMP);

//FfH Techs: Added by Kael 08/09/2007
	stream->Read(&m_bWater);
	stream->Read(&m_iPreferredAlignment);
	stream->Read(&m_iPrereqReligion);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupport);

	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

void CvTechInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iAdvisorType);
	stream->Write(m_iAIWeight);
	stream->Write(m_iAITradeModifier);
	stream->Write(m_iResearchCost);
	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);
	stream->Write(m_iEra);
	stream->Write(m_iFirstFreeUnitClass);
	stream->Write(m_iFreeUnitClass);
	stream->Write(m_iFeatureProductionModifier);
	stream->Write(m_iWorkerSpeedModifier);
	stream->Write(m_iTradeRoutes);
	stream->Write(m_iHealth);
	stream->Write(m_iHappiness);
	stream->Write(m_iFirstFreeTechs);
	stream->Write(m_iAssetValue);
	stream->Write(m_iPowerValue);
	stream->Write(m_bRepeat);
	stream->Write(m_bTrade);
	stream->Write(m_bDisable);
	stream->Write(m_bGoodyTech);
	stream->Write(m_bHolyKnowledge);
	stream->Write(m_bExtraWaterSeeFrom);
	stream->Write(m_bMapCentering);
	stream->Write(m_bMapVisible);
	stream->Write(m_bMapTrading);
	stream->Write(m_bTechTrading);
	stream->Write(m_bGoldTrading);
	stream->Write(m_bOpenBordersTrading);
	stream->Write(m_bDefensivePactTrading);
	stream->Write(m_bPermanentAllianceTrading);
	stream->Write(m_bVassalStateTrading);
	stream->Write(m_bBridgeBuilding);
	stream->Write(m_bIrrigation);
	stream->Write(m_bIgnoreIrrigation);
	stream->Write(m_bWaterWork);
	stream->Write(m_bRiverTrade);
	stream->Write(m_iGridX);
	stream->Write(m_iGridY);

	stream->Write(NUM_DOMAIN_TYPES, m_piDomainExtraMoves);
	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(GC.getNUM_OR_TECH_PREREQS(), m_piPrereqOrTechs);
	stream->Write(GC.getNUM_AND_TECH_PREREQS(), m_piPrereqAndTechs);
	stream->Write(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);

	int i;
	for (i = 0; i < GC.getNumReligionInfos(); i++)
	{
		stream->Write(GC.getNumReligionInfos(), m_ppiReligionCommerceModifiers[i]);
	}
		
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainTrade);

	stream->WriteString(m_szQuoteKey);
	stream->WriteString(m_szSound);
	stream->WriteString(m_szSoundMP);

//FfH Techs: Added by Kael 08/09/2007
	stream->Write(m_bWater);
	stream->Write(m_iPreferredAlignment);
	stream->Write(m_iPrereqReligion);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupport);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

}

bool CvTechInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Advisor");
	m_iAdvisorType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iAITradeModifier, "iAITradeModifier");
	pXML->GetChildXmlValByName(&m_iResearchCost, "iCost");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");

	pXML->GetChildXmlValByName(szTextVal, "Era");
	m_iEra = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FirstFreeUnitClass");
	m_iFirstFreeUnitClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FreeUnitClass");
	m_iFreeUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iFeatureProductionModifier, "iFeatureProductionModifier");
	pXML->GetChildXmlValByName(&m_iWorkerSpeedModifier, "iWorkerSpeedModifier");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iFirstFreeTechs, "iFirstFreeTechs");
	pXML->GetChildXmlValByName(&m_iAssetValue, "iAsset");
	pXML->GetChildXmlValByName(&m_iPowerValue, "iPower");
	pXML->GetChildXmlValByName(&m_bRepeat, "bRepeat");
	pXML->GetChildXmlValByName(&m_bTrade, "bTrade");
	pXML->GetChildXmlValByName(&m_bDisable, "bDisable");
	pXML->GetChildXmlValByName(&m_bGoodyTech, "bGoodyTech");
	pXML->GetChildXmlValByName(&m_bHolyKnowledge, "bHolyKnowledge");
	pXML->GetChildXmlValByName(&m_bExtraWaterSeeFrom, "bExtraWaterSeeFrom");
	pXML->GetChildXmlValByName(&m_bMapCentering, "bMapCentering");
	pXML->GetChildXmlValByName(&m_bMapVisible, "bMapVisible");
	pXML->GetChildXmlValByName(&m_bMapTrading, "bMapTrading");
	pXML->GetChildXmlValByName(&m_bTechTrading, "bTechTrading");
	pXML->GetChildXmlValByName(&m_bGoldTrading, "bGoldTrading");
	pXML->GetChildXmlValByName(&m_bOpenBordersTrading, "bOpenBordersTrading");
	pXML->GetChildXmlValByName(&m_bDefensivePactTrading, "bDefensivePactTrading");
	pXML->GetChildXmlValByName(&m_bPermanentAllianceTrading, "bPermanentAllianceTrading");
	pXML->GetChildXmlValByName(&m_bVassalStateTrading, "bVassalTrading");
	pXML->GetChildXmlValByName(&m_bBridgeBuilding, "bBridgeBuilding");
	pXML->GetChildXmlValByName(&m_bIrrigation, "bIrrigation");
	pXML->GetChildXmlValByName(&m_bIgnoreIrrigation, "bIgnoreIrrigation");
	pXML->GetChildXmlValByName(&m_bWaterWork, "bWaterWork");
	pXML->GetChildXmlValByName(&m_bRiverTrade, "bRiverTrade");
	pXML->GetChildXmlValByName(&m_iGridX, "iGridX");
	pXML->GetChildXmlValByName(&m_iGridY, "iGridY");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceFlexible"))
	{
		pXML->SetCommerce(&m_pbCommerceFlexible);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_pbCommerceFlexible, NUM_COMMERCE_TYPES);
	}

	// initialize the integer list to the correct size and all the ints to 0
	FAssertMsg((NUM_RELIGION_TYPES > 0) && (NUM_COMMERCE_TYPES > 0), "either the number of religion infos is zero or less or the number of commerce types is zero or less");
	pXML->Init2DIntList(&m_ppiReligionCommerceModifiers, NUM_RELIGION_TYPES, NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ReligionCommerceModifiers"))
	{
		int iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ReligionCommerceModifier"))
		{
			for (int j = 0; j < iNumChildren; j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "Religion");
				int k = GC.convertReligionTypes(szTextVal.GetCString());
				SAFE_DELETE_ARRAY(m_ppiReligionCommerceModifiers[k]);
				if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceModifiers") && (k > -1))
				{
					pXML->SetCommerce(&m_ppiReligionCommerceModifiers[k]);
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
				else
				{
					pXML->InitList(&m_ppiReligionCommerceModifiers[k], NUM_COMMERCE_TYPES);
				}
				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->SetVariableListTagPair(&m_piDomainExtraMoves, "DomainExtraMoves", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);
	pXML->SetVariableListTagPair(&m_pbTerrainTrade, "TerrainTrades", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos(), false);
	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());

//TEMPFIX SEPHI set AI Magic Values
	if(GC.getNumFlavorTypes()==11)
	{
		int iSpecial=GC.getGameINLINE().getSorenRandNum(3,"Magic Specialization");
		m_piFlavorValue[9+iSpecial]=100;
	}
//END TEMPFIX
	pXML->GetChildXmlValByName(szTextVal, "Quote");
	setQuoteKey(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SoundMP");
	setSoundMP(szTextVal);

//FfH Techs: Added by Kael 08/09/2007
	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(szTextVal, "PreferredAlignment");
	m_iPreferredAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AlignmentBlocked");
	m_iBlockedbyAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_aszExtraXMLforPass3.push_back(szTextVal);
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		This lists MUST exist so we can compare them during CopyNonDefaults function			**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	pXML->InitList(&m_piPrereqOrTechs, GC.getNUM_OR_TECH_PREREQS(), -1);
	pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_AND_TECH_PREREQS(), -1);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationSupportValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCorporationSupportforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiCorporationSupportforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationSupportModifierValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCorporationSupportModforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiCorporationSupportModforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "ReligionType");
	m_aszExtraXML1forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_bAllowAnimalTaming, "bAllowAnimalTaming");
	pXML->GetChildXmlValByName(&m_bAllowGuild, "bAllowGuild");
	pXML->GetChildXmlValByName(&m_bAllowReligion, "bAllowReligion");
	pXML->GetChildXmlValByName(&m_bGuild, "bGuild");
	pXML->GetChildXmlValByName(&m_bReligion, "bReligion");
	pXML->GetChildXmlValByName(&m_bCulturalAchievement, "bCulturalAchievement");
	pXML->GetChildXmlValByName(&m_bDrawNoOrPrereqArrows, "bDrawNoOrPrereqArrows");
	pXML->GetChildXmlValByName(&m_bDrawNoAndPrereqArrows, "bDrawNoAndPrereqArrows");
	pXML->GetChildXmlValByName(szTextVal, "ArcaneAuraPromotion");
	m_aszExtraXML2forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iNumPrereqSpellResearchFromSameSchool, "iNumPrereqSpellResearchFromSameSchool");
	pXML->GetChildXmlValByName(&m_iWillpowerChange, "iWillpowerChange");
	pXML->GetChildXmlValByName(&m_iReducedTerraformCost, "iReducedTerraformCost");
	pXML->GetChildXmlValByName(&m_iReducedEnchantmentCost, "iReducedEnchantmentCost");
	pXML->GetChildXmlValByName(&m_iReducedSummonCost, "iReducedSummonCost");
	pXML->GetChildXmlValByName(&m_bIncreaseTerraformTiles, "bIncreaseTerraformTiles");
	pXML->GetChildXmlValByName(&m_bIncreaseHostileTerraformTiles, "bIncreaseHostileTerraformTiles");
	pXML->GetChildXmlValByName(&m_iIncreaseSummonXP, "iIncreaseSummonXP");
	pXML->GetChildXmlValByName(&m_iIncreaseMaxMana, "iIncreaseMaxMana");
	pXML->GetChildXmlValByName(&m_iIncreaseMana, "iIncreaseMana");
	pXML->GetChildXmlValByName(&m_iIncreaseManaFromNodes, "iIncreaseManaFromNodes");	
	pXML->GetChildXmlValByName(&m_iIncreaseStrengthOfRegularUnits, "iIncreaseStrengthOfRegularUnits");	
	pXML->GetChildXmlValByName(szTextVal, "PrereqBonus");
	m_aszExtraXML3forPass3.push_back(szTextVal);

	pXML->GetChildXmlValByName(m_szPyRequirement, "PyRequirement");
	pXML->GetChildXmlValByName(m_szPicture, "Picture");

	pXML->SetVariableListTagPair(&m_paiSpellDamageChanges, "SpellDamageChanges", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}

bool CvTechInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	These calls retrieve the InfoBase set of fields which are available to most all XML files	**/
/**				That gets you Type, Definition, Civilopedia, bForceOverwrite...					**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"OrPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_OR_TECH_PREREQS()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqOrTechs, GC.getNUM_OR_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_OR_TECH_PREREQS()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (int j = 0; j < iNumSibs; ++j)
					{
						m_piPrereqOrTechs[j] = GC.getInfoTypeForString(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AndPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_AND_TECH_PREREQS()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_AND_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_AND_TECH_PREREQS()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (int j = 0; j < iNumSibs; ++j)
					{
						m_piPrereqAndTechs[j] = GC.getInfoTypeForString(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}

//FfH: Techs: Added by Kael 08/09/2007
bool CvTechInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iPrereqReligion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iPrereqReligion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
/*************************************************************************************************/
/**	New Function Definitions Sephi																**/
/*************************************************************************************************/
	iSize = m_aszExtraXML1forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML1forPass3[i], true) != -1)
		{
			m_iReligionType = GC.getInfoTypeForString(m_aszExtraXML1forPass3[i]);
			break;
		}
	}
	m_aszExtraXML1forPass3.clear();

	iSize = m_aszExtraXML2forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML2forPass3[i], true) != -1)
		{
			m_iArcaneAuraPromotion = GC.getInfoTypeForString(m_aszExtraXML2forPass3[i]);
			break;
		}
	}
	m_aszExtraXML2forPass3.clear();

	iSize = m_aszExtraXML3forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML3forPass3[i], true) != -1)
		{
			m_iPrereqBonus = GC.getInfoTypeForString(m_aszExtraXML3forPass3[i]);
			break;
		}
	}
	m_aszExtraXML3forPass3.clear();

/**	ADDON (Houses of Erebus) Sephi			                                 					**/

    m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
    for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
        m_paiCorporationSupport[iI] = 0;
	}
    int iNumLoad = m_aiCorporationSupportforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCorporationSupportforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_paiCorporationSupport[GC.getInfoTypeForString(m_aszCorporationSupportforPass3[iI])] += m_aiCorporationSupportforPass3[iI];
	}
    m_aszCorporationSupportforPass3.clear();
    m_aiCorporationSupportforPass3.clear();


    m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
    for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
        m_paiCorporationSupportMod[iI] = 0;
	}
    iNumLoad = m_aiCorporationSupportModforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCorporationSupportModforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_paiCorporationSupportMod[GC.getInfoTypeForString(m_aszCorporationSupportModforPass3[iI])] += m_aiCorporationSupportModforPass3[iI];
	}
    m_aszCorporationSupportModforPass3.clear();
    m_aiCorporationSupportModforPass3.clear();

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTechInfo::copyNonDefaults(CvTechInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getAIWeight()					== 0)				m_iAIWeight								= pClassInfo->getAIWeight();
	if (getAITradeModifier()			== 0)				m_iAITradeModifier						= pClassInfo->getAITradeModifier();
	if (getResearchCost()				== 0)				m_iResearchCost							= pClassInfo->getResearchCost();
	if (getAdvancedStartCost()			== 0)				m_iAdvancedStartCost					= pClassInfo->getAdvancedStartCost();
	if (getAdvancedStartCostIncrease()	== 0)				m_iAdvancedStartCostIncrease			= pClassInfo->getAdvancedStartCostIncrease();
	if (getFeatureProductionModifier()	== 0)				m_iFeatureProductionModifier			= pClassInfo->getFeatureProductionModifier();
	if (getWorkerSpeedModifier()		== 0)				m_iWorkerSpeedModifier					= pClassInfo->getWorkerSpeedModifier();
	if (getTradeRoutes()				== 0)				m_iTradeRoutes							= pClassInfo->getTradeRoutes();
	if (getHealth()						== 0)				m_iHealth								= pClassInfo->getHealth();
	if (getHappiness()					== 0)				m_iHappiness							= pClassInfo->getHappiness();
	if (getFirstFreeTechs()				== 0)				m_iFirstFreeTechs						= pClassInfo->getFirstFreeTechs();
	if (getAssetValue()					== 0)				m_iAssetValue							= pClassInfo->getAssetValue();
	if (getPowerValue()					== 0)				m_iPowerValue							= pClassInfo->getPowerValue();
	if (getGridX()						== 0)				m_iGridX								= pClassInfo->getGridX();
	if (getGridY()						== 0)				m_iGridY								= pClassInfo->getGridY();
	if (isRepeat()						== false)			m_bRepeat								= pClassInfo->isRepeat();
	if (isTrade()						== false)			m_bTrade								= pClassInfo->isTrade();
	if (isDisable()						== false)			m_bDisable								= pClassInfo->isDisable();
	if (isGoodyTech()					== false)			m_bGoodyTech							= pClassInfo->isGoodyTech();
	if (isHolyKnowledge()				== false)			m_bHolyKnowledge						= pClassInfo->isHolyKnowledge();
	if (isExtraWaterSeeFrom()			== false)			m_bExtraWaterSeeFrom					= pClassInfo->isExtraWaterSeeFrom();
	if (isMapCentering()				== false)			m_bMapCentering							= pClassInfo->isMapCentering();
	if (isMapVisible()					== false)			m_bMapVisible							= pClassInfo->isMapVisible();
	if (isMapTrading()					== false)			m_bMapTrading							= pClassInfo->isMapTrading();
	if (isTechTrading()					== false)			m_bTechTrading							= pClassInfo->isTechTrading();
	if (isGoldTrading()					== false)			m_bGoldTrading							= pClassInfo->isGoldTrading();
	if (isOpenBordersTrading()			== false)			m_bOpenBordersTrading					= pClassInfo->isOpenBordersTrading();
	if (isDefensivePactTrading()		== false)			m_bDefensivePactTrading					= pClassInfo->isDefensivePactTrading();
	if (isPermanentAllianceTrading()	== false)			m_bPermanentAllianceTrading				= pClassInfo->isPermanentAllianceTrading();
	if (isVassalStateTrading()			== false)			m_bVassalStateTrading					= pClassInfo->isVassalStateTrading();
	if (isBridgeBuilding()				== false)			m_bBridgeBuilding						= pClassInfo->isBridgeBuilding();
	if (isIrrigation()					== false)			m_bIrrigation							= pClassInfo->isIrrigation();
	if (isIgnoreIrrigation()			== false)			m_bIgnoreIrrigation						= pClassInfo->isIgnoreIrrigation();
	if (isWaterWork()					== false)			m_bWaterWork							= pClassInfo->isWaterWork();
	if (isRiverTrade()					== false)			m_bRiverTrade							= pClassInfo->isRiverTrade();
	if (m_bWater						== false)			m_bWater								= pClassInfo->isWater();
//	if (getQuoteKey()					== cDefault)		m_szQuoteKey							= pClassInfo->getQuoteKey();
	if (getSound()						== cDefault)		m_szSound								= pClassInfo->getSound();
	if (getSoundMP()					== cDefault)		m_szSoundMP								= pClassInfo->getSoundMP();
	if (getEra()						== NO_ERA)			m_iEra									= pClassInfo->getEra();
	if (getAdvisorType()				== NO_ADVISOR)		m_iAdvisorType							= pClassInfo->getAdvisorType();
	if (getFirstFreeUnitClass()			== NO_UNITCLASS)	m_iFirstFreeUnitClass					= pClassInfo->getFirstFreeUnitClass();
	if (getFreeUnitClass()				== NO_UNITCLASS)	m_iFreeUnitClass						= pClassInfo->getFreeUnitClass();
	if (getPreferredAlignment()			== NO_ALIGNMENT)	m_iPreferredAlignment					= pClassInfo->getPreferredAlignment();
	if (getBlockedbyAlignment()			== NO_ALIGNMENT)	m_iBlockedbyAlignment					= pClassInfo->getBlockedbyAlignment();
	if (getReligionType()				== NO_RELIGION)		m_iReligionType							= pClassInfo->getReligionType();
	if (isAllowAnimalTaming()			== false)			m_bAllowAnimalTaming					= pClassInfo->isAllowAnimalTaming();
	if (isAllowGuild()					== false)			m_bAllowGuild							= pClassInfo->isAllowGuild();
	if (isAllowReligion()				== false)			m_bAllowReligion						= pClassInfo->isAllowReligion();
	if (isGuild()						== false)			m_bGuild								= pClassInfo->isGuild();
	if (isReligion()					== false)			m_bReligion								= pClassInfo->isReligion();
	if (isCulturalAchievement()			== false)			m_bCulturalAchievement					= pClassInfo->isCulturalAchievement();
	if (isDrawNoOrPrereqArrows()		== false)			m_bDrawNoOrPrereqArrows					= pClassInfo->isDrawNoOrPrereqArrows();
	if (isDrawNoAndPrereqArrows()		== false)			m_bDrawNoAndPrereqArrows				= pClassInfo->isDrawNoAndPrereqArrows();
	if (getArcaneAuraPromotion()		== NO_PROMOTION)	m_iArcaneAuraPromotion					= pClassInfo->getArcaneAuraPromotion();
	if (getNumPrereqSpellResearchFromSameSchool()		== 0)	m_iNumPrereqSpellResearchFromSameSchool	= pClassInfo->getNumPrereqSpellResearchFromSameSchool();
	if (getWillpowerChange()			== 0)				m_iWillpowerChange						= pClassInfo->getWillpowerChange();
	if (getReducedTerraformCost()		== 0)				m_iReducedTerraformCost					= pClassInfo->getReducedTerraformCost();
	if (getReducedEnchantmentCost()		== 0)				m_iReducedEnchantmentCost				= pClassInfo->getReducedEnchantmentCost();
	if (getReducedSummonCost()			== 0)				m_iReducedSummonCost					= pClassInfo->getReducedSummonCost();
	if (isIncreaseTerraformTiles()		== false)			m_bIncreaseTerraformTiles				= pClassInfo->isIncreaseTerraformTiles();
	if (isIncreaseHostileTerraformTiles()== false)			m_bIncreaseHostileTerraformTiles		= pClassInfo->isIncreaseHostileTerraformTiles();
	if (getIncreaseSummonXP()			== 0)				m_iIncreaseSummonXP						= pClassInfo->getIncreaseSummonXP();
	if (getIncreaseMaxMana()			== 0)				m_iIncreaseMaxMana						= pClassInfo->getIncreaseMaxMana();
	if (getIncreaseMana()				== 0)				m_iIncreaseMana							= pClassInfo->getIncreaseMana();
	if (getIncreaseManaFromNodes()		== 0)				m_iIncreaseManaFromNodes				= pClassInfo->getIncreaseManaFromNodes();	
	if (getIncreaseStrengthOfRegularUnits()		== 0)		m_iIncreaseStrengthOfRegularUnits		= pClassInfo->getIncreaseStrengthOfRegularUnits();	
	if (getPrereqBonus()				== NO_BONUS)		m_iPrereqBonus							= pClassInfo->getPrereqBonus();
	if (getPyRequirement()				== cDefault)		m_szPyRequirement						= pClassInfo->getPyRequirement();
// crashes somehow
//	if (getPicture()					== cDefault)		m_szPicture								= pClassInfo->getPicture();

	for ( int j= 0; j < GC.getNumDamageTypeInfos(); j++)
	{
		if(getSpellDamageChange(j)		==0)				m_paiSpellDamageChanges[j]				= pClassInfo->getSpellDamageChange(j);
	}


	for ( int j = 0; j < NUM_COMMERCE_TYPES; j++)
	{
		if (isCommerceFlexible(j)		== false)			m_pbCommerceFlexible[j]					= pClassInfo->isCommerceFlexible(j);
	}

	for (int i = 0; i < GC.getNumReligionInfos(); i++)
	{
		for (int j = 0; j < NUM_COMMERCE_TYPES; j++)
		{
			if (m_ppiReligionCommerceModifiers[i][j] == 0)	m_ppiReligionCommerceModifiers[i][j]	= pClassInfo->getReligionCommerceTechRateModifier(i, j);
		}
	}

	for ( int j = 0; j < NUM_DOMAIN_TYPES; j++)
	{
		if (getDomainExtraMoves(j)		== 0)				m_piDomainExtraMoves[j]					= pClassInfo->getDomainExtraMoves(j);
		if (getDomainExtraMoves(j)		== 0)				m_piDomainExtraMoves[j]					= pClassInfo->getDomainExtraMoves(j);
	}
	for ( int j = 0; j < GC.getNumTerrainInfos(); j++)
	{
		if (isTerrainTrade(j)			== false)			m_pbTerrainTrade[j]						= pClassInfo->isTerrainTrade(j);
	}
	for ( int j = 0; j < GC.getNumFlavorTypes(); j++)
	{
		if (getFlavorValue(j)			== 0)				m_piFlavorValue[j]						= pClassInfo->getFlavorValue(j);
	}

	// Readpass2 stuff
	for ( int j = 0; j < GC.getNUM_OR_TECH_PREREQS(); j++)
	{
		if(getPrereqOrTechs(j)			== NO_TECH)			m_piPrereqOrTechs[j]					= pClassInfo->getPrereqOrTechs(j);
	}
	for ( int j = 0; j < GC.getNUM_AND_TECH_PREREQS(); j++)
	{
		if(getPrereqAndTechs(j)			== NO_TECH)			m_piPrereqAndTechs[j]					= pClassInfo->getPrereqAndTechs(j);
	}

	//Readpass3 stuff
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	for ( int i = 0; i < pClassInfo->getCorporationSupportVectorSize(); i++ )
	{
		m_aszCorporationSupportforPass3.push_back(	pClassInfo->getCorporationSupportNamesVectorElement(i));
		m_aiCorporationSupportforPass3.push_back(	pClassInfo->getCorporationSupportValuesVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getCorporationSupportModVectorSize(); i++ )
	{
		m_aszCorporationSupportModforPass3.push_back(	pClassInfo->getCorporationSupportModNamesVectorElement(i));
		m_aiCorporationSupportModforPass3.push_back(	pClassInfo->getCorporationSupportModValuesVectorElement(i));
	}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

void CvTechInfo::copyNonDefaultsReadPass2(CvTechInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	for ( int i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++ )
	{
		if(bOver || pClassInfo->getPrereqOrTechs(i)		!= NO_TECH)	m_piPrereqOrTechs[i]	= pClassInfo->getPrereqOrTechs(i);
	}
	for ( int i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++ )
	{
		if(bOver || pClassInfo->getPrereqAndTechs(i)	!= NO_TECH)	m_piPrereqAndTechs[i]	= pClassInfo->getPrereqAndTechs(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvPromotionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvPromotionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvPromotionInfo::CvPromotionInfo() :
m_iLayerAnimationPath(ANIMATIONPATH_NONE),
m_iPrereqPromotion(NO_PROMOTION),
m_iPrereqOrPromotion1(NO_PROMOTION),
m_iPrereqOrPromotion2(NO_PROMOTION),
m_iTechPrereq(NO_TECH),
m_iStateReligionPrereq(NO_RELIGION),
m_iVisibilityChange(0),
m_iMovesChange(0),
m_iMoveDiscountChange(0),
m_iAirRangeChange(0),
m_iInterceptChange(0),
m_iEvasionChange(0),
m_iWithdrawalChange(0),
m_iCargoChange(0),
m_iCollateralDamageChange(0),
m_iBombardRateChange(0),
m_iFirstStrikesChange(0),
m_iChanceFirstStrikesChange(0),
m_iEnemyHealChange(0),
m_iNeutralHealChange(0),
m_iFriendlyHealChange(0),
m_iSameTileHealChange(0),
m_iAdjacentTileHealChange(0),
m_iCombatPercent(0),
m_iCityAttackPercent(0),
m_iCityDefensePercent(0),
m_iHillsAttackPercent(0),
m_iHillsDefensePercent(0),
m_iCommandType(NO_COMMAND),
m_iRevoltProtection(0),
m_iCollateralDamageProtection(0),
m_iPillageChange(0),
m_iUpgradeDiscount(0),
m_iExperiencePercent(0),
m_iKamikazePercent(0),
m_bLeader(false),
m_bBlitz(false),
m_bAmphib(false),
m_bRiver(false),
m_bEnemyRoute(false),
m_bAlwaysHeal(false),
m_bHillsDoubleMove(false),
m_bImmuneToFirstStrikes(false),
m_piTerrainAttackPercent(NULL),
m_piTerrainDefensePercent(NULL),
m_piFeatureAttackPercent(NULL),
m_piFeatureDefensePercent(NULL),
m_piUnitCombatModifierPercent(NULL),
m_piDomainModifierPercent(NULL),
m_pbTerrainDoubleMove(NULL),
m_pbFeatureDoubleMove(NULL),
m_pbUnitCombat(NULL),
m_pbMakeEquipmentDurabilityValid(NULL),

//FfH: Added by Kael 07/30/2007
m_bAIControl(false),
m_bBoarding(false),
m_bOnlyDefensive(false),
m_bDispellable(false),
m_bDoubleFortifyBonus(false),
m_bEquipment(false),
m_iFear(false),
m_bFlying(false),
m_bHeld(false),
m_bHiddenNationality(false),
m_bIgnoreBuildingDefense(false),
m_bImmortal(false),
m_bImmuneToCapture(false),
m_bImmuneToDefensiveStrike(false),
m_bImmuneToFear(false),
m_bImmuneToMagic(false),
m_bInvisible(false),
m_bMutation(false),
m_bNotAlive(false),
m_bPrereqAlive(false),
m_bRace(false),
m_bRemovedByCasting(false),
m_bRemovedByCombat(false),
m_bRemovedWhenHealed(false),
m_bSeeInvisible(false),
m_bTargetWeakestUnit(false),
m_bTargetWeakestUnitCounter(false),
m_bTwincast(false),
m_bValidate(false),
m_bWaterWalking(false),
m_iAIWeight(0),
m_iBetrayalChance(0),
m_iBetterDefenderThanPercent(0),
m_iCasterResistModify(0),
m_iCombatCapturePercent(0),
m_iCombatHealPercent(0),
m_iCombatManaGained(0),
m_iCombatLimit(0),
m_iCombatPercentDefense(0),
m_iCombatPercentGlobalCounter(0),
m_iCombatPercentInBorders(0),
m_iDefensiveStrikeChance(0),
m_iDefensiveStrikeDamage(0),
m_iEnslavementChance(0),
m_iExpireChance(0),
m_iExtraCombatStr(0),
m_iExtraCombatDefense(0),
m_iFreeXPPerTurn(0),
m_iFreeXPFromCombat(0),
m_iGoldFromCombat(0),
m_iGroupSize(0),
m_iMinLevel(4),
m_iMaxLevel(0),
m_iModifyGlobalCounter(0),
m_iModifyGlobalCounterOnCombat(0),
m_iResistMagic(0),
m_iSpellCasterXP(0),
m_iSpellDamageModify(0),
m_iWorkRateModify(0),
m_iCaptureUnitCombat(NO_UNITCOMBAT),
m_iCaptureAnimalChance(0),
m_iCaptureBeastChance(0),
m_iPromotionCombatApply(NO_PROMOTION),
m_iPromotionCombatApplyChance(0),
m_iPromotionImmune1(NO_PROMOTION),
m_iPromotionImmune2(NO_PROMOTION),
m_iPromotionImmune3(NO_PROMOTION),
m_iPromotionRandomApply(NO_PROMOTION),
m_iPromotionRandomApplyChance(0),
m_iPromotionSummonPerk(NO_PROMOTION),
m_iBonusPrereq(NO_BONUS),
m_iPromotionPrereqOr3(NO_PROMOTION),
m_iPromotionPrereqOr4(NO_PROMOTION),
m_iPromotionPrereqOr5(NO_PROMOTION),
m_iPromotionPrereqOr6(NO_PROMOTION),
m_iPromotionPrereqAnd(NO_PROMOTION),
m_iPromotionNextLevel(NO_PROMOTION),
m_iUnitArtStyleType(NO_UNIT_ARTSTYLE),
m_iPromotionCombatType(NO_PROMOTION),
m_iPromotionCombatMod(0),
m_piBonusAffinity(NULL),
m_piDamageTypeCombat(NULL),
m_piDamageTypeResist(NULL),
m_piCombatAuraDamageTypeResist(NULL),
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
/** Equipment Start **/
m_bGear(false),
/** Equipment End   **/
m_bClassPromotion(false),
m_bDiscipline(false),
m_bGainedInBattle(false),
m_iAdventurePrereq(NO_ADVENTURE),
m_iCombatAuraEffect(0),
m_iCombatAuraRange(0),
m_iCombatAuraTargets(0),
m_bAnyUnitCombat(false),
m_bCannotLeaveCulture(false),
m_bLimitedByNumberBonuses(false),
m_bNoXP(false),
m_bFlamingArrows(false),
m_bHeroPromotion(false),
m_iGoldCost(0),
m_iManaCost(0),
m_iFaithCost(0),
m_iIDWPercent(0),
m_iUnitClassCreateFromCombat(NO_UNITCLASS),
m_iUnitClassCreateFromCombatChance(0),
m_iEquipmentCategory(NO_EQUIPMENTCATEGORY),
m_iEquipmentLevel(0),
m_iDurabilityType(NO_DURABILITY),
m_iYieldCost(0),
m_iYieldCostType(NO_YIELD),
m_iEquipmentYieldType(NO_YIELD),
m_iBonusVSUnitsFullHealth(0),
m_iReducedManaCost(0),
m_iUnitCombatTarget(NO_UNITCOMBAT),
m_iPromotionFromCombat(NO_PROMOTION),
m_iSpellTargetIncrease(0),
m_iNumPrereqBuildingANDs(0),
m_iNumPrereqBuildingORs(0),
m_iNumPrereqCivilizations(0),
m_iNumPromotionExcludes(0),
m_iNumPromotionReplacedBy(0),
m_iNumPromotionMustHave(0),
m_piPrereqBuildingANDs(NULL),
m_piPrereqBuildingORs(NULL),
m_piPrereqCivilizations(NULL),
m_piPromotionExcludes(NULL),
m_piPromotionReplacedBy(NULL),
m_piPromotionMustHave(NULL),
m_iCombatAuraType(NO_COMBATAURA),
m_bCombatAuraImmunityRangedStrike(false),
m_bCombatAuraLoyaltyChange(false),
m_bCombatAuraImmuneToFearChange(false),
m_bCombatAuraWaterwalking(false),
m_bCombatAuraEnchantedWeapons(false),
m_iCombatAuraExperienceChange(0),
m_iCombatAuraFearEffectChange(0),
m_iCombatAuraIgnoreFirstStrikes(0),
m_iCombatAuraIncreaseFirstStrikes(0),
m_iCombatAuraCityAttackChange(0),
m_iCombatAuraHealthRegenerationChange(0),
m_iCombatAuraStrengthChange(0),
m_pbCombatAuraApplyPromotion(NULL),
m_pbCombatAuraRemovePromotion(NULL),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Promotions can be unlocked by Gameoptions) Sephi                     				**/
/*************************************************************************************************/
m_iRequiredGameOption(NO_GAMEOPTION),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Ranged Combat) Sephi								                     				**/
/*************************************************************************************************/
m_iAirCombat(0),
m_iAirCombatLimitBoost(0),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
m_bDefensiveStrikes(false),
//<<<<Refined Defensive Strikes: End Add
m_pabEquipmentPromotions(NULL),
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
 m_paiCorporationSupport(NULL),
 m_paiCorporationSupportMod(NULL),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Better Unit Power (Added by Skyre)
m_iPowerModifier(0)
{
}
// End Better Unit Power

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvPromotionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvPromotionInfo::~CvPromotionInfo()
{

//FfH Damage Types: Added by Kael 08/23/2007
	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
	SAFE_DELETE_ARRAY(m_piDamageTypeResist);
	SAFE_DELETE_ARRAY(m_piCombatAuraDamageTypeResist);
//FfH: End Add

	SAFE_DELETE_ARRAY(m_piTerrainAttackPercent);
	SAFE_DELETE_ARRAY(m_piTerrainDefensePercent);
	SAFE_DELETE_ARRAY(m_piFeatureAttackPercent);
	SAFE_DELETE_ARRAY(m_piFeatureDefensePercent);
	SAFE_DELETE_ARRAY(m_piUnitCombatModifierPercent);
	SAFE_DELETE_ARRAY(m_piDomainModifierPercent);
	SAFE_DELETE_ARRAY(m_pbTerrainDoubleMove);
	SAFE_DELETE_ARRAY(m_pbFeatureDoubleMove);
	SAFE_DELETE_ARRAY(m_pbUnitCombat);
	SAFE_DELETE_ARRAY(m_pbMakeEquipmentDurabilityValid);
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pabEquipmentPromotions);
	SAFE_DELETE_ARRAY(m_piPromotionExcludes);
	SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
	SAFE_DELETE_ARRAY(m_piPromotionMustHave);
	SAFE_DELETE_ARRAY(m_piPrereqBuildingANDs);
	SAFE_DELETE_ARRAY(m_piPrereqBuildingORs);
	SAFE_DELETE_ARRAY(m_piPrereqCivilizations);
	SAFE_DELETE_ARRAY(m_pbCombatAuraApplyPromotion);
	SAFE_DELETE_ARRAY(m_pbCombatAuraRemovePromotion);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

int CvPromotionInfo::getLayerAnimationPath() const
{
	return m_iLayerAnimationPath;
}

int CvPromotionInfo::getPrereqPromotion() const
{
	return m_iPrereqPromotion;
}

void CvPromotionInfo::setPrereqPromotion(int i)
{
	m_iPrereqPromotion = i;
}

int CvPromotionInfo::getPrereqOrPromotion1() const
{
	return m_iPrereqOrPromotion1;
}

void CvPromotionInfo::setPrereqOrPromotion1(int i)
{
	m_iPrereqOrPromotion1 = i;
}

int CvPromotionInfo::getPrereqOrPromotion2() const
{
	return m_iPrereqOrPromotion2;
}

void CvPromotionInfo::setPrereqOrPromotion2(int i)
{
	m_iPrereqOrPromotion2 = i;
}

int CvPromotionInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvPromotionInfo::getStateReligionPrereq() const
{
	return m_iStateReligionPrereq;
}

int CvPromotionInfo::getVisibilityChange() const
{
	return m_iVisibilityChange;
}

int CvPromotionInfo::getMovesChange() const
{
	return m_iMovesChange;
}

int CvPromotionInfo::getMoveDiscountChange() const
{
	return m_iMoveDiscountChange;
}

int CvPromotionInfo::getAirRangeChange() const
{
	return m_iAirRangeChange;
}

int CvPromotionInfo::getInterceptChange() const
{
	return m_iInterceptChange;
}

int CvPromotionInfo::getEvasionChange() const
{
	return m_iEvasionChange;
}

int CvPromotionInfo::getWithdrawalChange() const
{
	return m_iWithdrawalChange;
}

int CvPromotionInfo::getCargoChange() const
{
	return m_iCargoChange;
}

int CvPromotionInfo::getCollateralDamageChange() const
{
	return m_iCollateralDamageChange;
}

int CvPromotionInfo::getBombardRateChange() const
{
	return m_iBombardRateChange;
}

int CvPromotionInfo::getFirstStrikesChange() const
{
	return m_iFirstStrikesChange;
}

int CvPromotionInfo::getChanceFirstStrikesChange() const
{
	return m_iChanceFirstStrikesChange;
}

int CvPromotionInfo::getEnemyHealChange() const
{
	return m_iEnemyHealChange;
}

int CvPromotionInfo::getNeutralHealChange() const
{
	return m_iNeutralHealChange;
}

int CvPromotionInfo::getFriendlyHealChange() const
{
	return m_iFriendlyHealChange;
}

int CvPromotionInfo::getSameTileHealChange() const
{
	return m_iSameTileHealChange;
}

int CvPromotionInfo::getAdjacentTileHealChange() const
{
	return m_iAdjacentTileHealChange;
}

int CvPromotionInfo::getCombatPercent() const
{
	return m_iCombatPercent;
}

int CvPromotionInfo::getCityAttackPercent() const
{
	return m_iCityAttackPercent;
}

int CvPromotionInfo::getCityDefensePercent() const
{
	return m_iCityDefensePercent;
}

int CvPromotionInfo::getHillsAttackPercent() const
{
	return m_iHillsAttackPercent;
}

int CvPromotionInfo::getHillsDefensePercent() const
{
	return m_iHillsDefensePercent;
}

int CvPromotionInfo::getCommandType() const
{
	return m_iCommandType;
}

void CvPromotionInfo::setCommandType(int iNewType)
{
	m_iCommandType = iNewType;
}

int CvPromotionInfo::getRevoltProtection() const
{
	return m_iRevoltProtection;
}

int CvPromotionInfo::getCollateralDamageProtection() const
{
	return m_iCollateralDamageProtection;
}

int CvPromotionInfo::getPillageChange() const
{
	return m_iPillageChange;
}

int CvPromotionInfo::getUpgradeDiscount() const
{
	return m_iUpgradeDiscount;
}

int CvPromotionInfo::getExperiencePercent() const
{
	return m_iExperiencePercent;
}

int CvPromotionInfo::getKamikazePercent() const
{
	return m_iKamikazePercent;
}

bool CvPromotionInfo::isLeader() const
{
	return m_bLeader;
}

bool CvPromotionInfo::isBlitz() const
{
	return m_bBlitz;
}

bool CvPromotionInfo::isAmphib() const
{
	return m_bAmphib;
}

bool CvPromotionInfo::isRiver() const
{
	return m_bRiver;
}

bool CvPromotionInfo::isEnemyRoute() const
{
	return m_bEnemyRoute;
}

bool CvPromotionInfo::isAlwaysHeal() const
{
	return m_bAlwaysHeal;
}

bool CvPromotionInfo::isHillsDoubleMove() const
{
	return m_bHillsDoubleMove;
}

bool CvPromotionInfo::isImmuneToFirstStrikes() const
{
	return m_bImmuneToFirstStrikes;
}

const TCHAR* CvPromotionInfo::getSound() const
{
	return m_szSound;
}

void CvPromotionInfo::setSound(const TCHAR* szVal)
{
	m_szSound = szVal;
}

//FfH: Added by Kael 07/30/2007
bool CvPromotionInfo::isAIControl() const
{
	return m_bAIControl;
}

bool CvPromotionInfo::isBoarding() const
{
	return m_bBoarding;
}

bool CvPromotionInfo::isOnlyDefensive() const
{
	return m_bOnlyDefensive;
}

bool CvPromotionInfo::isDispellable() const
{
	return m_bDispellable;
}

bool CvPromotionInfo::isDoubleFortifyBonus() const
{
	return m_bDoubleFortifyBonus;
}

bool CvPromotionInfo::isEquipment() const
{
	return m_bEquipment;
}

int CvPromotionInfo::getFear() const
{
	return m_iFear;
}

bool CvPromotionInfo::isFlying() const
{
	return m_bFlying;
}

bool CvPromotionInfo::isHeld() const
{
	return m_bHeld;
}

bool CvPromotionInfo::isHiddenNationality() const
{
	return m_bHiddenNationality;
}

bool CvPromotionInfo::isIgnoreBuildingDefense() const
{
	return m_bIgnoreBuildingDefense;
}

bool CvPromotionInfo::isImmortal() const
{
	return m_bImmortal;
}

bool CvPromotionInfo::isImmuneToCapture() const
{
	return m_bImmuneToCapture;
}

bool CvPromotionInfo::isImmuneToDefensiveStrike() const
{
	return m_bImmuneToDefensiveStrike;
}

bool CvPromotionInfo::isImmuneToFear() const
{
	return m_bImmuneToFear;
}

bool CvPromotionInfo::isImmuneToMagic() const
{
	return m_bImmuneToMagic;
}

bool CvPromotionInfo::isInvisible() const
{
	return m_bInvisible;
}

bool CvPromotionInfo::isMutation() const
{
	return m_bMutation;
}

bool CvPromotionInfo::isNotAlive() const
{
	return m_bNotAlive;
}

bool CvPromotionInfo::isPrereqAlive() const
{
	return m_bPrereqAlive;
}

bool CvPromotionInfo::isRace() const
{
	return m_bRace;
}

bool CvPromotionInfo::isRemovedByCasting() const
{
	return m_bRemovedByCasting;
}

bool CvPromotionInfo::isRemovedByCombat() const
{
	return m_bRemovedByCombat;
}

bool CvPromotionInfo::isRemovedWhenHealed() const
{
	return m_bRemovedWhenHealed;
}

bool CvPromotionInfo::isSeeInvisible() const
{
	return m_bSeeInvisible;
}

bool CvPromotionInfo::isTargetWeakestUnit() const
{
	return m_bTargetWeakestUnit;
}

bool CvPromotionInfo::isTargetWeakestUnitCounter() const
{
	return m_bTargetWeakestUnitCounter;
}

bool CvPromotionInfo::isTwincast() const
{
	return m_bTwincast;
}

bool CvPromotionInfo::isValidate() const
{
	return m_bValidate;
}

bool CvPromotionInfo::isWaterWalking() const
{
	return m_bWaterWalking;
}

int CvPromotionInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvPromotionInfo::getBetrayalChance() const
{
	return m_iBetrayalChance;
}

int CvPromotionInfo::getBetterDefenderThanPercent() const
{
	return m_iBetterDefenderThanPercent;
}

int CvPromotionInfo::getCasterResistModify() const
{
	return m_iCasterResistModify;
}

int CvPromotionInfo::getCombatCapturePercent() const
{
	return m_iCombatCapturePercent;
}

int CvPromotionInfo::getCombatHealPercent() const
{
	return m_iCombatHealPercent;
}

int CvPromotionInfo::getCombatManaGained() const
{
	return m_iCombatManaGained;
}

int CvPromotionInfo::getCombatLimit() const
{
	return m_iCombatLimit;
}

int CvPromotionInfo::getCombatPercentDefense() const
{
	return m_iCombatPercentDefense;
}

int CvPromotionInfo::getCombatPercentGlobalCounter() const
{
	return m_iCombatPercentGlobalCounter;
}

int CvPromotionInfo::getDefensiveStrikeChance() const
{
	return m_iDefensiveStrikeChance;
}

int CvPromotionInfo::getDefensiveStrikeDamage() const
{
	return m_iDefensiveStrikeDamage;
}

int CvPromotionInfo::getEnslavementChance() const
{
	return m_iEnslavementChance;
}

int CvPromotionInfo::getExpireChance() const
{
	return m_iExpireChance;
}

int CvPromotionInfo::getExtraCombatStr() const
{
	return m_iExtraCombatStr;
}

int CvPromotionInfo::getExtraCombatDefense() const
{
	return m_iExtraCombatDefense;
}

int CvPromotionInfo::getCombatPercentInBorders() const
{
	return m_iCombatPercentInBorders;
}

int CvPromotionInfo::getFreeXPPerTurn() const
{
	return m_iFreeXPPerTurn;
}

int CvPromotionInfo::getFreeXPFromCombat() const
{
	return m_iFreeXPFromCombat;
}

int CvPromotionInfo::getGoldFromCombat() const
{
	return m_iGoldFromCombat;
}

int CvPromotionInfo::getGroupSize() const
{
	return m_iGroupSize;
}

int CvPromotionInfo::getMinLevel() const
{
	if(isClassPromotion())
		if(m_iMinLevel == 4)
			return 3;

	return m_iMinLevel;
}

int CvPromotionInfo::getMaxLevel() const
{
	return m_iMaxLevel;
}

int CvPromotionInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvPromotionInfo::getModifyGlobalCounterOnCombat() const
{
	return m_iModifyGlobalCounterOnCombat;
}

int CvPromotionInfo::getResistMagic() const
{
	return m_iResistMagic;
}

int CvPromotionInfo::getSpellCasterXP() const
{
	return m_iSpellCasterXP;
}

int CvPromotionInfo::getSpellDamageModify() const
{
	return m_iSpellDamageModify;
}

int CvPromotionInfo::getWorkRateModify() const
{
	return m_iWorkRateModify;
}

int CvPromotionInfo::getCaptureUnitCombat() const
{
	return m_iCaptureUnitCombat;
}

int CvPromotionInfo::getCaptureAnimalChance() const
{
	return m_iCaptureAnimalChance;
}

int CvPromotionInfo::getCaptureBeastChance() const
{
	return m_iCaptureBeastChance;
}

int CvPromotionInfo::getPromotionCombatApply() const
{
	return m_iPromotionCombatApply;
}

int CvPromotionInfo::getPromotionCombatApplyChance() const
{
	return m_iPromotionCombatApplyChance;
}

int CvPromotionInfo::getPromotionImmune1() const
{
	return m_iPromotionImmune1;
}

int CvPromotionInfo::getPromotionImmune2() const
{
	return m_iPromotionImmune2;
}

int CvPromotionInfo::getPromotionImmune3() const
{
	return m_iPromotionImmune3;
}

int CvPromotionInfo::getPromotionRandomApply() const
{
	return m_iPromotionRandomApply;
}

int CvPromotionInfo::getPromotionRandomApplyChance() const
{
	return m_iPromotionRandomApplyChance;
}

int CvPromotionInfo::getPromotionSummonPerk() const
{
	return m_iPromotionSummonPerk;
}

int CvPromotionInfo::getBonusPrereq() const
{
	return m_iBonusPrereq;
}

int CvPromotionInfo::getPromotionPrereqOr3() const
{
	return m_iPromotionPrereqOr3;
}

int CvPromotionInfo::getPromotionPrereqOr4() const
{
	return m_iPromotionPrereqOr4;
}

int CvPromotionInfo::getPromotionPrereqOr5() const
{
	return m_iPromotionPrereqOr5;
}

int CvPromotionInfo::getPromotionPrereqOr6() const
{
	return m_iPromotionPrereqOr6;
}

int CvPromotionInfo::getPromotionPrereqAnd() const
{
	return m_iPromotionPrereqAnd;
}

int CvPromotionInfo::getPromotionNextLevel() const
{
	return m_iPromotionNextLevel;
}

int CvPromotionInfo::getUnitArtStyleType() const
{
	return m_iUnitArtStyleType;
}

int CvPromotionInfo::getPromotionCombatType() const
{
	return m_iPromotionCombatType;
}

int CvPromotionInfo::getPromotionCombatMod() const
{
	return m_iPromotionCombatMod;
}

const TCHAR *CvPromotionInfo::getPyPerTurn() const
{
	return m_szPyPerTurn;
}

int CvPromotionInfo::getBonusAffinity(int i) const
{
	return m_piBonusAffinity ? m_piBonusAffinity[i] : -1;
}

int CvPromotionInfo::getDamageTypeCombat(int i) const
{
	return m_piDamageTypeCombat ? m_piDamageTypeCombat[i] : -1;
}

int CvPromotionInfo::getDamageTypeResist(int i) const
{
	return m_piDamageTypeResist ? m_piDamageTypeResist[i] : -1;
}

int CvPromotionInfo::getCombatAuraDamageTypeResist(int i) const
{
	return m_piCombatAuraDamageTypeResist ? m_piCombatAuraDamageTypeResist[i] : -1;
}

//FfH: End Add

/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
bool CvPromotionInfo::isPromotionAPrereq(int iPromotion) const
{
	if(iPromotion==NO_PROMOTION)
	{
		return false;
	}
	if(getPrereqPromotion()==iPromotion)
	{
		return true;
	}
	if(getPrereqOrPromotion1()==iPromotion)
	{
		return true;
	}
	if(getPrereqOrPromotion2()==iPromotion)
	{
		return true;
	}
	if(this->getPromotionPrereqAnd()==iPromotion)
	{
		return true;
	}

	return false;
}
/** Equipment Start **/
bool CvPromotionInfo::isGear() const									{return m_bGear;}
bool CvPromotionInfo::isClassPromotion() const							{return m_bClassPromotion;}
bool CvPromotionInfo::isDiscipline() const							{return m_bDiscipline;}
bool CvPromotionInfo::isGainedInBattle() const							{return m_bGainedInBattle;}
/** Equipment End   **/
int CvPromotionInfo::getAdventurePrereq() const								{return m_iAdventurePrereq;}
int CvPromotionInfo::getAdventurePrereqVectorSize()						{return m_aszExtraXML3forPass3.size();}
CvString CvPromotionInfo::getAdventurePrereqVectorElement(int i)			{return m_aszExtraXML3forPass3[i];}
int CvPromotionInfo::getCombatAuraEffect() const								{return m_iCombatAuraEffect;}
int CvPromotionInfo::getCombatAuraRange() const								{return m_iCombatAuraRange;}
int CvPromotionInfo::getCombatAuraTargets() const								{return m_iCombatAuraTargets;}
bool CvPromotionInfo::isAnyUnitCombat() const							{return m_bAnyUnitCombat;}
bool CvPromotionInfo::isCannotLeaveCulture() const						{return m_bCannotLeaveCulture;}
bool CvPromotionInfo::isLimitedByNumberBonuses() const					{return m_bLimitedByNumberBonuses;}
bool CvPromotionInfo::isNoXP() const									{return m_bNoXP;}
bool CvPromotionInfo::isFlamingArrows() const						{return m_bFlamingArrows;}
bool CvPromotionInfo::isHeroPromotion() const							{return m_bHeroPromotion;}

int CvPromotionInfo::getGoldCost() const								{return m_iGoldCost;}
int CvPromotionInfo::getManaCost() const								{return m_iManaCost;}
int CvPromotionInfo::getFaithCost() const								{return m_iFaithCost;}
int CvPromotionInfo::getIDWPercent() const								{return m_iIDWPercent;}
int CvPromotionInfo::getUnitClassCreateFromCombat() const				{return m_iUnitClassCreateFromCombat;}
int CvPromotionInfo::getUnitClassCreateFromCombatChance() const			{return m_iUnitClassCreateFromCombatChance;}
int CvPromotionInfo::getEquipmentCategory() const						{return m_iEquipmentCategory;}
int CvPromotionInfo::getEquipmentLevel() const							{return m_iEquipmentLevel;}
int CvPromotionInfo::getDurabilityType() const							{return m_iDurabilityType;}

int CvPromotionInfo::getYieldCost(int iUnitTier) const
{
//	return m_iYieldCost*std::max(iUnitTier,1);
	return m_iYieldCost;
}
int CvPromotionInfo::getYieldCostType() const							{return m_iYieldCostType;}
int CvPromotionInfo::getEquipmentYieldType() const							{return m_iEquipmentYieldType;}
int CvPromotionInfo::getBonusVSUnitsFullHealth() const					{return m_iBonusVSUnitsFullHealth;}
int CvPromotionInfo::getReducedManaCost() const							{return m_iReducedManaCost;}

int CvPromotionInfo::getUnitCombatTarget() const								{return m_iUnitCombatTarget;}
int CvPromotionInfo::getSpellTargetIncrease() const								{return m_iSpellTargetIncrease;}

PromotionTypes CvPromotionInfo::getPromotionExcludes(int iI) const		{return (getNumPromotionExcludes() > iI)	? (PromotionTypes)m_piPromotionExcludes[iI]		: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionExcludes() const					{return m_iNumPromotionExcludes;}
PromotionTypes CvPromotionInfo::getPromotionReplacedBy(int iI) const	{return (getNumPromotionReplacedBy() > iI)	? (PromotionTypes)m_piPromotionReplacedBy[iI]	: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionReplacedBy() const					{return m_iNumPromotionReplacedBy;}
PromotionTypes CvPromotionInfo::getPromotionMustHave(int iI) const		{return (getNumPromotionMustHave() > iI)	? (PromotionTypes)m_piPromotionMustHave[iI]		: NO_PROMOTION;}
int CvPromotionInfo::getNumPromotionMustHave() const					{return m_iNumPromotionMustHave;}
int CvPromotionInfo::getPrereqBuildingAND(int iI) const					{return (getNumPrereqBuildingANDs() > iI)	? m_piPrereqBuildingANDs[iI]					: -1;}
int CvPromotionInfo::getNumPrereqBuildingANDs() const					{return m_iNumPrereqBuildingANDs;}
int CvPromotionInfo::getPrereqBuildingOR(int iI) const					{return (getNumPrereqBuildingORs() > iI)	? m_piPrereqBuildingORs[iI]						: -1;}
int CvPromotionInfo::getNumPrereqBuildingORs() const					{return m_iNumPrereqBuildingORs;}
int CvPromotionInfo::getPrereqCivilization(int iI) const				{return (getNumPrereqCivilizations() > iI)	? m_piPrereqCivilizations[iI]					: -1;}
int CvPromotionInfo::getNumPrereqCivilizations() const					{return m_iNumPrereqCivilizations;}
CvString CvPromotionInfo::getPrereqBuildingANDsVectorElement(int i)		{return m_aszPrereqBuildingANDsforPass3[i];}
CvString CvPromotionInfo::getPrereqBuildingORsVectorElement(int i)		{return m_aszPrereqBuildingORsforPass3[i];}
CvString CvPromotionInfo::getPrereqCivilizationsVectorElement(int i)	{return m_aszPrereqCivilizationsforPass3[i];}

bool CvPromotionInfo::isPrereqCivilization(int iCivilization) const
{
	if(iCivilization==NO_CIVILIZATION && getNumPrereqCivilizations()==0)
	{
		return true;
	}

	for(int iJ=0;iJ<getNumPrereqCivilizations();iJ++)
	{
		if(getPrereqCivilization(iJ)==iCivilization)
		{
			return true;
		}
	}
	return false;
}

int CvPromotionInfo::getPromotionFromCombat() const								{return m_iPromotionFromCombat;}
int CvPromotionInfo::getPromotionFromCombatVectorSize()						{return m_aszExtraXML2forPass3.size();}
CvString CvPromotionInfo::getPromotionFromCombatVectorElement(int i)			{return m_aszExtraXML2forPass3[i];}

int CvPromotionInfo::getCombatAuraExperienceChange() const				{return m_iCombatAuraExperienceChange;}
int CvPromotionInfo::getCombatAuraFearEffectChange() const				{return m_iCombatAuraFearEffectChange;}
int CvPromotionInfo::getCombatAuraIgnoreFirstStrikes() const			{return m_iCombatAuraIgnoreFirstStrikes;}
int CvPromotionInfo::getCombatAuraIncreaseFirstStrikes() const			{return m_iCombatAuraIncreaseFirstStrikes;}
int CvPromotionInfo::getCombatAuraType() const							{return m_iCombatAuraType;}
bool CvPromotionInfo::isCombatAuraImmunityRangedStrike() const			{return m_bCombatAuraImmunityRangedStrike;}
bool CvPromotionInfo::isCombatAuraLoyaltyChange() const					{return m_bCombatAuraLoyaltyChange;}
bool CvPromotionInfo::isCombatAuraImmuneToFearChange() const			{return m_bCombatAuraImmuneToFearChange;}
bool CvPromotionInfo::isCombatAuraWaterwalking() const					{return m_bCombatAuraWaterwalking;}
bool CvPromotionInfo::isCombatAuraEnchantedWeapons() const				{return m_bCombatAuraEnchantedWeapons;}
int CvPromotionInfo::getCombatAuraCityAttackChange() const				{return m_iCombatAuraCityAttackChange;}
int CvPromotionInfo::getCombatAuraHealthRegenerationChange() const		{return m_iCombatAuraHealthRegenerationChange;}
int CvPromotionInfo::getCombatAuraStrengthChange() const				{return m_iCombatAuraStrengthChange;}
int CvPromotionInfo::getCombatAuraTypeVectorSize()						{return m_aszExtraXML1forPass3.size();}
CvString CvPromotionInfo::getCombatAuraTypeVectorElement(int i)			{return m_aszExtraXML1forPass3[i];}

bool CvPromotionInfo::isCombatAuraApplyPromotion(int iI) const			{return m_pbCombatAuraApplyPromotion ? m_pbCombatAuraApplyPromotion[iI]		: false;}
int CvPromotionInfo::getCombatAuraApplyPromotionVectorSize()			{return m_aszCombatAuraApplyPromotionsforPass3.size();}
CvString CvPromotionInfo::getCombatAuraApplyPromotionNamesVectorElement(int i)		{return m_aszCombatAuraApplyPromotionsforPass3[i];}
bool CvPromotionInfo::getCombatAuraApplyPromotionValuesVectorElement(int i) {return m_abCombatAuraApplyPromotionsforPass3[i];}
bool CvPromotionInfo::isCombatAuraRemovePromotion(int iI) const			{return m_pbCombatAuraRemovePromotion? m_pbCombatAuraRemovePromotion[iI]		: false;}
int CvPromotionInfo::getCombatAuraRemovePromotionVectorSize() {return m_aszCombatAuraRemovePromotionsforPass3.size();}
CvString CvPromotionInfo::getCombatAuraRemovePromotionNamesVectorElement(int i)	{return m_aszCombatAuraRemovePromotionsforPass3[i];}
bool CvPromotionInfo::getCombatAuraRemovePromotionValuesVectorElement(int i) {return m_abCombatAuraRemovePromotionsforPass3[i];}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	ADDON (Promotions can be unlocked by Gameoptions) Sephi                     				**/
/*************************************************************************************************/
int CvPromotionInfo::getRequiredGameOption() const
{
	return m_iRequiredGameOption;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	ADDON (Ranged Combat) Sephi								                     				**/
/*************************************************************************************************/
int CvPromotionInfo::getAirCombat() const
{
	return m_iAirCombat;
}
int CvPromotionInfo::getAirCombatLimitBoost() const
{
	return m_iAirCombatLimitBoost;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
bool CvPromotionInfo::isDefensiveStrikes() const
{
	return m_bDefensiveStrikes;
}
//<<<<Refined Defensive Strikes: End Add
bool CvPromotionInfo::isEquipmentPromotion(int iPromotion) const
{
	return m_pabEquipmentPromotions[iPromotion];
}

int CvPromotionInfo::getEquipmentPromotionsVectorSize()					{return m_aszEquipmentPromotionsforPass3.size();}
CvString CvPromotionInfo::getEquipmentPromotionsNamesVectorElement(int i)	{return m_aszEquipmentPromotionsforPass3[i];}
bool CvPromotionInfo::isEquipmentPromotionsValuesVectorElement(int i)		{return m_abEquipmentPromotionsforPass3[i];}

bool CvPromotionInfo::isDisplayAsEquipment()
{
	if(isEquipment())
		return true;

	if(getEquipmentCategory() != NO_EQUIPMENTCATEGORY)
		return true;

	int iType = GC.getInfoTypeForString(getType());
	for(int i = 0; i < GC.getNumPromotionInfos(); ++i) {
		if(GC.getPromotionInfo((PromotionTypes)i).isEquipmentPromotion(iType)) {
			return true;
		}
	}

	return false;
}

bool CvPromotionInfo::isDisplayAsClass()
{
	if(isDiscipline())
		return true;

	if(isClassPromotion())
		return true;

	if(isHeroPromotion())
		return true;

	return false;
}

/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvPromotionInfo::getCorporationSupport(int iCorporation) const
{
	return m_paiCorporationSupport[iCorporation];
}

int CvPromotionInfo::getCorporationSupportMultiplier(int iCorporation) const
{
	return m_paiCorporationSupportMod[iCorporation];
}

int CvPromotionInfo::getCorporationSupportVectorSize()					{return m_aszCorporationSupportforPass3.size();}
CvString CvPromotionInfo::getCorporationSupportNamesVectorElement(int i)	{return m_aszCorporationSupportforPass3[i];}
int CvPromotionInfo::getCorporationSupportValuesVectorElement(int i)		{return m_aiCorporationSupportforPass3[i];}

int CvPromotionInfo::getCorporationSupportModVectorSize()					{return m_aszCorporationSupportModforPass3.size();}
CvString CvPromotionInfo::getCorporationSupportModNamesVectorElement(int i)	{return m_aszCorporationSupportModforPass3[i];}
int CvPromotionInfo::getCorporationSupportModValuesVectorElement(int i)		{return m_aiCorporationSupportModforPass3[i];}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

// Better Unit Power (Added by Skyre)
int CvPromotionInfo::getPowerModifier() const
{
	return m_iPowerModifier;
}
// End Better Unit Power

// Arrays

int CvPromotionInfo::getTerrainAttackPercent(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainAttackPercent ? m_piTerrainAttackPercent[i] : -1;
}

int CvPromotionInfo::getTerrainDefensePercent(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainDefensePercent ? m_piTerrainDefensePercent[i] : -1;
}

int CvPromotionInfo::getFeatureAttackPercent(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureAttackPercent ? m_piFeatureAttackPercent[i] : -1;
}

int CvPromotionInfo::getFeatureDefensePercent(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureDefensePercent ? m_piFeatureDefensePercent[i] : -1;
}

int CvPromotionInfo::getUnitCombatModifierPercent(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatModifierPercent ? m_piUnitCombatModifierPercent[i] : -1;
}

int CvPromotionInfo::getDomainModifierPercent(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDomainModifierPercent ? m_piDomainModifierPercent[i] : -1;
}

bool CvPromotionInfo::getTerrainDoubleMove(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainDoubleMove ? m_pbTerrainDoubleMove[i] : false;
}

bool CvPromotionInfo::getFeatureDoubleMove(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureDoubleMove ? m_pbFeatureDoubleMove[i] : false;
}

bool CvPromotionInfo::getUnitCombat(int i) const
{
	//added,Sephi
	if(isAnyUnitCombat())
	{
		return true;
	}
	//end added
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbUnitCombat ? m_pbUnitCombat[i] : false;
}

bool CvPromotionInfo::isMakeEquipmentDurabilityValid(int i) const
{
	FAssertMsg(i < GC.getNumDurabilityInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbMakeEquipmentDurabilityValid ? m_pbMakeEquipmentDurabilityValid[i] : false;
}

void CvPromotionInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iLayerAnimationPath);
	stream->Read(&m_iPrereqPromotion);
	stream->Read(&m_iPrereqOrPromotion1);
	stream->Read(&m_iPrereqOrPromotion2);

	stream->Read(&m_iTechPrereq);
	stream->Read(&m_iStateReligionPrereq);
	stream->Read(&m_iVisibilityChange);
	stream->Read(&m_iMovesChange);
	stream->Read(&m_iMoveDiscountChange);
	stream->Read(&m_iAirRangeChange);
	stream->Read(&m_iInterceptChange);
	stream->Read(&m_iEvasionChange);
	stream->Read(&m_iWithdrawalChange);
	stream->Read(&m_iCargoChange);
	stream->Read(&m_iCollateralDamageChange);
	stream->Read(&m_iBombardRateChange);
	stream->Read(&m_iFirstStrikesChange);
	stream->Read(&m_iChanceFirstStrikesChange);
	stream->Read(&m_iEnemyHealChange);
	stream->Read(&m_iNeutralHealChange);
	stream->Read(&m_iFriendlyHealChange);
	stream->Read(&m_iSameTileHealChange);
	stream->Read(&m_iAdjacentTileHealChange);
	stream->Read(&m_iCombatPercent);
	stream->Read(&m_iCityAttackPercent);
	stream->Read(&m_iCityDefensePercent);
	stream->Read(&m_iHillsAttackPercent);
	stream->Read(&m_iHillsDefensePercent);
	stream->Read(&m_iCommandType);
	stream->Read(&m_iRevoltProtection);
	stream->Read(&m_iCollateralDamageProtection);
	stream->Read(&m_iPillageChange);
	stream->Read(&m_iUpgradeDiscount);
	stream->Read(&m_iExperiencePercent);
	stream->Read(&m_iKamikazePercent);

	stream->Read(&m_bLeader);
	stream->Read(&m_bBlitz);
	stream->Read(&m_bAmphib);
	stream->Read(&m_bRiver);
	stream->Read(&m_bEnemyRoute);
	stream->Read(&m_bAlwaysHeal);
	stream->Read(&m_bHillsDoubleMove);
	stream->Read(&m_bImmuneToFirstStrikes);

	stream->ReadString(m_szSound);
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
	stream->Read(&m_bGear);
	stream->Read(&m_bCannotLeaveCulture);
	stream->Read(&m_iGoldCost);
	stream->Read(&m_iManaCost);
	stream->Read(&m_iFaithCost);
	stream->Read(&m_iIDWPercent);
	stream->Read(&m_iBonusVSUnitsFullHealth);
	stream->Read(&m_iNumPrereqBuildingANDs);
    if (m_iNumPrereqBuildingANDs > 0)
    {
		SAFE_DELETE_ARRAY(m_piPrereqBuildingANDs);
        m_piPrereqBuildingANDs = new int[m_iNumPrereqBuildingANDs];
        stream->Read(m_iNumPrereqBuildingANDs, m_piPrereqBuildingANDs);
	}
	stream->Read(&m_iNumPrereqBuildingORs);
    if (m_iNumPrereqBuildingORs > 0)
    {
		SAFE_DELETE_ARRAY(m_piPrereqBuildingORs);
        m_piPrereqBuildingORs = new int[m_iNumPrereqBuildingORs];
        stream->Read(m_iNumPrereqBuildingORs, m_piPrereqBuildingORs);
	}
	stream->Read(&m_iNumPrereqCivilizations);
    if (m_iNumPrereqCivilizations > 0)
    {
		SAFE_DELETE_ARRAY(m_piPrereqCivilizations);
        m_piPrereqCivilizations = new int[m_iNumPrereqCivilizations];
        stream->Read(m_iNumPrereqCivilizations, m_piPrereqCivilizations);
	}

	stream->Read(&m_iNumPromotionExcludes);
    if (m_iNumPromotionExcludes > 0)
    {
		SAFE_DELETE_ARRAY(m_piPromotionExcludes);
        m_piPromotionExcludes = new int[m_iNumPromotionExcludes];
        stream->Read(m_iNumPromotionExcludes, m_piPromotionExcludes);
	}
	stream->Read(&m_iNumPromotionReplacedBy);
    if (m_iNumPromotionReplacedBy > 0)
    {
		SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
        m_piPromotionReplacedBy = new int[m_iNumPromotionReplacedBy];
        stream->Read(m_iNumPromotionReplacedBy, m_piPromotionReplacedBy);
	}
	stream->Read(&m_iNumPromotionMustHave);
    if (m_iNumPromotionMustHave > 0)
    {
		SAFE_DELETE_ARRAY(m_piPromotionMustHave);
        m_piPromotionMustHave = new int[m_iNumPromotionMustHave];
        stream->Read(m_iNumPromotionMustHave, m_piPromotionMustHave);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	ADDON (Promotions can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	stream->Read(&m_iRequiredGameOption);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Ranged Combat) Sephi								                     				**/
/*************************************************************************************************/
	stream->Read(&m_iAirCombat);
	stream->Read(&m_iAirCombatLimitBoost);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	stream->Read(&m_bDefensiveStrikes);
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupport);

	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Better Unit Power (Added by Skyre)
	stream->Read(&m_iPowerModifier);
// End Better Unit Power
//FfH: Added by Kael 07/30/2007
	stream->Read(&m_bAIControl);
	stream->Read(&m_bBoarding);
	stream->Read(&m_bOnlyDefensive);
	stream->Read(&m_bDispellable);
	stream->Read(&m_bDoubleFortifyBonus);
	stream->Read(&m_bEquipment);
	stream->Read(&m_iFear);
	stream->Read(&m_bFlying);
	stream->Read(&m_bHeld);
	stream->Read(&m_bHiddenNationality);
	stream->Read(&m_bIgnoreBuildingDefense);
	stream->Read(&m_bImmortal);
	stream->Read(&m_bImmuneToCapture);
	stream->Read(&m_bImmuneToDefensiveStrike);
	stream->Read(&m_bImmuneToFear);
	stream->Read(&m_bImmuneToMagic);
	stream->Read(&m_bInvisible);
	stream->Read(&m_bMutation);
	stream->Read(&m_bNotAlive);
	stream->Read(&m_bPrereqAlive);
	stream->Read(&m_bRace);
	stream->Read(&m_bRemovedByCasting);
	stream->Read(&m_bRemovedByCombat);
	stream->Read(&m_bRemovedWhenHealed);
	stream->Read(&m_bSeeInvisible);
	stream->Read(&m_bTargetWeakestUnit);
	stream->Read(&m_bTargetWeakestUnitCounter);
	stream->Read(&m_bTwincast);
	stream->Read(&m_bValidate);
	stream->Read(&m_bWaterWalking);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iBetrayalChance);
	stream->Read(&m_iBetterDefenderThanPercent);
	stream->Read(&m_iCasterResistModify);
	stream->Read(&m_iCombatCapturePercent);
	stream->Read(&m_iCombatHealPercent);
	stream->Read(&m_iCombatManaGained);
	stream->Read(&m_iCombatLimit);
	stream->Read(&m_iCombatPercentDefense);
	stream->Read(&m_iCombatPercentGlobalCounter);
	stream->Read(&m_iCombatPercentInBorders);
	stream->Read(&m_iDefensiveStrikeChance);
	stream->Read(&m_iDefensiveStrikeDamage);
	stream->Read(&m_iEnslavementChance);
	stream->Read(&m_iExpireChance);
	stream->Read(&m_iExtraCombatStr);
	stream->Read(&m_iExtraCombatDefense);
	stream->Read(&m_iFreeXPPerTurn);
	stream->Read(&m_iFreeXPFromCombat);
	stream->Read(&m_iGoldFromCombat);
	stream->Read(&m_iGroupSize);
	stream->Read(&m_iMinLevel);
	stream->Read(&m_iModifyGlobalCounter);
	stream->Read(&m_iModifyGlobalCounterOnCombat);
	stream->Read(&m_iResistMagic);
	stream->Read(&m_iSpellCasterXP);
	stream->Read(&m_iSpellDamageModify);
	stream->Read(&m_iWorkRateModify);
	stream->Read(&m_iCaptureUnitCombat);
	stream->Read(&m_iCaptureAnimalChance);
	stream->Read(&m_iCaptureBeastChance);
	stream->Read(&m_iPromotionCombatApply);
	stream->Read(&m_iPromotionImmune1);
	stream->Read(&m_iPromotionImmune2);
	stream->Read(&m_iPromotionImmune3);
	stream->Read(&m_iPromotionRandomApply);
	stream->Read(&m_iPromotionSummonPerk);
	stream->Read(&m_iBonusPrereq);
	stream->Read(&m_iPromotionPrereqOr3);
	stream->Read(&m_iPromotionPrereqOr4);
	stream->Read(&m_iPromotionPrereqOr5);
	stream->Read(&m_iPromotionPrereqOr6);
	stream->Read(&m_iPromotionPrereqAnd);
	stream->Read(&m_iPromotionNextLevel);
	stream->ReadString(m_szPyPerTurn);
	stream->Read(&m_iUnitArtStyleType);
	stream->Read(&m_iPromotionCombatType);
	stream->Read(&m_iPromotionCombatMod);

	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	m_piBonusAffinity = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusAffinity);

	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
	m_piDamageTypeCombat = new int[GC.getNumDamageTypeInfos()];
	stream->Read(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);

	SAFE_DELETE_ARRAY(m_piDamageTypeResist);
	m_piDamageTypeResist = new int[GC.getNumDamageTypeInfos()];
	stream->Read(GC.getNumDamageTypeInfos(), m_piDamageTypeResist);
//FfH: End Add

	// Arrays

	SAFE_DELETE_ARRAY(m_piTerrainAttackPercent);
	m_piTerrainAttackPercent = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainAttackPercent);

	SAFE_DELETE_ARRAY(m_piTerrainDefensePercent);
	m_piTerrainDefensePercent = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainDefensePercent);

	SAFE_DELETE_ARRAY(m_piFeatureAttackPercent);
	m_piFeatureAttackPercent = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureAttackPercent);

	SAFE_DELETE_ARRAY(m_piFeatureDefensePercent);
	m_piFeatureDefensePercent = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureDefensePercent);

	SAFE_DELETE_ARRAY(m_piUnitCombatModifierPercent);
	m_piUnitCombatModifierPercent = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatModifierPercent);

	SAFE_DELETE_ARRAY(m_piDomainModifierPercent);
	m_piDomainModifierPercent = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainModifierPercent);

	SAFE_DELETE_ARRAY(m_pbTerrainDoubleMove);
	m_pbTerrainDoubleMove = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainDoubleMove);

	SAFE_DELETE_ARRAY(m_pbFeatureDoubleMove);
	m_pbFeatureDoubleMove = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureDoubleMove);

	SAFE_DELETE_ARRAY(m_pbUnitCombat);
	m_pbUnitCombat = new bool[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pbUnitCombat);
}

void CvPromotionInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iLayerAnimationPath);
	stream->Write(m_iPrereqPromotion);
	stream->Write(m_iPrereqOrPromotion1);
	stream->Write(m_iPrereqOrPromotion2);

	stream->Write(m_iTechPrereq);
	stream->Write(m_iStateReligionPrereq);
	stream->Write(m_iVisibilityChange);
	stream->Write(m_iMovesChange);
	stream->Write(m_iMoveDiscountChange);
	stream->Write(m_iAirRangeChange);
	stream->Write(m_iInterceptChange);
	stream->Write(m_iEvasionChange);
	stream->Write(m_iWithdrawalChange);
	stream->Write(m_iCargoChange);
	stream->Write(m_iCollateralDamageChange);
	stream->Write(m_iBombardRateChange);
	stream->Write(m_iFirstStrikesChange);
	stream->Write(m_iChanceFirstStrikesChange);
	stream->Write(m_iEnemyHealChange);
	stream->Write(m_iNeutralHealChange);
	stream->Write(m_iFriendlyHealChange);
	stream->Write(m_iSameTileHealChange);
	stream->Write(m_iAdjacentTileHealChange);
	stream->Write(m_iCombatPercent);
	stream->Write(m_iCityAttackPercent);
	stream->Write(m_iCityDefensePercent);
	stream->Write(m_iHillsAttackPercent);
	stream->Write(m_iHillsDefensePercent);
	stream->Write(m_iCommandType);
	stream->Write(m_iRevoltProtection);
	stream->Write(m_iCollateralDamageProtection);
	stream->Write(m_iPillageChange);
	stream->Write(m_iUpgradeDiscount);
	stream->Write(m_iExperiencePercent);
	stream->Write(m_iKamikazePercent);

	stream->Write(m_bLeader);
	stream->Write(m_bBlitz);
	stream->Write(m_bAmphib);
	stream->Write(m_bRiver);
	stream->Write(m_bEnemyRoute);
	stream->Write(m_bAlwaysHeal);
	stream->Write(m_bHillsDoubleMove);
	stream->Write(m_bImmuneToFirstStrikes);

	stream->WriteString(m_szSound);
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
	stream->Write(m_bGear);
	stream->Write(m_bCannotLeaveCulture);
	stream->Write(m_iGoldCost);
	stream->Write(m_iManaCost);
	stream->Write(m_iFaithCost);
	stream->Write(m_iIDWPercent);
	stream->Write(m_iBonusVSUnitsFullHealth);
	stream->Write(m_iNumPrereqBuildingANDs);
    if (m_iNumPrereqBuildingANDs > 0)
        stream->Write(m_iNumPrereqBuildingANDs, m_piPrereqBuildingANDs);
	stream->Write(m_iNumPrereqBuildingORs);
    if (m_iNumPrereqBuildingORs > 0)
        stream->Write(m_iNumPrereqBuildingORs, m_piPrereqBuildingORs);
	stream->Write(m_iNumPrereqCivilizations);
    if (m_iNumPrereqCivilizations > 0)
        stream->Write(m_iNumPrereqCivilizations, m_piPrereqCivilizations);
	stream->Write(m_iNumPromotionExcludes);
    if (m_iNumPromotionExcludes > 0)
        stream->Write(m_iNumPromotionExcludes, m_piPromotionExcludes);
	stream->Write(m_iNumPromotionReplacedBy);
    if (m_iNumPromotionReplacedBy > 0)
        stream->Write(m_iNumPromotionReplacedBy, m_piPromotionReplacedBy);
	stream->Write(m_iNumPromotionMustHave);
    if (m_iNumPromotionMustHave > 0)
        stream->Write(m_iNumPromotionMustHave, m_piPromotionMustHave);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	ADDON (Promotions can be unlocked by Gameoptions) Sephi                     				**/
/*************************************************************************************************/
	stream->Write(m_iRequiredGameOption);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Ranged Combat) Sephi								                     				**/
/*************************************************************************************************/
	stream->Write(m_iAirCombat);
	stream->Write(m_iAirCombatLimitBoost);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	stream->Write(m_bDefensiveStrikes);
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupport);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Better Unit Power (Added by Skyre)
	stream->Write(m_iPowerModifier);
// End Better Unit Power
//FfH: Added by Kael 07/30/2007
	stream->Write(m_bAIControl);
	stream->Write(m_bBoarding);
	stream->Write(m_bOnlyDefensive);
	stream->Write(m_bDispellable);
	stream->Write(m_bDoubleFortifyBonus);
	stream->Write(m_bEquipment);
	stream->Write(m_iFear);
	stream->Write(m_bFlying);
	stream->Write(m_bHeld);
	stream->Write(m_bHiddenNationality);
	stream->Write(m_bIgnoreBuildingDefense);
	stream->Write(m_bImmortal);
	stream->Write(m_bImmuneToCapture);
	stream->Write(m_bImmuneToDefensiveStrike);
	stream->Write(m_bImmuneToFear);
	stream->Write(m_bImmuneToMagic);
	stream->Write(m_bInvisible);
	stream->Write(m_bMutation);
	stream->Write(m_bNotAlive);
	stream->Write(m_bPrereqAlive);
	stream->Write(m_bRace);
	stream->Write(m_bRemovedByCasting);
	stream->Write(m_bRemovedByCombat);
	stream->Write(m_bRemovedWhenHealed);
	stream->Write(m_bSeeInvisible);
	stream->Write(m_bTargetWeakestUnit);
	stream->Write(m_bTargetWeakestUnitCounter);
	stream->Write(m_bTwincast);
	stream->Write(m_bValidate);
	stream->Write(m_bWaterWalking);
	stream->Write(m_iAIWeight);
	stream->Write(m_iBetrayalChance);
	stream->Write(m_iBetterDefenderThanPercent);
	stream->Write(m_iCasterResistModify);
	stream->Write(m_iCombatCapturePercent);
	stream->Write(m_iCombatHealPercent);
	stream->Write(m_iCombatManaGained);
	stream->Write(m_iCombatLimit);
	stream->Write(m_iCombatPercentDefense);
	stream->Write(m_iCombatPercentGlobalCounter);
	stream->Write(m_iCombatPercentInBorders);
	stream->Write(m_iDefensiveStrikeChance);
	stream->Write(m_iDefensiveStrikeDamage);
	stream->Write(m_iEnslavementChance);
	stream->Write(m_iExpireChance);
	stream->Write(m_iExtraCombatStr);
	stream->Write(m_iExtraCombatDefense);
	stream->Write(m_iFreeXPPerTurn);
	stream->Write(m_iFreeXPFromCombat);
	stream->Write(m_iGoldFromCombat);
	stream->Write(m_iGroupSize);
	stream->Write(m_iMinLevel);
	stream->Write(m_iModifyGlobalCounter);
	stream->Write(m_iModifyGlobalCounterOnCombat);
	stream->Write(m_iResistMagic);
	stream->Write(m_iSpellCasterXP);
	stream->Write(m_iSpellDamageModify);
	stream->Write(m_iWorkRateModify);
	stream->Write(m_iCaptureUnitCombat);
	stream->Write(m_iCaptureAnimalChance);
	stream->Write(m_iCaptureBeastChance);
	stream->Write(m_iPromotionCombatApply);
	stream->Write(m_iPromotionImmune1);
	stream->Write(m_iPromotionImmune2);
	stream->Write(m_iPromotionImmune3);
	stream->Write(m_iPromotionRandomApply);
	stream->Write(m_iPromotionSummonPerk);
	stream->Write(m_iBonusPrereq);
	stream->Write(m_iPromotionPrereqOr3);
	stream->Write(m_iPromotionPrereqOr4);
	stream->Write(m_iPromotionPrereqOr5);
	stream->Write(m_iPromotionPrereqOr6);
	stream->Write(m_iPromotionPrereqAnd);
	stream->Write(m_iPromotionNextLevel);
	stream->WriteString(m_szPyPerTurn);
	stream->Write(m_iUnitArtStyleType);
	stream->Write(m_iPromotionCombatType);
	stream->Write(m_iPromotionCombatMod);
	stream->Write(GC.getNumBonusInfos(), m_piBonusAffinity);
	stream->Write(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);
	stream->Write(GC.getNumDamageTypeInfos(), m_piDamageTypeResist);
//FfH: End Add

	// Arrays

	stream->Write(GC.getNumTerrainInfos(), m_piTerrainAttackPercent);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainDefensePercent);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureAttackPercent);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureDefensePercent);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatModifierPercent);
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainModifierPercent);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainDoubleMove);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureDoubleMove);
	stream->Write(GC.getNumUnitCombatInfos(), m_pbUnitCombat);
}

bool CvPromotionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "LayerAnimationPath");
	m_iLayerAnimationPath = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StateReligionPrereq");
	m_iStateReligionPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bLeader, "bLeader");
	if (m_bLeader)
	{
		m_bGraphicalOnly = true;  // don't show in Civilopedia list of promotions
	}
	pXML->GetChildXmlValByName(&m_bBlitz, "bBlitz");
	pXML->GetChildXmlValByName(&m_bAmphib, "bAmphib");
	pXML->GetChildXmlValByName(&m_bRiver, "bRiver");
	pXML->GetChildXmlValByName(&m_bEnemyRoute, "bEnemyRoute");
	pXML->GetChildXmlValByName(&m_bAlwaysHeal, "bAlwaysHeal");
	pXML->GetChildXmlValByName(&m_bHillsDoubleMove, "bHillsDoubleMove");
	pXML->GetChildXmlValByName(&m_bImmuneToFirstStrikes, "bImmuneToFirstStrikes");
	pXML->GetChildXmlValByName(&m_iVisibilityChange, "iVisibilityChange");
	pXML->GetChildXmlValByName(&m_iMovesChange, "iMovesChange");
	pXML->GetChildXmlValByName(&m_iMoveDiscountChange, "iMoveDiscountChange");
	pXML->GetChildXmlValByName(&m_iAirRangeChange, "iAirRangeChange");
	pXML->GetChildXmlValByName(&m_iInterceptChange, "iInterceptChange");
	pXML->GetChildXmlValByName(&m_iEvasionChange, "iEvasionChange");
	pXML->GetChildXmlValByName(&m_iWithdrawalChange, "iWithdrawalChange");
	pXML->GetChildXmlValByName(&m_iCargoChange, "iCargoChange");
	pXML->GetChildXmlValByName(&m_iCollateralDamageChange, "iCollateralDamageChange");
	pXML->GetChildXmlValByName(&m_iBombardRateChange, "iBombardRateChange");
	pXML->GetChildXmlValByName(&m_iFirstStrikesChange, "iFirstStrikesChange");
	pXML->GetChildXmlValByName(&m_iChanceFirstStrikesChange, "iChanceFirstStrikesChange");
	pXML->GetChildXmlValByName(&m_iEnemyHealChange, "iEnemyHealChange");
	pXML->GetChildXmlValByName(&m_iNeutralHealChange, "iNeutralHealChange");
	pXML->GetChildXmlValByName(&m_iFriendlyHealChange, "iFriendlyHealChange");
	pXML->GetChildXmlValByName(&m_iSameTileHealChange, "iSameTileHealChange");
	pXML->GetChildXmlValByName(&m_iAdjacentTileHealChange, "iAdjacentTileHealChange");
	pXML->GetChildXmlValByName(&m_iCombatPercent, "iCombatPercent");
	pXML->GetChildXmlValByName(&m_iCityAttackPercent, "iCityAttack");
	pXML->GetChildXmlValByName(&m_iCityDefensePercent, "iCityDefense");
	pXML->GetChildXmlValByName(&m_iHillsAttackPercent, "iHillsAttack");
	pXML->GetChildXmlValByName(&m_iHillsDefensePercent, "iHillsDefense");
	pXML->GetChildXmlValByName(&m_iRevoltProtection, "iRevoltProtection");
	pXML->GetChildXmlValByName(&m_iCollateralDamageProtection, "iCollateralDamageProtection");
	pXML->GetChildXmlValByName(&m_iPillageChange, "iPillageChange");
	pXML->GetChildXmlValByName(&m_iUpgradeDiscount, "iUpgradeDiscount");
	pXML->GetChildXmlValByName(&m_iExperiencePercent, "iExperiencePercent");
	pXML->GetChildXmlValByName(&m_iKamikazePercent, "iKamikazePercent");

	pXML->SetVariableListTagPair(&m_piTerrainAttackPercent, "TerrainAttacks", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piTerrainDefensePercent, "TerrainDefenses", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piFeatureAttackPercent, "FeatureAttacks", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_piFeatureDefensePercent, "FeatureDefenses", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_piUnitCombatModifierPercent, "UnitCombatMods", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_piDomainModifierPercent, "DomainMods", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);

	pXML->SetVariableListTagPair(&m_pbTerrainDoubleMove, "TerrainDoubleMoves", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureDoubleMove, "FeatureDoubleMoves", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_pbUnitCombat, "UnitCombats", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pbMakeEquipmentDurabilityValid, "MakeEquipmentDurabilityValid", sizeof(GC.getDurabilityInfo((DurabilityTypes)0)), GC.getNumDurabilityInfos());

//FfH: Added by Kael 07/30/2007
	pXML->GetChildXmlValByName(&m_bAIControl, "bAIControl");
	pXML->GetChildXmlValByName(&m_bBoarding, "bBoarding");
	pXML->GetChildXmlValByName(&m_bOnlyDefensive, "bOnlyDefensive");
	pXML->GetChildXmlValByName(&m_bDispellable, "bDispellable");
	pXML->GetChildXmlValByName(&m_bDoubleFortifyBonus, "bDoubleFortifyBonus");
	pXML->GetChildXmlValByName(&m_bEquipment, "bEquipment");
	pXML->GetChildXmlValByName(&m_iFear, "iFear");
	pXML->GetChildXmlValByName(&m_bFlying, "bFlying");
	pXML->GetChildXmlValByName(&m_bHeld, "bHeld");
	pXML->GetChildXmlValByName(&m_bHiddenNationality, "bHiddenNationality");
	pXML->GetChildXmlValByName(&m_bIgnoreBuildingDefense, "bIgnoreBuildingDefense");
	pXML->GetChildXmlValByName(&m_bImmortal, "bImmortal");
	pXML->GetChildXmlValByName(&m_bImmuneToCapture, "bImmuneToCapture");
	pXML->GetChildXmlValByName(&m_bImmuneToDefensiveStrike, "bImmuneToDefensiveStrike");
	pXML->GetChildXmlValByName(&m_bImmuneToFear, "bImmuneToFear");
	pXML->GetChildXmlValByName(&m_bImmuneToMagic, "bImmuneToMagic");
	pXML->GetChildXmlValByName(&m_bInvisible, "bInvisible");
	pXML->GetChildXmlValByName(&m_bMutation, "bMutation");
	pXML->GetChildXmlValByName(&m_bNotAlive, "bNotAlive");
	pXML->GetChildXmlValByName(&m_bPrereqAlive, "bPrereqAlive");
	pXML->GetChildXmlValByName(&m_bRace, "bRace");
	pXML->GetChildXmlValByName(&m_bRemovedByCasting, "bRemovedByCasting");
	pXML->GetChildXmlValByName(&m_bRemovedByCombat, "bRemovedByCombat");
	pXML->GetChildXmlValByName(&m_bRemovedWhenHealed, "bRemovedWhenHealed");
	pXML->GetChildXmlValByName(&m_bSeeInvisible, "bSeeInvisible");
	pXML->GetChildXmlValByName(&m_bTargetWeakestUnit, "bTargetWeakestUnit");
	pXML->GetChildXmlValByName(&m_bTargetWeakestUnitCounter, "bTargetWeakestUnitCounter");
	pXML->GetChildXmlValByName(&m_bTwincast, "bTwincast");
	pXML->GetChildXmlValByName(&m_bValidate, "bValidate");
	pXML->GetChildXmlValByName(&m_bWaterWalking, "bWaterWalking");
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iBetrayalChance, "iBetrayalChance");
	pXML->GetChildXmlValByName(&m_iBetterDefenderThanPercent, "iBetterDefenderThanPercent");
	pXML->GetChildXmlValByName(&m_iCasterResistModify, "iCasterResistModify");
	pXML->GetChildXmlValByName(&m_iCombatCapturePercent, "iCombatCapturePercent");
	pXML->GetChildXmlValByName(&m_iCombatHealPercent, "iCombatHealPercent");
	pXML->GetChildXmlValByName(&m_iCombatManaGained, "iCombatManaGained");
	pXML->GetChildXmlValByName(&m_iCombatLimit, "iCombatLimit");
	pXML->GetChildXmlValByName(&m_iCombatPercentDefense, "iCombatPercentDefense");
	pXML->GetChildXmlValByName(&m_iCombatPercentGlobalCounter, "iCombatPercentGlobalCounter");
	pXML->GetChildXmlValByName(&m_iCombatPercentInBorders, "iCombatPercentInBorders");
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeChance, "iDefensiveStrikeChance");
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeDamage, "iDefensiveStrikeDamage");
	pXML->GetChildXmlValByName(&m_iEnslavementChance, "iEnslavementChance");
	pXML->GetChildXmlValByName(&m_iExpireChance, "iExpireChance");
	pXML->GetChildXmlValByName(&m_iExtraCombatStr, "iExtraCombatStr");
	pXML->GetChildXmlValByName(&m_iExtraCombatDefense, "iExtraCombatDefense");
	pXML->GetChildXmlValByName(&m_iFreeXPPerTurn, "iFreeXPPerTurn");
	pXML->GetChildXmlValByName(&m_iFreeXPFromCombat, "iFreeXPFromCombat");
	pXML->GetChildXmlValByName(&m_iGoldFromCombat, "iGoldFromCombat");
	pXML->GetChildXmlValByName(&m_iGroupSize, "iGroupSize");
	pXML->GetChildXmlValByName(&m_iMinLevel, "iMinLevel",4);
	pXML->GetChildXmlValByName(&m_iMaxLevel, "iMaxLevel",0);
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter, "iModifyGlobalCounter");
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounterOnCombat, "iModifyGlobalCounterOnCombat");
	pXML->GetChildXmlValByName(&m_iResistMagic, "iResistMagic");
	pXML->GetChildXmlValByName(&m_iSpellCasterXP, "iSpellCasterXP");
	pXML->GetChildXmlValByName(&m_iSpellDamageModify, "iSpellDamageModify");
	pXML->GetChildXmlValByName(&m_iWorkRateModify, "iWorkRateModify");
	pXML->GetChildXmlValByName(szTextVal, "CaptureUnitCombat");
	m_iCaptureUnitCombat = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(&m_iCaptureAnimalChance, "iCaptureAnimalChance");
	pXML->GetChildXmlValByName(&m_iCaptureBeastChance, "iCaptureBeastChance");
	pXML->GetChildXmlValByName(szTextVal, "BonusPrereq");
	m_iBonusPrereq = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(m_szPyPerTurn, "PyPerTurn");
	pXML->GetChildXmlValByName(szTextVal, "UnitArtStyleType");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iPromotionCombatMod, "iPromotionCombatMod");
	pXML->SetVariableListTagPair(&m_piBonusAffinity, "BonusAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piDamageTypeCombat, "DamageTypeCombats", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
	pXML->SetVariableListTagPair(&m_piDamageTypeResist, "DamageTypeResists", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
	pXML->SetVariableListTagPair(&m_piCombatAuraDamageTypeResist, "CombatAuraDamageTypeResists", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
/** Equipment Start **/
	pXML->GetChildXmlValByName(&m_bGear, "bGear");
	pXML->GetChildXmlValByName(&m_bClassPromotion, "bClassPromotion");
	pXML->GetChildXmlValByName(&m_bDiscipline, "bDiscipline");
	pXML->GetChildXmlValByName(&m_bGainedInBattle, "bGainedInBattle");
/** Equipment End   **/
	pXML->GetChildXmlValByName(&m_iCombatAuraEffect, "iCombatAuraEffect");
	pXML->GetChildXmlValByName(&m_iCombatAuraRange, "iCombatAuraRange");
	pXML->GetChildXmlValByName(&m_iCombatAuraTargets, "iCombatAuraTargets");
	pXML->GetChildXmlValByName(&m_bAnyUnitCombat, "bAnyUnitCombat",false);
	pXML->GetChildXmlValByName(&m_bCannotLeaveCulture, "bCannotLeaveCulture",false);
	pXML->GetChildXmlValByName(&m_bLimitedByNumberBonuses, "bLimitedByNumberBonuses",false);
	pXML->GetChildXmlValByName(&m_bFlamingArrows, "bFlamingArrows");
	pXML->GetChildXmlValByName(&m_bNoXP, "bNoXP");
	pXML->GetChildXmlValByName(&m_bHeroPromotion, "bHeroPromotion",false);
	pXML->GetChildXmlValByName(&m_iGoldCost, "iGoldCost");
	pXML->GetChildXmlValByName(&m_iManaCost, "iManaCost");
	pXML->GetChildXmlValByName(&m_iFaithCost, "iFaithCost");
	pXML->GetChildXmlValByName(&m_iIDWPercent, "iIDWPercent");
	pXML->GetChildXmlValByName(szTextVal, "UnitClassCreateFromCombat");
	m_iUnitClassCreateFromCombat = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(&m_iUnitClassCreateFromCombatChance, "iUnitClassCreateFromCombatChance");
	pXML->GetChildXmlValByName(&m_iPromotionRandomApplyChance, "iPromotionRandomApplyChance");
	pXML->GetChildXmlValByName(szTextVal, "EquipmentCategory");
	m_iEquipmentCategory = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(&m_iEquipmentLevel, "iEquipmentLevel");
	pXML->GetChildXmlValByName(szTextVal, "DurabilityType");
	m_iDurabilityType = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(&m_iYieldCost, "iYieldCost");
	pXML->GetChildXmlValByName(szTextVal, "EquipmentYieldType");
	m_iEquipmentYieldType = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "YieldCostType");
	m_iYieldCostType = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(&m_iBonusVSUnitsFullHealth, "iBonusVSUnitsFullHealth");
	pXML->GetChildXmlValByName(&m_iReducedManaCost, "iReducedManaCost");
	pXML->GetChildXmlValByName(szTextVal, "TargetUnitCombat");
	m_iUnitCombatTarget = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(&m_iSpellTargetIncrease, "iSpellTargetIncrease");

	pXML->GetChildXmlValByName(&m_iPromotionCombatApplyChance, "iPromotionCombatApplyChance");
    if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBuildingANDs"))	pXML->SetStringWithChildList(&m_iNumPrereqBuildingANDs, &m_aszPrereqBuildingANDsforPass3);
    if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBuildingORs"))	pXML->SetStringWithChildList(&m_iNumPrereqBuildingORs, &m_aszPrereqBuildingORsforPass3);
    if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqCivilizations"))	pXML->SetStringWithChildList(&m_iNumPrereqCivilizations, &m_aszPrereqCivilizationsforPass3);

	pXML->GetChildXmlValByName(&m_bCombatAuraImmunityRangedStrike, "bCombatAuraImmunityRangedStrike");
	pXML->GetChildXmlValByName(&m_bCombatAuraLoyaltyChange, "bCombatAuraLoyaltyChange");
	pXML->GetChildXmlValByName(&m_bCombatAuraImmuneToFearChange, "bCombatAuraImmuneToFearChange");
	pXML->GetChildXmlValByName(&m_bCombatAuraWaterwalking, "bCombatAuraWaterwalking");
	pXML->GetChildXmlValByName(&m_bCombatAuraEnchantedWeapons, "bCombatAuraEnchantedWeapons");

	pXML->GetChildXmlValByName(&m_iCombatAuraExperienceChange, "iCombatAuraExperienceChange");
	pXML->GetChildXmlValByName(&m_iCombatAuraFearEffectChange, "iCombatAuraFearEffectChange");
	pXML->GetChildXmlValByName(&m_iCombatAuraIgnoreFirstStrikes, "iCombatAuraIgnoreFirstStrikes");
	pXML->GetChildXmlValByName(&m_iCombatAuraIncreaseFirstStrikes, "iCombatAuraIncreaseFirstStrikes");
	pXML->GetChildXmlValByName(&m_iCombatAuraCityAttackChange, "iCombatAuraCityAttackChange");
	pXML->GetChildXmlValByName(&m_iCombatAuraHealthRegenerationChange, "iCombatAuraHealthRegenerationChange");
	pXML->GetChildXmlValByName(&m_iCombatAuraStrengthChange, "iCombatAuraStrengthChange");
	pXML->GetChildXmlValByName(szTextVal, "CombatAuraType","NONE");
	m_aszExtraXML1forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionFromCombat");
	m_aszExtraXML2forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AdventurePrereq");
	m_aszExtraXML3forPass3.push_back(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CombatAuraApplyPromotions"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			bool bTemp = false;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCombatAuraApplyPromotionsforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&bTemp);
                            m_abCombatAuraApplyPromotionsforPass3.push_back(bTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CombatAuraRemovePromotions"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			bool bTemp = false;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCombatAuraRemovePromotionsforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&bTemp);
                            m_abCombatAuraRemovePromotionsforPass3.push_back(bTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Promotions can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "RequiredGameOption","NONE");
	m_iRequiredGameOption = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Ranged Combat) Sephi								                     				**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iAirCombat, "iAirCombat");
	pXML->GetChildXmlValByName(&m_iAirCombatLimitBoost, "iAirCombatLimitBoost");
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	pXML->GetChildXmlValByName(&m_bDefensiveStrikes, "bDefensiveStrikes");
//<<<<Refined Defensive Strikes: End Add

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"EquipmentPromotions"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszEquipmentPromotionsforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_abEquipmentPromotionsforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationSupportValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCorporationSupportforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiCorporationSupportforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationSupportModifierValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCorporationSupportModforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiCorporationSupportModforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Better Unit Power (Added by Skyre)
	pXML->GetChildXmlValByName(&m_iPowerModifier, "iPowerModifier");
// End Better Unit Power
	return true;
}

bool CvPromotionInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	HotkeyInfo will call InfoBase for us, so if we need hotkeys, then we don't need Infobase	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq");
	m_iPrereqPromotion = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr1");
	m_iPrereqOrPromotion1 = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr2");
	m_iPrereqOrPromotion2 = GC.getInfoTypeForString(szTextVal);

//FfH: Modified by Kael 02/24/2008
	pXML->GetChildXmlValByName(szTextVal, "PromotionCombatApply");
	m_iPromotionCombatApply = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionImmune1");
	m_iPromotionImmune1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionImmune2");
	m_iPromotionImmune2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionImmune3");
	m_iPromotionImmune3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionRandomApply");
	m_iPromotionRandomApply = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionSummonPerk");
	m_iPromotionSummonPerk = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr3");
	m_iPromotionPrereqOr3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr4");
	m_iPromotionPrereqOr4 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr5");
	m_iPromotionPrereqOr5 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqOr6");
	m_iPromotionPrereqOr6 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereqAnd");
	m_iPromotionPrereqAnd = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionNextLevel");
	m_iPromotionNextLevel = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionCombatType");
	m_iPromotionCombatType = pXML->FindInInfoClass(szTextVal);
//FfH: End Modify
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionExcludes"))
		pXML->SetIntWithChildList(&m_iNumPromotionExcludes, &m_piPromotionExcludes);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionReplacedBy"))
		pXML->SetIntWithChildList(&m_iNumPromotionReplacedBy, &m_piPromotionReplacedBy);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PromotionMustHave"))
		pXML->SetIntWithChildList(&m_iNumPromotionMustHave, &m_piPromotionMustHave);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	return true;
}


//FfH: Added by Kael 09/09/2007
bool CvPromotionInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3[0] != "")
	{
	    m_iUnitArtStyleType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	}
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iUnitArtStyleType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
    m_aszExtraXMLforPass3.clear();

	iSize = m_aszExtraXML1forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML1forPass3[i], true) != -1)
		{
			m_iCombatAuraType = GC.getInfoTypeForString(m_aszExtraXML1forPass3[i]);
			break;
		}
	}
    m_aszExtraXML1forPass3.clear();

	iSize = m_aszExtraXML2forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML2forPass3[i], true) != -1)
		{
			m_iPromotionFromCombat = GC.getInfoTypeForString(m_aszExtraXML2forPass3[i]);
			break;
		}
	}
    m_aszExtraXML2forPass3.clear();

	iSize = m_aszExtraXML3forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML3forPass3[i], true) != -1)
		{
			m_iAdventurePrereq = GC.getInfoTypeForString(m_aszExtraXML3forPass3[i]);
			break;
		}
	}
    m_aszExtraXML3forPass3.clear();

    m_pabEquipmentPromotions = new bool[GC.getNumPromotionInfos()];
    for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
        m_pabEquipmentPromotions[iI] = false;
	}
    int iNumLoad = m_abEquipmentPromotionsforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszEquipmentPromotionsforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_pabEquipmentPromotions[GC.getInfoTypeForString(m_aszEquipmentPromotionsforPass3[iI])] = m_abEquipmentPromotionsforPass3[iI];
	}
    m_aszEquipmentPromotionsforPass3.clear();
    m_abEquipmentPromotionsforPass3.clear();

/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
    for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
        m_paiCorporationSupport[iI] = 0;
	}
    iNumLoad = m_aiCorporationSupportforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCorporationSupportforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_paiCorporationSupport[GC.getInfoTypeForString(m_aszCorporationSupportforPass3[iI])] += m_aiCorporationSupportforPass3[iI];
	}
    m_aszCorporationSupportforPass3.clear();
    m_aiCorporationSupportforPass3.clear();


    m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
    for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
        m_paiCorporationSupportMod[iI] = 0;
	}
    iNumLoad = m_aiCorporationSupportModforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCorporationSupportModforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_paiCorporationSupportMod[GC.getInfoTypeForString(m_aszCorporationSupportModforPass3[iI])] += m_aiCorporationSupportModforPass3[iI];
	}
    m_aszCorporationSupportModforPass3.clear();
    m_aiCorporationSupportModforPass3.clear();

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
    m_pbCombatAuraApplyPromotion = new bool[GC.getNumPromotionInfos()];
    for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
        m_pbCombatAuraApplyPromotion[iI] = false;
	}
    iNumLoad = m_abCombatAuraApplyPromotionsforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCombatAuraApplyPromotionsforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_pbCombatAuraApplyPromotion[GC.getInfoTypeForString(m_aszCombatAuraApplyPromotionsforPass3[iI])] = m_abCombatAuraApplyPromotionsforPass3[iI];
	}
    m_aszCombatAuraApplyPromotionsforPass3.clear();
    m_abCombatAuraApplyPromotionsforPass3.clear();

    m_pbCombatAuraRemovePromotion = new bool[GC.getNumPromotionInfos()];
    for (int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
        m_pbCombatAuraRemovePromotion[iI] = false;
	}
    iNumLoad = m_abCombatAuraRemovePromotionsforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCombatAuraRemovePromotionsforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_pbCombatAuraRemovePromotion[GC.getInfoTypeForString(m_aszCombatAuraRemovePromotionsforPass3[iI])] = m_abCombatAuraRemovePromotionsforPass3[iI];
	}
    m_aszCombatAuraRemovePromotionsforPass3.clear();
    m_abCombatAuraRemovePromotionsforPass3.clear();

    m_piPrereqBuildingANDs = new int[m_iNumPrereqBuildingANDs];
	for(int iI = 0; iI < m_iNumPrereqBuildingANDs; iI++)
		m_piPrereqBuildingANDs[iI] = GC.getInfoTypeForString(m_aszPrereqBuildingANDsforPass3[iI]);
    m_aszPrereqBuildingANDsforPass3.clear();

    m_piPrereqBuildingORs = new int[m_iNumPrereqBuildingORs];
	for(int iI = 0; iI < m_iNumPrereqBuildingORs; iI++)
		m_piPrereqBuildingORs[iI] = GC.getInfoTypeForString(m_aszPrereqBuildingORsforPass3[iI]);
    m_aszPrereqBuildingORsforPass3.clear();

    m_piPrereqCivilizations = new int[m_iNumPrereqCivilizations];
	for(int iI = 0; iI < m_iNumPrereqCivilizations; iI++)
		m_piPrereqCivilizations[iI] = GC.getInfoTypeForString(m_aszPrereqCivilizationsforPass3[iI]);
    m_aszPrereqCivilizationsforPass3.clear();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(PromotionInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvPromotionInfo::copyNonDefaults(CvPromotionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isLeader()								== false)				m_bLeader							= pClassInfo->isLeader();

	if (isBlitz()								== false)				m_bBlitz							= pClassInfo->isBlitz();
	if (isAmphib()								== false)				m_bAmphib							= pClassInfo->isAmphib();
	if (isRiver()								== false)				m_bRiver							= pClassInfo->isRiver();
	if (isEnemyRoute()							== false)				m_bEnemyRoute						= pClassInfo->isEnemyRoute();
	if (isAlwaysHeal()							== false)				m_bAlwaysHeal						= pClassInfo->isAlwaysHeal();
	if (isHillsDoubleMove()						== false)				m_bHillsDoubleMove					= pClassInfo->isHillsDoubleMove();
	if (isImmuneToFirstStrikes()				== false)				m_bImmuneToFirstStrikes				= pClassInfo->isImmuneToFirstStrikes();
	if (isAIControl()							== false)				m_bAIControl						= pClassInfo->isAIControl();
	if (isBoarding()							== false)				m_bBoarding							= pClassInfo->isBoarding();
	if (isOnlyDefensive()						== false)				m_bOnlyDefensive					= pClassInfo->isOnlyDefensive();
	if (isDispellable()							== false)				m_bDispellable						= pClassInfo->isDispellable();
	if (isDoubleFortifyBonus()					== false)				m_bDoubleFortifyBonus				= pClassInfo->isDoubleFortifyBonus();
	if (isEquipment()							== false)				m_bEquipment						= pClassInfo->isEquipment();
	if (getFear()								== 0)					m_iFear								= pClassInfo->getFear();
	if (isFlying()								== false)				m_bFlying							= pClassInfo->isFlying();
	if (isHeld()								== false)				m_bHeld								= pClassInfo->isHeld();
	if (isHiddenNationality()					== false)				m_bHiddenNationality				= pClassInfo->isHiddenNationality();
	if (isIgnoreBuildingDefense()				== false)				m_bIgnoreBuildingDefense			= pClassInfo->isIgnoreBuildingDefense();
	if (isImmortal()							== false)				m_bImmortal							= pClassInfo->isImmortal();
	if (isImmuneToCapture()						== false)				m_bImmuneToCapture					= pClassInfo->isImmuneToCapture();
	if (isImmuneToDefensiveStrike()				== false)				m_bImmuneToDefensiveStrike			= pClassInfo->isImmuneToDefensiveStrike();
	if (isImmuneToFear()						== false)				m_bImmuneToFear						= pClassInfo->isImmuneToFear();
	if (isImmuneToMagic()						== false)				m_bImmuneToMagic					= pClassInfo->isImmuneToMagic();
	if (isInvisible()							== false)				m_bInvisible						= pClassInfo->isInvisible();
	if (isMutation()							== false)				m_bMutation							= pClassInfo->isMutation();
	if (isNotAlive()							== false)				m_bNotAlive							= pClassInfo->isNotAlive();
	if (isPrereqAlive()							== false)				m_bPrereqAlive						= pClassInfo->isPrereqAlive();
	if (isRace()								== false)				m_bRace								= pClassInfo->isRace();
	if (isRemovedByCasting()					== false)				m_bRemovedByCasting					= pClassInfo->isRemovedByCasting();
	if (isRemovedByCombat()						== false)				m_bRemovedByCombat					= pClassInfo->isRemovedByCombat();
	if (isRemovedWhenHealed()					== false)				m_bRemovedWhenHealed				= pClassInfo->isRemovedWhenHealed();
    if (isSeeInvisible()                        == false)               m_bSeeInvisible                     = pClassInfo->isSeeInvisible();
	if (isTargetWeakestUnit()					== false)				m_bTargetWeakestUnit				= pClassInfo->isTargetWeakestUnit();
	if (isTargetWeakestUnitCounter()			== false)				m_bTargetWeakestUnitCounter			= pClassInfo->isTargetWeakestUnitCounter();
	if (isTwincast()							== false)				m_bTwincast							= pClassInfo->isTwincast();
	if (isValidate()							== false)				m_bValidate							= pClassInfo->isValidate();
	if (isWaterWalking()						== false)				m_bWaterWalking						= pClassInfo->isWaterWalking();
	if (getVisibilityChange()					== 0)					m_iVisibilityChange					= pClassInfo->getVisibilityChange();
	if (getMovesChange()						== 0)					m_iMovesChange						= pClassInfo->getMovesChange();
	if (getMoveDiscountChange()					== 0)					m_iMoveDiscountChange				= pClassInfo->getMoveDiscountChange();
	if (getAirRangeChange()						== 0)					m_iAirRangeChange					= pClassInfo->getAirRangeChange();
	if (getInterceptChange()					== 0)					m_iInterceptChange					= pClassInfo->getInterceptChange();
	if (getEvasionChange()						== 0)					m_iEvasionChange					= pClassInfo->getEvasionChange();
	if (getWithdrawalChange()					== 0)					m_iWithdrawalChange					= pClassInfo->getWithdrawalChange();
	if (getCargoChange()						== 0)					m_iCargoChange						= pClassInfo->getCargoChange();
	if (getCollateralDamageChange()				== 0)					m_iCollateralDamageChange			= pClassInfo->getCollateralDamageChange();
	if (getBombardRateChange()					== 0)					m_iBombardRateChange				= pClassInfo->getBombardRateChange();
	if (getFirstStrikesChange()					== 0)					m_iFirstStrikesChange				= pClassInfo->getFirstStrikesChange();
	if (getChanceFirstStrikesChange()			== 0)					m_iChanceFirstStrikesChange			= pClassInfo->getChanceFirstStrikesChange();
	if (getEnemyHealChange()					== 0)					m_iEnemyHealChange					= pClassInfo->getEnemyHealChange();
	if (getNeutralHealChange()					== 0)					m_iNeutralHealChange				= pClassInfo->getNeutralHealChange();
	if (getFriendlyHealChange()					== 0)					m_iFriendlyHealChange				= pClassInfo->getFriendlyHealChange();
	if (getSameTileHealChange()					== 0)					m_iSameTileHealChange				= pClassInfo->getSameTileHealChange();
	if (getAdjacentTileHealChange()				== 0)					m_iAdjacentTileHealChange			= pClassInfo->getAdjacentTileHealChange();
	if (getCombatPercent()						== 0)					m_iCombatPercent					= pClassInfo->getCombatPercent();
	if (getCityAttackPercent()					== 0)					m_iCityAttackPercent				= pClassInfo->getCityAttackPercent();
	if (getCityDefensePercent()					== 0)					m_iCityDefensePercent				= pClassInfo->getCityDefensePercent();
	if (getHillsAttackPercent()					== 0)					m_iHillsAttackPercent				= pClassInfo->getHillsAttackPercent();
	if (getHillsDefensePercent()				== 0)					m_iHillsDefensePercent				= pClassInfo->getHillsDefensePercent();
	if (getRevoltProtection()					== 0)					m_iRevoltProtection					= pClassInfo->getRevoltProtection();
	if (getCollateralDamageProtection()			== 0)					m_iCollateralDamageProtection		= pClassInfo->getCollateralDamageProtection();
	if (getPillageChange()						== 0)					m_iPillageChange					= pClassInfo->getPillageChange();
	if (getUpgradeDiscount()					== 0)					m_iUpgradeDiscount					= pClassInfo->getUpgradeDiscount();
	if (getExperiencePercent()					== 0)					m_iExperiencePercent				= pClassInfo->getExperiencePercent();
	if (getKamikazePercent()					== 0)					m_iKamikazePercent					= pClassInfo->getKamikazePercent();
	if (getAIWeight()							== 0)					m_iAIWeight							= pClassInfo->getAIWeight();
	if (getBetrayalChance()						== 0)					m_iBetrayalChance					= pClassInfo->getBetrayalChance();
	if (getBetterDefenderThanPercent()			== 0)					m_iBetterDefenderThanPercent		= pClassInfo->getBetterDefenderThanPercent();
	if (getCasterResistModify()					== 0)					m_iCasterResistModify				= pClassInfo->getCasterResistModify();
	if (getCombatCapturePercent()				== 0)					m_iCombatCapturePercent				= pClassInfo->getCombatCapturePercent();
	if (getCombatHealPercent()					== 0)					m_iCombatHealPercent				= pClassInfo->getCombatHealPercent();
	if (getCombatManaGained()					== 0)					m_iCombatManaGained					= pClassInfo->getCombatManaGained();
	if (getCombatLimit()						== 0)					m_iCombatLimit						= pClassInfo->getCombatLimit();
	if (getCombatPercentDefense()				== 0)					m_iCombatPercentDefense				= pClassInfo->getCombatPercentDefense();
	if (getCombatPercentGlobalCounter()			== 0)					m_iCombatPercentGlobalCounter		= pClassInfo->getCombatPercentGlobalCounter();
	if (getCombatPercentInBorders()				== 0)					m_iCombatPercentInBorders			= pClassInfo->getCombatPercentInBorders();
	if (getDefensiveStrikeChance()				== 0)					m_iDefensiveStrikeChance			= pClassInfo->getDefensiveStrikeChance();
	if (getDefensiveStrikeDamage()				== 0)					m_iDefensiveStrikeDamage			= pClassInfo->getDefensiveStrikeDamage();
	if (getEnslavementChance()					== 0)					m_iEnslavementChance				= pClassInfo->getEnslavementChance();
	if (getExpireChance()						== 0)					m_iExpireChance						= pClassInfo->getExpireChance();
	if (getExtraCombatStr()						== 0)					m_iExtraCombatStr					= pClassInfo->getExtraCombatStr();
	if (getExtraCombatDefense()					== 0)					m_iExtraCombatDefense				= pClassInfo->getExtraCombatDefense();
	if (getFreeXPPerTurn()						== 0)					m_iFreeXPPerTurn					= pClassInfo->getFreeXPPerTurn();
	if (getFreeXPFromCombat()					== 0)					m_iFreeXPFromCombat					= pClassInfo->getFreeXPFromCombat();
    if (getGoldFromCombat()                     == 0)                   m_iGoldFromCombat                   = pClassInfo->getGoldFromCombat();
	if (getGroupSize()							== 0)					m_iGroupSize						= pClassInfo->getGroupSize();
	if (getMinLevel()							== 4)					m_iMinLevel							= pClassInfo->getMinLevel();
	if (getMaxLevel()							== 0)					m_iMaxLevel							= pClassInfo->getMaxLevel();
	if (getModifyGlobalCounter()				== 0)					m_iModifyGlobalCounter				= pClassInfo->getModifyGlobalCounter();
	if (getModifyGlobalCounterOnCombat()		== 0)					m_iModifyGlobalCounterOnCombat		= pClassInfo->getModifyGlobalCounterOnCombat();
	if (getResistMagic()						== 0)					m_iResistMagic						= pClassInfo->getResistMagic();
	if (getSpellCasterXP()						== 0)					m_iSpellCasterXP					= pClassInfo->getSpellCasterXP();
	if (getWorkRateModify()						== 0)					m_iWorkRateModify					= pClassInfo->getWorkRateModify();
	if (getSound()								== cDefault)			m_szSound							= pClassInfo->getSound();
	if (getPyPerTurn()							== cDefault)			m_szPyPerTurn						= pClassInfo->getPyPerTurn();
	if (getTechPrereq()							== NO_TECH)				m_iTechPrereq						= pClassInfo->getTechPrereq();
	if (getBonusPrereq()						== NO_BONUS)			m_iBonusPrereq						= pClassInfo->getBonusPrereq();
	if (getStateReligionPrereq()				== NO_RELIGION)			m_iStateReligionPrereq				= pClassInfo->getStateReligionPrereq();
	if (getPromotionCombatMod()					== NO_PROMOTION)		m_iPromotionCombatMod				= pClassInfo->getPromotionCombatMod();
	if (getCaptureUnitCombat()					== NO_UNITCOMBAT)		m_iCaptureUnitCombat				= pClassInfo->getCaptureUnitCombat();
	if (getCaptureAnimalChance()				== 0)					m_iCaptureAnimalChance				= pClassInfo->getCaptureAnimalChance();
	if (getCaptureBeastChance()					== 0)					m_iCaptureBeastChance				= pClassInfo->getCaptureBeastChance();
	if (getLayerAnimationPath()					== ANIMATIONPATH_NONE)	m_iLayerAnimationPath				= pClassInfo->getLayerAnimationPath();
	for (int j = 0; j < GC.getNumBonusInfos(); j++)
	{
		if (m_piBonusAffinity[j]				== 0)					m_piBonusAffinity[j]				= pClassInfo->getBonusAffinity(j);
	}
	for (int j = 0; j < GC.getNumDamageTypeInfos(); j++)
	{
		if (m_piDamageTypeResist[j]				== 0)					m_piDamageTypeResist[j]				= pClassInfo->getDamageTypeResist(j);
		if (m_piDamageTypeCombat[j]				== 0)					m_piDamageTypeCombat[j]				= pClassInfo->getDamageTypeCombat(j);
		if (m_piCombatAuraDamageTypeResist[j]	== 0)					m_piCombatAuraDamageTypeResist[j]	= pClassInfo->getCombatAuraDamageTypeResist(j);
	}
	for (int j = 0; j < GC.getNumTerrainInfos(); j++)
	{
		if (m_piTerrainAttackPercent[j]			== 0)					m_piTerrainAttackPercent[j]			= pClassInfo->getTerrainAttackPercent(j);
		if (m_piTerrainDefensePercent[j]		== 0)					m_piTerrainDefensePercent[j]		= pClassInfo->getTerrainDefensePercent(j);
		if (m_pbTerrainDoubleMove[j]			== false)				m_pbTerrainDoubleMove[j]			= pClassInfo->getTerrainDoubleMove(j);
	}
	for (int j = 0; j < GC.getNumFeatureInfos(); j++)
	{
		if (m_piFeatureAttackPercent[j]			== 0)					m_piFeatureAttackPercent[j]			= pClassInfo->getFeatureAttackPercent(j);
		if (m_piFeatureDefensePercent[j]		== 0)					m_piFeatureDefensePercent[j]		= pClassInfo->getFeatureDefensePercent(j);
		if (m_pbFeatureDoubleMove[j]			== false)				m_pbFeatureDoubleMove[j]			= pClassInfo->getFeatureDoubleMove(j);
	}
	for (int j = 0; j < GC.getNumUnitCombatInfos(); j++)
	{
		if (m_piUnitCombatModifierPercent[j]	== 0)					m_piUnitCombatModifierPercent[j]	= pClassInfo->getUnitCombatModifierPercent(j);
		if (m_pbUnitCombat[j]					== false)				m_pbUnitCombat[j]					= pClassInfo->getUnitCombat(j);
	}

	for (int j = 0; j < GC.getNumDurabilityInfos(); j++)
	{
		if (m_pbMakeEquipmentDurabilityValid[j]	== false)				m_pbMakeEquipmentDurabilityValid[j]	= pClassInfo->isMakeEquipmentDurabilityValid(j);
	}

	for (int j = 0; j < NUM_DOMAIN_TYPES; j++)
	{
		if (m_piDomainModifierPercent[j]		== 0)			m_piDomainModifierPercent[j]		= pClassInfo->getDomainModifierPercent(j);
	}
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/
/** Equipment Start **/
	if (isGear()								== false)				m_bGear								= pClassInfo->isGear();
	if (isClassPromotion()						== false)				m_bClassPromotion					= pClassInfo->isClassPromotion();
	if (isDiscipline()							== false)				m_bDiscipline						= pClassInfo->isDiscipline();
	if (isGainedInBattle()						== false)				m_bGainedInBattle					= pClassInfo->isGainedInBattle();
/** Equipment End   **/
	if (getCombatAuraEffect()					== 0)					m_iCombatAuraEffect					= pClassInfo->getCombatAuraEffect();
	if (getCombatAuraRange()					== 0)					m_iCombatAuraRange					= pClassInfo->getCombatAuraRange();
	if (getCombatAuraTargets()					== 0)					m_iCombatAuraTargets				= pClassInfo->getCombatAuraTargets();
	if (isAnyUnitCombat()						== false)				m_bAnyUnitCombat					= pClassInfo->isAnyUnitCombat();
	if (isCannotLeaveCulture()					== false)				m_bCannotLeaveCulture				= pClassInfo->isCannotLeaveCulture();
	if (isLimitedByNumberBonuses()				== false)				m_bLimitedByNumberBonuses			= pClassInfo->isLimitedByNumberBonuses();
	if (isNoXP()								== false)				m_bNoXP								= pClassInfo->isNoXP();
	if (isFlamingArrows()						== false)				m_bFlamingArrows					= pClassInfo->isFlamingArrows();
	if (isHeroPromotion()						== false)				m_bHeroPromotion					= pClassInfo->isHeroPromotion();	
	if (getGoldCost()							== 0)					m_iGoldCost							= pClassInfo->getGoldCost();
	if (getManaCost()							== 0)					m_iManaCost							= pClassInfo->getManaCost();
	if (getFaithCost()							== 0)					m_iFaithCost						= pClassInfo->getFaithCost();
	if (getIDWPercent()							== 0)					m_iIDWPercent						= pClassInfo->getIDWPercent();
	if (getUnitClassCreateFromCombat()			== 0)					m_iUnitClassCreateFromCombat		= pClassInfo->getUnitClassCreateFromCombat();
	if (getUnitClassCreateFromCombatChance()	== 0)					m_iUnitClassCreateFromCombatChance	= pClassInfo->getUnitClassCreateFromCombatChance();
	if (getEquipmentCategory()					== 0)					m_iEquipmentCategory				= pClassInfo->getEquipmentCategory();
	if (getEquipmentLevel()						== 0)					m_iEquipmentLevel					= pClassInfo->getEquipmentLevel();
	if (getDurabilityType()						== 0)					m_iDurabilityType					= pClassInfo->getDurabilityType();

	if (getEquipmentYieldType()						== NO_YIELD)		m_iEquipmentYieldType					= pClassInfo->getEquipmentYieldType();
	if (getYieldCostType()						== NO_YIELD)			m_iYieldCostType					= pClassInfo->getYieldCostType();
	if (getYieldCost(1)							== 0)					m_iYieldCost						= pClassInfo->getYieldCost(1);
	if (getBonusVSUnitsFullHealth()				== 0)					m_iBonusVSUnitsFullHealth			= pClassInfo->getBonusVSUnitsFullHealth();
	if (getReducedManaCost()					== 0)					m_iReducedManaCost					= pClassInfo->getReducedManaCost();

	if (getUnitCombatTarget()					== NO_UNITCOMBAT)		m_iUnitCombatTarget					= pClassInfo->getUnitCombatTarget();
	if (getPromotionFromCombat()				== NO_PROMOTION)		m_iPromotionFromCombat				= pClassInfo->getPromotionFromCombat();
	if (getSpellTargetIncrease()				== 0)					m_iSpellTargetIncrease				= pClassInfo->getSpellTargetIncrease();

	if (isCombatAuraImmunityRangedStrike()		== false)				m_bCombatAuraImmunityRangedStrike	= pClassInfo->isCombatAuraImmunityRangedStrike();
	if (isCombatAuraLoyaltyChange()				== false)				m_bCombatAuraLoyaltyChange			= pClassInfo->isCombatAuraLoyaltyChange();
	if (isCombatAuraImmuneToFearChange()		== false)				m_bCombatAuraImmuneToFearChange		= pClassInfo->isCombatAuraImmuneToFearChange();
	if (isCombatAuraWaterwalking()				== false)				m_bCombatAuraWaterwalking			= pClassInfo->isCombatAuraWaterwalking();
	if (isCombatAuraEnchantedWeapons()			== false)				m_bCombatAuraWaterwalking			= pClassInfo->isCombatAuraEnchantedWeapons();

	if (getCombatAuraExperienceChange()			== 0)					m_iCombatAuraExperienceChange		= pClassInfo->getCombatAuraExperienceChange();
	if (getCombatAuraFearEffectChange()			== 0)					m_iCombatAuraFearEffectChange		= pClassInfo->getCombatAuraFearEffectChange();
	if (getCombatAuraIgnoreFirstStrikes()		== 0)					m_iCombatAuraIgnoreFirstStrikes		= pClassInfo->getCombatAuraIgnoreFirstStrikes();
	if (getCombatAuraIncreaseFirstStrikes()		== 0)					m_iCombatAuraIncreaseFirstStrikes		= pClassInfo->getCombatAuraIncreaseFirstStrikes();
	if (getCombatAuraCityAttackChange()			== 0)					m_iCombatAuraCityAttackChange		= pClassInfo->getCombatAuraCityAttackChange();
	if (getCombatAuraHealthRegenerationChange()	== 0)					m_iCombatAuraHealthRegenerationChange	= pClassInfo->getCombatAuraHealthRegenerationChange();
	if (getCombatAuraStrengthChange()			== 0)					m_iCombatAuraStrengthChange			= pClassInfo->getCombatAuraStrengthChange();

	for(int i = 0; i < pClassInfo->getNumPrereqBuildingANDs(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqBuildingANDs();++j)
		{
			if(pClassInfo->getPrereqBuildingANDsVectorElement(i) == getPrereqBuildingANDsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqBuildingANDsforPass3.push_back(	pClassInfo->getPrereqBuildingANDsVectorElement(i));
			m_iNumPrereqBuildingANDs++;
		}
	}
	for(int i = 0; i < pClassInfo->getNumPrereqBuildingORs(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqBuildingORs();++j)
		{
			if(pClassInfo->getPrereqBuildingORsVectorElement(i) == getPrereqBuildingORsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqBuildingORsforPass3.push_back(	pClassInfo->getPrereqBuildingORsVectorElement(i));
			m_iNumPrereqBuildingORs++;
		}
	}

	for(int i = 0; i < pClassInfo->getNumPrereqCivilizations(); ++i)
	{
		bool bLoad = true;
		for(int j=0;j<getNumPrereqCivilizations();++j)
		{
			if(pClassInfo->getPrereqCivilizationsVectorElement(i) == getPrereqCivilizationsVectorElement(j))
			{
				bLoad = false;
				break;
			}
		}
		if(bLoad)
		{
			m_aszPrereqCivilizationsforPass3.push_back(	pClassInfo->getPrereqCivilizationsVectorElement(i));
			m_iNumPrereqCivilizations++;
		}
	}

	if(pClassInfo->getNumPromotionExcludes() > 0)
	{
		int* tempArray = new int[getNumPromotionExcludes() + pClassInfo->getNumPromotionExcludes()];
		for(int i = 0; i< getNumPromotionExcludes(); ++i)
		{
			tempArray[i] = getPromotionExcludes(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionExcludes(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionExcludes();++j)
			{
				if(pClassInfo->getPromotionExcludes(i) == getPromotionExcludes(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionExcludes()] = pClassInfo->getPromotionExcludes(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionExcludes);
		int iGoalSize = getNumPromotionExcludes() + iNewItems;
		m_piPromotionExcludes = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionExcludes[i] = tempArray[i];
			FAssertMsg(m_piPromotionExcludes[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionExcludes[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionExcludes = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionReplacedBy() > 0)
	{
		int* tempArray = new int[getNumPromotionReplacedBy() + pClassInfo->getNumPromotionReplacedBy()];
		for(int i = 0; i< getNumPromotionReplacedBy(); ++i)
		{
			tempArray[i] = getPromotionReplacedBy(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionReplacedBy(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionReplacedBy();++j)
			{
				if(pClassInfo->getPromotionReplacedBy(i) == getPromotionReplacedBy(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionReplacedBy()] = pClassInfo->getPromotionReplacedBy(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
		int iGoalSize = getNumPromotionReplacedBy() + iNewItems;
		m_piPromotionReplacedBy = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionReplacedBy[i] = tempArray[i];
			FAssertMsg(m_piPromotionReplacedBy[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionReplacedBy[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionReplacedBy = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}

	if(pClassInfo->getNumPromotionMustHave() > 0)
	{
		int* tempArray = new int[getNumPromotionMustHave() + pClassInfo->getNumPromotionMustHave()];
		for(int i = 0; i< getNumPromotionMustHave(); ++i)
		{
			tempArray[i] = getPromotionMustHave(i);
		}
		int iNewItems = 0;
		for(int i = 0; i < pClassInfo->getNumPromotionMustHave(); ++i)
		{
			bool bLoad = true;
			for(int j=0;j<getNumPromotionMustHave();++j)
			{
				if(pClassInfo->getPromotionMustHave(i) == getPromotionMustHave(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				tempArray[iNewItems+getNumPromotionMustHave()] = pClassInfo->getPromotionMustHave(i);
				iNewItems++;
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionMustHave);
		int iGoalSize = getNumPromotionMustHave() + iNewItems;
		m_piPromotionMustHave = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionMustHave[i] = tempArray[i];
			FAssertMsg(m_piPromotionMustHave[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionMustHave[i] > -1 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionMustHave = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	ADDON (Promotions can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	if (getRequiredGameOption()		== NO_GAMEOPTION)					m_iRequiredGameOption	= pClassInfo->getRequiredGameOption();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Ranged Combat) Sephi                     					**/
/*************************************************************************************************/
	if (getAirCombat()							== 0)					m_iAirCombat						= pClassInfo->getAirCombat();
	if (getAirCombatLimitBoost()				== 0)					m_iAirCombatLimitBoost				= pClassInfo->getAirCombatLimitBoost();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	if (isDefensiveStrikes()					== false)				m_bDefensiveStrikes					= pClassInfo->isDefensiveStrikes();
//<<<<Refined Defensive Strikes: End Add

	// Readpass2 stuff
	if (getPrereqPromotion()					== NO_PROMOTION)		m_iPrereqPromotion					= pClassInfo->getPrereqPromotion();
	if (getPrereqOrPromotion1()					== NO_PROMOTION)		m_iPrereqOrPromotion1				= pClassInfo->getPrereqOrPromotion1();
	if (getPrereqOrPromotion2()					== NO_PROMOTION)		m_iPrereqOrPromotion2				= pClassInfo->getPrereqOrPromotion2();
	if (getPromotionCombatApply()				== NO_PROMOTION)		m_iPromotionCombatApply				= pClassInfo->getPromotionCombatApply();
	if (getPromotionCombatApplyChance()			== 0)					m_iPromotionCombatApplyChance		= pClassInfo->getPromotionCombatApplyChance();
	if (getPromotionImmune1()					== NO_PROMOTION)		m_iPromotionImmune1					= pClassInfo->getPromotionImmune1();
	if (getPromotionImmune2()					== NO_PROMOTION)		m_iPromotionImmune2					= pClassInfo->getPromotionImmune2();
	if (getPromotionImmune3()					== NO_PROMOTION)		m_iPromotionImmune3					= pClassInfo->getPromotionImmune3();
	if (getPromotionRandomApply()				== NO_PROMOTION)		m_iPromotionRandomApply				= pClassInfo->getPromotionRandomApply();
	if (getPromotionRandomApplyChance()			== 0)					m_iPromotionRandomApplyChance		= pClassInfo->getPromotionRandomApplyChance();
	if (getPromotionSummonPerk()				== NO_PROMOTION)		m_iPromotionSummonPerk				= pClassInfo->getPromotionSummonPerk();
	if (getPromotionPrereqOr3()					== NO_PROMOTION)		m_iPromotionPrereqOr3				= pClassInfo->getPromotionPrereqOr3();
	if (getPromotionPrereqOr4()					== NO_PROMOTION)		m_iPromotionPrereqOr4				= pClassInfo->getPromotionPrereqOr4();
	if (getPromotionPrereqOr5()					== NO_PROMOTION)		m_iPromotionPrereqOr5				= pClassInfo->getPromotionPrereqOr5();
	if (getPromotionPrereqOr6()					== NO_PROMOTION)		m_iPromotionPrereqOr6				= pClassInfo->getPromotionPrereqOr6();
	if (getPromotionPrereqAnd()					== NO_PROMOTION)		m_iPromotionPrereqAnd				= pClassInfo->getPromotionPrereqAnd();
	if (getPromotionNextLevel()					== NO_PROMOTION)		m_iPromotionNextLevel				= pClassInfo->getPromotionNextLevel();
	if (getPromotionCombatType()				== NO_PROMOTION)		m_iPromotionCombatType				= pClassInfo->getPromotionCombatType();
 	// Readpass3 stuff

	for ( int i = 0; i < pClassInfo->getCombatAuraApplyPromotionVectorSize(); i++ )
	{
		m_aszCombatAuraApplyPromotionsforPass3.push_back(	pClassInfo->getCombatAuraApplyPromotionNamesVectorElement(i));
		m_abCombatAuraApplyPromotionsforPass3.push_back(	pClassInfo->getCombatAuraApplyPromotionValuesVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getCombatAuraRemovePromotionVectorSize(); i++ )
	{
		m_aszCombatAuraRemovePromotionsforPass3.push_back(	pClassInfo->getCombatAuraRemovePromotionNamesVectorElement(i));
		m_abCombatAuraRemovePromotionsforPass3.push_back(	pClassInfo->getCombatAuraRemovePromotionValuesVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getCombatAuraTypeVectorSize(); i++ )
	{
		m_aszExtraXML1forPass3.push_back(pClassInfo->getCombatAuraTypeVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getPromotionFromCombatVectorSize(); i++ )
	{
		m_aszExtraXML2forPass3.push_back(pClassInfo->getPromotionFromCombatVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getAdventurePrereqVectorSize(); i++ )
	{
		m_aszExtraXML3forPass3.push_back(pClassInfo->getAdventurePrereqVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getEquipmentPromotionsVectorSize(); i++ )
	{
		m_aszEquipmentPromotionsforPass3.push_back(	pClassInfo->getEquipmentPromotionsNamesVectorElement(i));
		m_abEquipmentPromotionsforPass3.push_back(	pClassInfo->isEquipmentPromotionsValuesVectorElement(i));
	}
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	for ( int i = 0; i < pClassInfo->getCorporationSupportVectorSize(); i++ )
	{
		m_aszCorporationSupportforPass3.push_back(	pClassInfo->getCorporationSupportNamesVectorElement(i));
		m_aiCorporationSupportforPass3.push_back(	pClassInfo->getCorporationSupportValuesVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getCorporationSupportModVectorSize(); i++ )
	{
		m_aszCorporationSupportModforPass3.push_back(	pClassInfo->getCorporationSupportModNamesVectorElement(i));
		m_aiCorporationSupportModforPass3.push_back(	pClassInfo->getCorporationSupportModValuesVectorElement(i));
	}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

void CvPromotionInfo::copyNonDefaultsReadPass2(CvPromotionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getPrereqPromotion()		!= NO_PROMOTION)		m_iPrereqPromotion		= pClassInfo->getPrereqPromotion();
	if (bOver || pClassInfo->getPrereqOrPromotion1()	!= NO_PROMOTION)		m_iPrereqOrPromotion1	= pClassInfo->getPrereqOrPromotion1();
	if (bOver || pClassInfo->getPrereqOrPromotion2()	!= NO_PROMOTION)		m_iPrereqOrPromotion2	= pClassInfo->getPrereqOrPromotion2();
	if (bOver || pClassInfo->getPromotionCombatApply()	!= NO_PROMOTION)		m_iPromotionCombatApply = pClassInfo->getPromotionCombatApply();
	if (bOver || pClassInfo->getPromotionImmune1()		!= NO_PROMOTION)		m_iPromotionImmune1		= pClassInfo->getPromotionImmune1();
	if (bOver || pClassInfo->getPromotionImmune2()		!= NO_PROMOTION)		m_iPromotionImmune2		= pClassInfo->getPromotionImmune2();
	if (bOver || pClassInfo->getPromotionImmune3()		!= NO_PROMOTION)		m_iPromotionImmune3		= pClassInfo->getPromotionImmune3();
	if (bOver || pClassInfo->getPromotionRandomApply()	!= NO_PROMOTION)		m_iPromotionRandomApply	= pClassInfo->getPromotionRandomApply();
	if (bOver || pClassInfo->getPromotionSummonPerk()	!= NO_PROMOTION)		m_iPromotionSummonPerk	= pClassInfo->getPromotionSummonPerk();
	if (bOver || pClassInfo->getPromotionPrereqOr3()	!= NO_PROMOTION)		m_iPromotionPrereqOr3	= pClassInfo->getPromotionPrereqOr3();
	if (bOver || pClassInfo->getPromotionPrereqOr4()	!= NO_PROMOTION)		m_iPromotionPrereqOr4	= pClassInfo->getPromotionPrereqOr4();
	if (bOver || pClassInfo->getPromotionPrereqOr5()	!= NO_PROMOTION)		m_iPromotionPrereqOr5	= pClassInfo->getPromotionPrereqOr5();
	if (bOver || pClassInfo->getPromotionPrereqOr6()	!= NO_PROMOTION)		m_iPromotionPrereqOr6	= pClassInfo->getPromotionPrereqOr6();
	if (bOver || pClassInfo->getPromotionPrereqAnd()	!= NO_PROMOTION)		m_iPromotionPrereqAnd	= pClassInfo->getPromotionPrereqAnd();
	if (bOver || pClassInfo->getPromotionNextLevel()	!= NO_PROMOTION)		m_iPromotionNextLevel	= pClassInfo->getPromotionNextLevel();
	if (bOver || pClassInfo->getPromotionCombatType()	!= NO_PROMOTION)		m_iPromotionCombatType	= pClassInfo->getPromotionCombatType();
/*************************************************************************************************/
/**	ADDON (new Functions Definitions) Sephi					                     				**/
/*************************************************************************************************/

	if(pClassInfo->getNumPromotionExcludes() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionExcludes() : getNumPromotionExcludes() + pClassInfo->getNumPromotionExcludes();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionExcludes(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionExcludes(i);
		}
		if (!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionExcludes();
			for(int i = 0; i< getNumPromotionExcludes(); ++i)
			{
				tempArray[i+iOffset] = getPromotionExcludes(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionExcludes);
		m_piPromotionExcludes = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionExcludes[i] = tempArray[i];
			FAssertMsg(m_piPromotionExcludes[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionExcludes[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionExcludes = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
	if(pClassInfo->getNumPromotionReplacedBy() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionReplacedBy() : getNumPromotionReplacedBy() + pClassInfo->getNumPromotionReplacedBy();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionReplacedBy(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionReplacedBy(i);
		}
		if(!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionReplacedBy();
			for(int i = 0; i< getNumPromotionReplacedBy(); ++i)
			{
				tempArray[i+iOffset] = getPromotionReplacedBy(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionReplacedBy);
		m_piPromotionReplacedBy = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionReplacedBy[i] = tempArray[i];
			FAssertMsg(m_piPromotionReplacedBy[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionReplacedBy[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionReplacedBy = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}

	if(pClassInfo->getNumPromotionMustHave() > 0)
	{
		int iGoalSize = bOver ? pClassInfo->getNumPromotionMustHave() : getNumPromotionMustHave() + pClassInfo->getNumPromotionMustHave();
		int* tempArray = new int[iGoalSize];
		for(int i = 0; i < pClassInfo->getNumPromotionMustHave(); ++i)
		{
			tempArray[i] = pClassInfo->getPromotionMustHave(i);
		}
		if (!bOver)
		{
			int iOffset = pClassInfo->getNumPromotionMustHave();
			for(int i = 0; i< getNumPromotionMustHave(); ++i)
			{
				tempArray[i+iOffset] = getPromotionMustHave(i);
			}
		}
		SAFE_DELETE_ARRAY(m_piPromotionMustHave);
		m_piPromotionMustHave = new int[iGoalSize];
		for(int i = 0; i < iGoalSize; ++i)
		{
			m_piPromotionMustHave[i] = tempArray[i];
			FAssertMsg(m_piPromotionMustHave[i] < GC.getNumPromotionInfos() ,"Out of Bounds Array Melding");
			FAssertMsg(m_piPromotionMustHave[i] >= 0 ,"Out of Bounds Array Melding");
		}
		m_iNumPromotionMustHave = iGoalSize;
		SAFE_DELETE_ARRAY(tempArray);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//FfH Spell System: Added by Kael 07/23/2007
//======================================================================================================
//					CvSpellInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpellInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpellInfo::CvSpellInfo() :
m_iPromotionPrereq1(NO_PROMOTION),
m_iPromotionPrereq2(NO_PROMOTION),
m_iPromotionPrereq3(NO_PROMOTION),
m_iPromotionPrereq4(NO_PROMOTION),
m_iUnitPrereq(NO_UNIT),
m_iUnitCombatPrereq(NO_UNITCOMBAT),
m_iUnitClassPrereq(NO_UNITCLASS),
m_iUnitInStackPrereq(NO_UNIT),
m_iBuildingPrereq(NO_BUILDING),
m_iBuildingClassOwnedPrereq(NO_BUILDINGCLASS),
m_iCivilizationPrereq(NO_CIVILIZATION),
//>>>>BUGFfH: Added by Denev 2009/09/14
m_iTerrainOrPrereq1(NO_TERRAIN),
m_iTerrainOrPrereq2(NO_TERRAIN),
//<<<<BUGFfH: End Add
m_iCorporationPrereq(NO_CORPORATION),
m_iFeatureOrPrereq1(NO_FEATURE),
m_iFeatureOrPrereq2(NO_FEATURE),
m_iImprovementPrereq(NO_IMPROVEMENT),
m_iPromotionInStackPrereq(NO_PROMOTION),
m_iReligionPrereq(NO_RELIGION),
m_iStateReligionPrereq(NO_RELIGION),
m_iTechPrereq(NO_TECH),
m_bAllowAI(false),
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/*************************************************************************************************/
m_bAllowAuto(false),
m_bExploreDungeon(false),
m_bNoDisplay(false),
m_iFaithCost(0),
m_iManaCost(0),
m_iPrereqAlignment(NO_ALIGNMENT),
m_bTargetedHostile(false),
m_bBombard(false),
m_bFlameFeatures(false),
m_bHighCrit(false),
m_bManaCostReductionBonus(false),
m_bThiefMission(false),
m_iThiefDifficulty(0),
m_iThiefExperienceChange(0),
m_iNumTargets(-1),
m_iTriggerSecondaryPlotChance(0),
m_iForcedTeleport(0),
m_iReduceDurability(0),
m_iDestroyEnemyEquipment(0),
m_iDoT(NO_PROMOTION),
m_iDamageSpellPrereqPromotion(NO_PROMOTION),
m_iDamageSpellPrereqUnitCombat(NO_PROMOTION),
m_iUnitCombatCapture(NO_UNITCOMBAT),
m_pbObsoletedBySpell(NULL),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
m_bAdjacentToWaterOnly(false),
m_bCasterMustBeAlive(false),
m_bCasterNoDuration(false),
m_bCausesWar(false),
m_bGlobal(false),
m_bInBordersOnly(false),
m_bInCityOnly(false),
m_bPrereqSlaveTrade(false),
m_bResistable(false),
m_iAIWeight(0),
m_iAIWeightCity(0),
m_iAIWeightWar(0),
m_iCasterMinLevel(0),
m_iHeal(0),
m_bDisplayWhenDisabled(false),
m_bHasCasted(false),
m_bIgnoreHasCasted(false),
m_iDamage(0),
m_iDamageLimit(0),
m_iDamageType(NO_DAMAGE),
m_iRange(0),
m_iResistModify(0),
m_iAddPromotionType1(NO_PROMOTION),
m_iAddPromotionType2(NO_PROMOTION),
m_iAddPromotionType3(NO_PROMOTION),
m_iAddPromotionType4(NO_PROMOTION),
m_iAddPromotionType5(NO_PROMOTION),
m_iRemovePromotionType1(NO_PROMOTION),
m_iRemovePromotionType2(NO_PROMOTION),
m_iRemovePromotionType3(NO_PROMOTION),
m_bBuffCasterOnly(false),
m_iConvertUnitType(NO_UNIT),
m_iCreateBuildingType(NO_BUILDING),
m_iCreateBuildingType1(NO_BUILDING),
m_iCreateBuildingType2(NO_BUILDING),
m_iRemoveBuildingType(NO_BUILDING),
m_iCreateFeatureType(NO_FEATURE),
m_iCreateImprovementType(NO_IMPROVEMENT),
m_iSpreadReligion(NO_RELIGION),
m_iCreateUnitType(NO_UNIT),
m_iCreateUnitNum(0),
m_bCopyCastersPromotions(false),
m_bPermanentUnitCreate(false),
m_iCreateUnitPromotion(NO_PROMOTION),
m_bImmuneTeam(false),
m_bImmuneNeutral(false),
m_bImmuneEnemy(false),
m_bImmuneFlying(false),
m_bImmuneNotAlive(false),
m_bAbility(false),
m_bDispel(false),
m_bPush(false),
m_bRemoveHasCasted(false),
m_bSacrificeCaster(false),
m_iChangePopulation(0),
m_iCost(0),
m_iDelay(0),
m_iImmobileTurns(0),
m_bDomination(0),
m_iMiscastChance(0),
m_iEffect(NO_EFFECT),
m_szSound(NULL),
m_iCommandType(NO_COMMAND),
//>>>>Spell Interrupt Unit Cycling: Added by Denev 2009/10/17
m_bNoInterruptUnitCycling(false),
//<<<<Spell Interrupt Unit Cycling: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
 m_paiCorporationSupport(NULL),
 m_paiCorporationSupportMod(NULL)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpellInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpellInfo::~CvSpellInfo()
{
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_pbObsoletedBySpell);
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

int CvSpellInfo::getPromotionPrereq1() const
{
	return m_iPromotionPrereq1;
}

int CvSpellInfo::getPromotionPrereq2() const
{
	return m_iPromotionPrereq2;
}

int CvSpellInfo::getPromotionPrereq3() const
{
	return m_iPromotionPrereq3;
}

int CvSpellInfo::getPromotionPrereq4() const
{
	return m_iPromotionPrereq4;
}

int CvSpellInfo::getUnitPrereq() const
{
	return m_iUnitPrereq;
}

int CvSpellInfo::getUnitCombatPrereq() const
{
	return m_iUnitCombatPrereq;
}

int CvSpellInfo::getUnitClassPrereq() const
{
	return m_iUnitClassPrereq;
}

int CvSpellInfo::getUnitInStackPrereq() const
{
	return m_iUnitInStackPrereq;
}

int CvSpellInfo::getBuildingPrereq() const
{
	return m_iBuildingPrereq;
}

int CvSpellInfo::getBuildingClassOwnedPrereq() const
{
	return m_iBuildingClassOwnedPrereq;
}

int CvSpellInfo::getCivilizationPrereq() const
{
	return m_iCivilizationPrereq;
}

int CvSpellInfo::getCorporationPrereq() const
{
	return m_iCorporationPrereq;
}

int CvSpellInfo::getFeatureOrPrereq1() const
{
	return m_iFeatureOrPrereq1;
}

int CvSpellInfo::getFeatureOrPrereq2() const
{
	return m_iFeatureOrPrereq2;
}

int CvSpellInfo::getImprovementPrereq() const
{
	return m_iImprovementPrereq;
}

int CvSpellInfo::getPromotionInStackPrereq() const
{
	return m_iPromotionInStackPrereq;
}

int CvSpellInfo::getReligionPrereq() const
{
	return m_iReligionPrereq;
}

int CvSpellInfo::getStateReligionPrereq() const
{
	return m_iStateReligionPrereq;
}

int CvSpellInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvSpellInfo::getRange() const
{
	return m_iRange;
}

int CvSpellInfo::getEffect() const
{
	return m_iEffect;
}

const TCHAR *CvSpellInfo::getSound() const
{
	return m_szSound;
}

bool CvSpellInfo::isAllowAI() const
{
	return m_bAllowAI;
}

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
bool CvSpellInfo::isAllowAuto() const
{
    return m_bAllowAuto;
}

bool CvSpellInfo::isHighCrit() const
{
    return m_bHighCrit;
}

bool CvSpellInfo::isManaCostReductionBonus() const
{
    return m_bManaCostReductionBonus;
}

bool CvSpellInfo::isThiefMission() const
{
    return m_bThiefMission;
}

int CvSpellInfo::getThiefDifficulty() const
{
    return m_iThiefDifficulty;
}

int CvSpellInfo::getThiefExperienceChange() const
{
    return m_iThiefExperienceChange;
}

int CvSpellInfo::getFaithCost() const
{
    return m_iFaithCost;
}

int CvSpellInfo::getManaCost() const
{
    return m_iManaCost;
}

int CvSpellInfo::getPrereqAlignment() const
{
    return m_iPrereqAlignment;
}

int CvSpellInfo::getNumTargets() const
{
    return m_iNumTargets;
}

int CvSpellInfo::getTriggerSecondaryPlotChance() const
{
    return m_iTriggerSecondaryPlotChance;
}

int CvSpellInfo::getDoT() const
{
    return m_iDoT;
}

int CvSpellInfo::getForcedTeleport() const
{
    return m_iForcedTeleport;
}

int CvSpellInfo::getReduceDurability() const
{
    return m_iReduceDurability;
}

int CvSpellInfo::getDestroyEnemyEquipment() const
{
    return m_iDestroyEnemyEquipment;
}

int CvSpellInfo::getDamageSpellPrereqPromotion() const
{
    return m_iDamageSpellPrereqPromotion;
}

int CvSpellInfo::getDamageSpellPrereqUnitCombat() const
{
    return m_iDamageSpellPrereqUnitCombat;
}

int CvSpellInfo::getUnitCombatCapture() const
{
    return m_iUnitCombatCapture;
}

bool CvSpellInfo::isTargetedHostile() const
{
	return m_bTargetedHostile;
}

bool CvSpellInfo::isBombard() const
{
	return m_bBombard;
}

bool CvSpellInfo::isFlameFeatures() const
{
	return m_bFlameFeatures;
}

bool CvSpellInfo::isExploreDungeon() const
{
	return m_bExploreDungeon;
}

bool CvSpellInfo::isNoDisplay() const
{
	return m_bNoDisplay;
}

bool CvSpellInfo::isObsoletedBySpell(int iSpell) const
{
	return m_pbObsoletedBySpell ? m_pbObsoletedBySpell[iSpell] : false;
}

bool CvSpellInfo::isSpellObsoleted(CvUnit* pCaster, int iSpellType) const
{
    for (int iI=0;iI<GC.getNumSpellInfos();iI++)
    {
        if (isObsoletedBySpell(iI))
        {
			TechTypes iPrereqTech=(TechTypes)GC.getSpellInfo((SpellTypes)iI).getTechPrereq();
			if (iPrereqTech==NO_TECH || GET_TEAM(pCaster->getTeam()).isHasTech(iPrereqTech))
			{
				PromotionTypes iPrereqPromotion1=(PromotionTypes)GC.getSpellInfo((SpellTypes)iI).getPromotionPrereq1();
				PromotionTypes iPrereqPromotion2=(PromotionTypes)GC.getSpellInfo((SpellTypes)iI).getPromotionPrereq2();
				if(iPrereqPromotion1==NO_PROMOTION || pCaster->isHasPromotion(iPrereqPromotion1))
				{
					if(iPrereqPromotion2==NO_PROMOTION || pCaster->isHasPromotion(iPrereqPromotion2))
					{
						return true;
					}
				}
			}
		}
    }

    return false;
}

int CvSpellInfo::getObsoletedBySpellVectorSize()					{return m_aszObsoletedBySpellforPass3.size();}
CvString CvSpellInfo::getObsoletedBySpellNamesVectorElement(int i)	{return m_aszObsoletedBySpellforPass3[i];}
bool CvSpellInfo::getObsoletedBySpellValuesVectorElement(int i)		{return m_abObsoletedBySpellforPass3[i];}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

bool CvSpellInfo::isAdjacentToWaterOnly() const
{
	return m_bAdjacentToWaterOnly;
}

bool CvSpellInfo::isCasterMustBeAlive() const
{
	return m_bCasterMustBeAlive;
}

bool CvSpellInfo::isCasterNoDuration() const
{
	return m_bCasterNoDuration;
}

bool CvSpellInfo::isCausesWar() const
{
	return m_bCausesWar;
}

bool CvSpellInfo::isGlobal() const
{
	return m_bGlobal;
}

bool CvSpellInfo::isInBordersOnly() const
{
	return m_bInBordersOnly;
}

bool CvSpellInfo::isInCityOnly() const
{
	return m_bInCityOnly;
}

bool CvSpellInfo::isPrereqSlaveTrade() const
{
	return m_bPrereqSlaveTrade;
}

bool CvSpellInfo::isBuffCasterOnly() const
{
	return m_bBuffCasterOnly;
}

bool CvSpellInfo::isCopyCastersPromotions() const
{
	return m_bCopyCastersPromotions;
}

bool CvSpellInfo::isAbility() const
{
	return m_bAbility;
}

bool CvSpellInfo::isDispel() const
{
	return m_bDispel;
}

bool CvSpellInfo::isDisplayWhenDisabled() const
{
	return m_bDisplayWhenDisabled;
}

bool CvSpellInfo::isHasCasted() const
{
	return m_bHasCasted;
}

bool CvSpellInfo::isIgnoreHasCasted() const
{
	return m_bIgnoreHasCasted;
}

bool CvSpellInfo::isImmuneTeam() const
{
	return m_bImmuneTeam;
}

bool CvSpellInfo::isImmuneNeutral() const
{
	return m_bImmuneNeutral;
}

bool CvSpellInfo::isImmuneEnemy() const
{
	return m_bImmuneEnemy;
}

bool CvSpellInfo::isImmuneFlying() const
{
	return m_bImmuneFlying;
}

bool CvSpellInfo::isImmuneNotAlive() const
{
	return m_bImmuneNotAlive;
}

bool CvSpellInfo::isPermanentUnitCreate() const
{
	return m_bPermanentUnitCreate;
}

bool CvSpellInfo::isPush() const
{
	return m_bPush;
}

bool CvSpellInfo::isRemoveHasCasted() const
{
	return m_bRemoveHasCasted;
}

bool CvSpellInfo::isResistable() const
{
	return m_bResistable;
}

bool CvSpellInfo::isSacrificeCaster() const
{
	return m_bSacrificeCaster;
}

int CvSpellInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvSpellInfo::getAIWeightCity() const
{
	return m_iAIWeightCity;
}

int CvSpellInfo::getAIWeightWar() const
{
	return m_iAIWeightWar;
}

int CvSpellInfo::getCasterMinLevel() const
{
	return m_iCasterMinLevel;
}

int CvSpellInfo::getHeal() const
{
	return m_iHeal;
}

int CvSpellInfo::getChangePopulation() const
{
	return m_iChangePopulation;
}

int CvSpellInfo::getCost() const
{
	return m_iCost;
}

int CvSpellInfo::getDamage() const
{
	return m_iDamage;
}

int CvSpellInfo::getDamageLimit() const
{
	return m_iDamageLimit;
}

int CvSpellInfo::getDamageType() const
{
	return m_iDamageType;
}

int CvSpellInfo::getCreateUnitNum() const
{
	return m_iCreateUnitNum;
}

int CvSpellInfo::getAddPromotionType1() const
{
	return m_iAddPromotionType1;
}

int CvSpellInfo::getAddPromotionType2() const
{
	return m_iAddPromotionType2;
}

int CvSpellInfo::getAddPromotionType3() const
{
	return m_iAddPromotionType3;
}

int CvSpellInfo::getAddPromotionType4() const
{
	return m_iAddPromotionType4;
}

int CvSpellInfo::getAddPromotionType5() const
{
	return m_iAddPromotionType5;
}

int CvSpellInfo::getConvertUnitType() const
{
	return m_iConvertUnitType;
}

int CvSpellInfo::getCreateBuildingType() const
{
	return m_iCreateBuildingType;
}

int CvSpellInfo::getRemoveBuildingType() const
{
	return m_iRemoveBuildingType;
}

int CvSpellInfo::getCreateBuildingType1() const
{
	return m_iCreateBuildingType1;
}

int CvSpellInfo::getCreateBuildingType2() const
{
	return m_iCreateBuildingType2;
}

int CvSpellInfo::getCreateFeatureType() const
{
	return m_iCreateFeatureType;
}

int CvSpellInfo::getCreateImprovementType() const
{
	return m_iCreateImprovementType;
}

int CvSpellInfo::getSpreadReligion() const
{
	return m_iSpreadReligion;
}

int CvSpellInfo::getDelay() const
{
	return m_iDelay;
}

int CvSpellInfo::getImmobileTurns() const
{
	return m_iImmobileTurns;
}

int CvSpellInfo::isDomination() const
{
	return m_bDomination;
}

int CvSpellInfo::getMiscastChance() const
{
	return m_iMiscastChance;
}

int CvSpellInfo::getRemovePromotionType1() const
{
	return m_iRemovePromotionType1;
}

int CvSpellInfo::getRemovePromotionType2() const
{
	return m_iRemovePromotionType2;
}

int CvSpellInfo::getRemovePromotionType3() const
{
	return m_iRemovePromotionType3;
}

int CvSpellInfo::getResistModify() const
{
	return m_iResistModify;
}

int CvSpellInfo::getCreateUnitType() const
{
	return m_iCreateUnitType;
}

int CvSpellInfo::getCreateUnitPromotion() const
{
	return m_iCreateUnitPromotion;
}

const TCHAR *CvSpellInfo::getPyMiscast() const
{
	return m_szPyMiscast;
}

const TCHAR *CvSpellInfo::getPyResult() const
{
	return m_szPyResult;
}

const TCHAR *CvSpellInfo::getPyRequirement() const
{
	return m_szPyRequirement;
}

int CvSpellInfo::getCommandType() const
{
	return m_iCommandType;
}

void CvSpellInfo::setCommandType(int iNewType)
{
	m_iCommandType = iNewType;
}
//>>>>Spell Interrupt Unit Cycling: Added by Denev 2009/10/17
bool CvSpellInfo::isNoInterruptUnitCycling() const
{
	return m_bNoInterruptUnitCycling;
}
//<<<<Spell Interrupt Unit Cycling: End Add

//>>>>BUGFfH: Added by Denev 2009/09/14
int CvSpellInfo::getTerrainOrPrereq1() const
{
	return m_iTerrainOrPrereq1;
}

int CvSpellInfo::getTerrainOrPrereq2() const
{
	return m_iTerrainOrPrereq2;
}

const TCHAR *CvSpellInfo::getPyResultSecondary() const
{
	return m_szPyResultSecondary;
}

//<<<<BUGFfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvSpellInfo::getCorporationSupport(int iCorporation) const
{
	return m_paiCorporationSupport[iCorporation];
}

int CvSpellInfo::getCorporationSupportMultiplier(int iCorporation) const
{
	return m_paiCorporationSupportMod[iCorporation];
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/


void CvSpellInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iPromotionPrereq1);
	stream->Read(&m_iPromotionPrereq2);
	stream->Read(&m_iPromotionPrereq3);
	stream->Read(&m_iPromotionPrereq4);
	stream->Read(&m_iUnitPrereq);
	stream->Read(&m_iUnitCombatPrereq);
	stream->Read(&m_iUnitClassPrereq);
	stream->Read(&m_iUnitInStackPrereq);
	stream->Read(&m_iBuildingPrereq);
	stream->Read(&m_iBuildingClassOwnedPrereq);
	stream->Read(&m_iCivilizationPrereq);
	stream->Read(&m_iCorporationPrereq);
	stream->Read(&m_iFeatureOrPrereq1);
	stream->Read(&m_iFeatureOrPrereq2);
	stream->Read(&m_iImprovementPrereq);
	stream->Read(&m_iPromotionInStackPrereq);
	stream->Read(&m_iReligionPrereq);
	stream->Read(&m_iStateReligionPrereq);
	stream->Read(&m_iTechPrereq);
	stream->Read(&m_bAllowAI);
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Read(&m_bAllowAuto);
	stream->Read(&m_iFaithCost);
	stream->Read(&m_iManaCost);
	stream->Read(&m_iPrereqAlignment);
/**
	SAFE_DELETE_ARRAY(m_pbObsoletedBySpell);
	m_pbObsoletedBySpell = new bool[GC.getNumSpellInfos()];
	stream->Read(GC.getNumSpellInfos(), m_pbObsoletedBySpell);**/
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	stream->Read(&m_bAdjacentToWaterOnly);
	stream->Read(&m_bCasterMustBeAlive);
	stream->Read(&m_bCasterNoDuration);
	stream->Read(&m_bCausesWar);
	stream->Read(&m_bGlobal);
	stream->Read(&m_bInBordersOnly);
	stream->Read(&m_bInCityOnly);
	stream->Read(&m_bPrereqSlaveTrade);
	stream->Read(&m_bResistable);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iAIWeightCity);
	stream->Read(&m_iAIWeightWar);
	stream->Read(&m_iCasterMinLevel);
	stream->Read(&m_bDisplayWhenDisabled);
	stream->Read(&m_bHasCasted);
	stream->Read(&m_bIgnoreHasCasted);
	stream->Read(&m_iRange);
	stream->Read(&m_iResistModify);
	stream->Read(&m_iDamage);
	stream->Read(&m_iDamageLimit);
	stream->Read(&m_iDamageType);
	stream->Read(&m_iAddPromotionType1);
	stream->Read(&m_iAddPromotionType2);
	stream->Read(&m_iAddPromotionType3);
	stream->Read(&m_iAddPromotionType4);
	stream->Read(&m_iAddPromotionType5);
	stream->Read(&m_iRemovePromotionType1);
	stream->Read(&m_iRemovePromotionType2);
	stream->Read(&m_iRemovePromotionType3);
	stream->Read(&m_bBuffCasterOnly);
	stream->Read(&m_iConvertUnitType);
	stream->Read(&m_iCreateBuildingType);
	stream->Read(&m_iCreateBuildingType1);
	stream->Read(&m_iCreateBuildingType2);
	stream->Read(&m_iRemoveBuildingType);
	stream->Read(&m_iCreateFeatureType);
	stream->Read(&m_iCreateImprovementType);
	stream->Read(&m_iSpreadReligion);
	stream->Read(&m_iCreateUnitType);
	stream->Read(&m_iCreateUnitNum);
	stream->Read(&m_bCopyCastersPromotions);
	stream->Read(&m_bPermanentUnitCreate);
	stream->Read(&m_iCreateUnitPromotion);
	stream->Read(&m_bImmuneTeam);
	stream->Read(&m_bImmuneNeutral);
	stream->Read(&m_bImmuneEnemy);
	stream->Read(&m_bImmuneFlying);
	stream->Read(&m_bImmuneNotAlive);
	stream->Read(&m_bAbility);
	stream->Read(&m_bDispel);
	stream->Read(&m_bPush);
	stream->Read(&m_bRemoveHasCasted);
	stream->Read(&m_bSacrificeCaster);
	stream->Read(&m_iChangePopulation);
	stream->Read(&m_iCost);
	stream->Read(&m_iDelay);
	stream->Read(&m_iImmobileTurns);
	stream->Read(&m_iMiscastChance);
	stream->ReadString(m_szPyMiscast);
	stream->ReadString(m_szPyResult);
	stream->ReadString(m_szPyRequirement);
	stream->Read(&m_iEffect);
	stream->ReadString(m_szSound);
	stream->Read(&m_iCommandType);
//>>>>BUGFfH: Added by Denev 2009/09/14
	stream->Read(&m_iTerrainOrPrereq1);
	stream->Read(&m_iTerrainOrPrereq2);
	stream->ReadString(m_szPyResultSecondary);
//<<<<BUGFfH: End Add
//>>>>Spell Interrupt Unit Cycling: Added by Denev 2009/10/17
	stream->Read(&m_bNoInterruptUnitCycling);
//<<<<Spell Interrupt Unit Cycling: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupport);

	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

void CvSpellInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iPromotionPrereq1);
	stream->Write(m_iPromotionPrereq2);
	stream->Write(m_iPromotionPrereq3);
	stream->Write(m_iPromotionPrereq4);
	stream->Write(m_iUnitPrereq);
	stream->Write(m_iUnitCombatPrereq);
	stream->Write(m_iUnitClassPrereq);
	stream->Write(m_iUnitInStackPrereq);
	stream->Write(m_iBuildingPrereq);
	stream->Write(m_iBuildingClassOwnedPrereq);
	stream->Write(m_iCivilizationPrereq);
	stream->Write(m_iCorporationPrereq);
	stream->Write(m_iFeatureOrPrereq1);
	stream->Write(m_iFeatureOrPrereq2);
	stream->Write(m_iImprovementPrereq);
	stream->Write(m_iPromotionInStackPrereq);
	stream->Write(m_iReligionPrereq);
	stream->Write(m_iStateReligionPrereq);
	stream->Write(m_iTechPrereq);
	stream->Write(m_bAllowAI);
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Write(m_bAllowAuto);
	stream->Write(m_iFaithCost);
	stream->Write(m_iManaCost);
	stream->Write(m_iPrereqAlignment);
/**	stream->Write(GC.getNumSpellInfos(), m_pbObsoletedBySpell);**/
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	stream->Write(m_bAdjacentToWaterOnly);
	stream->Write(m_bCasterMustBeAlive);
	stream->Write(m_bCasterNoDuration);
	stream->Write(m_bCausesWar);
	stream->Write(m_bGlobal);
	stream->Write(m_bInBordersOnly);
	stream->Write(m_bInCityOnly);
	stream->Write(m_bPrereqSlaveTrade);
	stream->Write(m_bResistable);
	stream->Write(m_iAIWeight);
	stream->Write(m_iAIWeightCity);
	stream->Write(m_iAIWeightWar);
	stream->Write(m_iCasterMinLevel);
	stream->Write(m_bDisplayWhenDisabled);
	stream->Write(m_bHasCasted);
	stream->Write(m_bIgnoreHasCasted);
	stream->Write(m_iRange);
	stream->Write(m_iResistModify);
	stream->Write(m_iDamage);
	stream->Write(m_iDamageLimit);
	stream->Write(m_iDamageType);
	stream->Write(m_iAddPromotionType1);
	stream->Write(m_iAddPromotionType2);
	stream->Write(m_iAddPromotionType3);
	stream->Write(m_iAddPromotionType4);
	stream->Write(m_iAddPromotionType5);
	stream->Write(m_iRemovePromotionType1);
	stream->Write(m_iRemovePromotionType2);
	stream->Write(m_iRemovePromotionType3);
	stream->Write(m_bBuffCasterOnly);
	stream->Write(m_iConvertUnitType);
	stream->Write(m_iCreateBuildingType);
	stream->Write(m_iCreateBuildingType1);
	stream->Write(m_iCreateBuildingType2);
	stream->Write(m_iRemoveBuildingType);
	stream->Write(m_iCreateFeatureType);
	stream->Write(m_iCreateImprovementType);
	stream->Write(m_iSpreadReligion);
	stream->Write(m_iCreateUnitType);
	stream->Write(m_iCreateUnitNum);
	stream->Write(m_bCopyCastersPromotions);
	stream->Write(m_bPermanentUnitCreate);
	stream->Write(m_iCreateUnitPromotion);
	stream->Write(m_bImmuneTeam);
	stream->Write(m_bImmuneNeutral);
	stream->Write(m_bImmuneEnemy);
	stream->Write(m_bImmuneFlying);
	stream->Write(m_bImmuneNotAlive);
	stream->Write(m_bAbility);
	stream->Write(m_bDispel);
	stream->Write(m_bPush);
	stream->Write(m_bRemoveHasCasted);
	stream->Write(m_bSacrificeCaster);
	stream->Write(m_iChangePopulation);
	stream->Write(m_iCost);
	stream->Write(m_iDelay);
	stream->Write(m_iImmobileTurns);
	stream->Write(m_iMiscastChance);
	stream->WriteString(m_szPyMiscast);
	stream->WriteString(m_szPyResult);
	stream->WriteString(m_szPyRequirement);
	stream->Write(m_iEffect);
	stream->WriteString(m_szSound);
	stream->Write(m_iCommandType);
//>>>>BUGFfH: Added by Denev 2009/09/14
	stream->Write(m_iTerrainOrPrereq1);
	stream->Write(m_iTerrainOrPrereq2);
	stream->WriteString(m_szPyResultSecondary);
//<<<<BUGFfH: End Add
//>>>>Spell Interrupt Unit Cycling: Added by Denev 2009/10/17
	stream->Write(m_bNoInterruptUnitCycling);
//<<<<Spell Interrupt Unit Cycling: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupport);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

bool CvSpellInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq1");
	if (szTextVal != "") m_iPromotionPrereq1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq2");
	if (szTextVal != "") m_iPromotionPrereq2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq3");
	if (szTextVal != "") m_iPromotionPrereq3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionPrereq4");
	if (szTextVal != "") m_iPromotionPrereq4 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitPrereq");
	if (szTextVal != "") m_iUnitPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitCombatPrereq");
	if (szTextVal != "") m_iUnitCombatPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitClassPrereq");
	if (szTextVal != "") m_iUnitClassPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitInStackPrereq");
	if (szTextVal != "") m_iUnitInStackPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BuildingPrereq");
	if (szTextVal != "") m_iBuildingPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BuildingClassOwnedPrereq");
	if (szTextVal != "") m_iBuildingClassOwnedPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CivilizationPrereq");
	if (szTextVal != "") m_iCivilizationPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CorporationPrereq");
	if (szTextVal != "") m_iCorporationPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureOrPrereq1");
	if (szTextVal != "") m_iFeatureOrPrereq1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureOrPrereq2");
	if (szTextVal != "") m_iFeatureOrPrereq2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ImprovementPrereq");
	if (szTextVal != "") m_iImprovementPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionInStackPrereq");
	if (szTextVal != "") m_iPromotionInStackPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ReligionPrereq");
	if (szTextVal != "") m_iReligionPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "StateReligionPrereq");
	if (szTextVal != "") m_iStateReligionPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	if (szTextVal != "") m_iTechPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bAllowAI, "bAllowAI");
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    pXML->GetChildXmlValByName(&m_bAllowAuto, "bAllowAuto",false);
    pXML->GetChildXmlValByName(&m_bExploreDungeon, "bExploreDungeon",false);
    pXML->GetChildXmlValByName(&m_bNoDisplay, "bNoDisplay",false);
    pXML->GetChildXmlValByName(&m_iFaithCost, "iFaithCost",0);
    pXML->GetChildXmlValByName(&m_iManaCost, "iManaCost",0);
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment", "NONE");
	if (szTextVal != "") m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iInterfaceMode, "iInterfaceMode",-1);
    pXML->GetChildXmlValByName(&m_bTargetedHostile, "bTargetedHostile",false);
    pXML->GetChildXmlValByName(&m_bBombard, "bBombard",false);
    pXML->GetChildXmlValByName(&m_bFlameFeatures, "bFlameFeatures",false);
    pXML->GetChildXmlValByName(&m_bHighCrit, "bHighCrit",false);
    pXML->GetChildXmlValByName(&m_bManaCostReductionBonus, "bManaCostReductionBonus",false);
    pXML->GetChildXmlValByName(&m_bThiefMission, "bThiefMission",false);
    pXML->GetChildXmlValByName(&m_iThiefDifficulty, "iThiefDifficulty", 0);
    pXML->GetChildXmlValByName(&m_iThiefExperienceChange, "iThiefExperienceChange", 0);
    pXML->GetChildXmlValByName(&m_iNumTargets, "iNumTargets",-1);
    pXML->GetChildXmlValByName(&m_iTriggerSecondaryPlotChance, "iTriggerSecondaryPlotChance");
    pXML->GetChildXmlValByName(&m_iForcedTeleport, "iForcedTeleport");
    pXML->GetChildXmlValByName(&m_iReduceDurability, "iReduceDurability");
    pXML->GetChildXmlValByName(&m_iDestroyEnemyEquipment, "iDestroyEnemyEquipment");
	pXML->GetChildXmlValByName(szTextVal, "DoTPromotion", "NONE");
	if (szTextVal != "") m_iDoT = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DamageSpellPrereqPromotion", "NONE");
	if (szTextVal != "") m_iDamageSpellPrereqPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DamageSpellPrereqUnitCombat", "NONE");
	if (szTextVal != "") m_iDamageSpellPrereqUnitCombat = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitCombatCapture", "NONE");
	if (szTextVal != "") m_iUnitCombatCapture = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bAdjacentToWaterOnly, "bAdjacentToWaterOnly");
	pXML->GetChildXmlValByName(&m_bCasterMustBeAlive, "bCasterMustBeAlive");
	pXML->GetChildXmlValByName(&m_bCasterNoDuration, "bCasterNoDuration");
	pXML->GetChildXmlValByName(&m_bCausesWar, "bCausesWar");
	pXML->GetChildXmlValByName(&m_bGlobal, "bGlobal");
	pXML->GetChildXmlValByName(&m_bInBordersOnly, "bInBordersOnly");
	pXML->GetChildXmlValByName(&m_bInCityOnly, "bInCityOnly");
	pXML->GetChildXmlValByName(&m_bPrereqSlaveTrade, "bPrereqSlaveTrade");
	pXML->GetChildXmlValByName(&m_bResistable, "bResistable");
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iAIWeightCity, "iAIWeightCity");
	pXML->GetChildXmlValByName(&m_iAIWeightWar, "iAIWeightWar");
	pXML->GetChildXmlValByName(&m_iCasterMinLevel, "iCasterMinLevel");
	pXML->GetChildXmlValByName(&m_iHeal, "iHeal");
	pXML->GetChildXmlValByName(&m_bDisplayWhenDisabled, "bDisplayWhenDisabled");
	pXML->GetChildXmlValByName(&m_bHasCasted, "bHasCasted");
	pXML->GetChildXmlValByName(&m_bIgnoreHasCasted, "bIgnoreHasCasted");
	pXML->GetChildXmlValByName(&m_iRange, "iRange");
	pXML->GetChildXmlValByName(&m_iResistModify, "iResistModify");

	pXML->GetChildXmlValByName(&m_iDamage, "iDamage");
	pXML->GetChildXmlValByName(&m_iDamageLimit, "iDamageLimit");
	pXML->GetChildXmlValByName(szTextVal, "DamageType");
	if (szTextVal != "") m_iDamageType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType1");
	if (szTextVal != "") m_iAddPromotionType1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType2");
	if (szTextVal != "") m_iAddPromotionType2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType3");
	if (szTextVal != "") m_iAddPromotionType3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType4");
	if (szTextVal != "") m_iAddPromotionType4 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AddPromotionType5");
	if (szTextVal != "") m_iAddPromotionType5 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotionType1");
	if (szTextVal != "") m_iRemovePromotionType1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotionType2");
	if (szTextVal != "") m_iRemovePromotionType2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotionType3");
	if (szTextVal != "") m_iRemovePromotionType3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bBuffCasterOnly, "bBuffCasterOnly");

	pXML->GetChildXmlValByName(szTextVal, "ConvertUnitType");
	if (szTextVal != "") m_iConvertUnitType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateBuildingType");
	if (szTextVal != "") m_iCreateBuildingType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateBuildingType1");
	if (szTextVal != "") m_iCreateBuildingType1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateBuildingType2");
	if (szTextVal != "") m_iCreateBuildingType2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemoveBuildingType");
	if (szTextVal != "") m_iRemoveBuildingType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateFeatureType");
	if (szTextVal != "") m_iCreateFeatureType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "CreateImprovementType");
	if (szTextVal != "") m_iCreateImprovementType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "SpreadReligion");
	if (szTextVal != "") m_iSpreadReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "CreateUnitType");
	if (szTextVal != "") m_iCreateUnitType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iCreateUnitNum, "iCreateUnitNum");
	pXML->GetChildXmlValByName(&m_bCopyCastersPromotions, "bCopyCastersPromotions");
	pXML->GetChildXmlValByName(&m_bPermanentUnitCreate, "bPermanentUnitCreate");
	pXML->GetChildXmlValByName(szTextVal, "CreateUnitPromotion");
	if (szTextVal != "") m_iCreateUnitPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bImmuneTeam, "bImmuneTeam");
	pXML->GetChildXmlValByName(&m_bImmuneNeutral, "bImmuneNeutral");
	pXML->GetChildXmlValByName(&m_bImmuneEnemy, "bImmuneEnemy");
	pXML->GetChildXmlValByName(&m_bImmuneFlying, "bImmuneFlying");
	pXML->GetChildXmlValByName(&m_bImmuneNotAlive, "bImmuneNotAlive");
	pXML->GetChildXmlValByName(&m_bAbility, "bAbility");
	pXML->GetChildXmlValByName(&m_bDispel, "bDispel");
	pXML->GetChildXmlValByName(&m_bPush, "bPush");
	pXML->GetChildXmlValByName(&m_bRemoveHasCasted, "bRemoveHasCasted");
	pXML->GetChildXmlValByName(&m_bSacrificeCaster, "bSacrificeCaster");
	pXML->GetChildXmlValByName(&m_iChangePopulation, "iChangePopulation");
	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_iDelay, "iDelay");
	pXML->GetChildXmlValByName(&m_iImmobileTurns, "iImmobileTurns");
	pXML->GetChildXmlValByName(&m_bDomination, "bDomination");
	pXML->GetChildXmlValByName(&m_iMiscastChance, "iMiscastChance");

	pXML->GetChildXmlValByName(m_szPyMiscast, "PyMiscast");
	pXML->GetChildXmlValByName(m_szPyResult, "PyResult");
	pXML->GetChildXmlValByName(m_szPyRequirement, "PyRequirement");
	pXML->GetChildXmlValByName(szTextVal, "Effect");
	if (szTextVal != "") m_iEffect = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(m_szSound, "Sound");
//>>>>BUGFfH: Added by Denev 2009/09/14
	pXML->GetChildXmlValByName(szTextVal, "TerrainOrPrereq1");
	if (szTextVal != "") m_iTerrainOrPrereq1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainOrPrereq2");
	if (szTextVal != "") m_iTerrainOrPrereq2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(m_szPyResultSecondary, "PyResultSecondary");

//<<<<BUGFfH: End Add
//>>>>Spell Interrupt Unit Cycling: Added by Denev 2009/10/17
	pXML->GetChildXmlValByName(&m_bNoInterruptUnitCycling, "bNoInterruptUnitCycling",true);
//<<<<Spell Interrupt Unit Cycling: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_paiCorporationSupport, "CorporationSupportValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
	pXML->SetVariableListTagPair(&m_paiCorporationSupportMod, "CorporationSupportModifierValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (New Definitions / readpass3) Sephi			                                 					**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ObsoletedBySpells"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			bool bTemp = false;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszObsoletedBySpellforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&bTemp);
                            m_abObsoletedBySpellforPass3.push_back(bTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}
//FfH: End Add

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/*************************************************************************************************/
bool CvSpellInfo::readPass3()
{
    m_pbObsoletedBySpell = new bool[GC.getNumSpellInfos()];
    for (int iI = 0; iI < GC.getNumSpellInfos(); iI++)
	{
        m_pbObsoletedBySpell[iI] = false;
	}
    int iNumLoad = m_abObsoletedBySpellforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszObsoletedBySpellforPass3[iI]) >= 0, "Warning, about to leak memory in CvSpellInfo::readPass3");
		m_pbObsoletedBySpell[GC.getInfoTypeForString(m_aszObsoletedBySpellforPass3[iI])] = m_abObsoletedBySpellforPass3[iI];
	}
    m_aszObsoletedBySpellforPass3.clear();
    m_abObsoletedBySpellforPass3.clear();

    return true;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(SpellInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpellInfo::copyNonDefaults(CvSpellInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isBuffCasterOnly()				== false)				m_bBuffCasterOnly				= pClassInfo->isBuffCasterOnly();
	if (isCopyCastersPromotions()		== false)				m_bCopyCastersPromotions		= pClassInfo->isCopyCastersPromotions();
	if (isPermanentUnitCreate()			== false)				m_bPermanentUnitCreate			= pClassInfo->isPermanentUnitCreate();
	if (isImmuneTeam()					== false)				m_bImmuneTeam					= pClassInfo->isImmuneTeam();
	if (isImmuneNeutral()				== false)				m_bImmuneNeutral				= pClassInfo->isImmuneNeutral();
	if (isImmuneEnemy()					== false)				m_bImmuneEnemy					= pClassInfo->isImmuneEnemy();
	if (isImmuneFlying()				== false)				m_bImmuneFlying					= pClassInfo->isImmuneFlying();
	if (isImmuneNotAlive()				== false)				m_bImmuneNotAlive				= pClassInfo->isImmuneNotAlive();
	if (isAbility()						== false)				m_bAbility						= pClassInfo->isAbility();
	if (isDispel()						== false)				m_bDispel						= pClassInfo->isDispel();
	if (isPush()						== false)				m_bPush							= pClassInfo->isPush();
	if (isRemoveHasCasted()				== false)				m_bRemoveHasCasted				= pClassInfo->isRemoveHasCasted();
	if (isSacrificeCaster()				== false)				m_bSacrificeCaster				= pClassInfo->isSacrificeCaster();
	if (isAllowAI()						== false)				m_bAllowAI						= pClassInfo->isAllowAI();
	if (isAdjacentToWaterOnly()			== false)				m_bAdjacentToWaterOnly			= pClassInfo->isAdjacentToWaterOnly();
	if (isCasterMustBeAlive()			== false)				m_bCasterMustBeAlive			= pClassInfo->isCasterMustBeAlive();
	if (isCasterNoDuration()			== false)				m_bCasterNoDuration				= pClassInfo->isCasterNoDuration();
	if (isCausesWar()					== false)				m_bCausesWar					= pClassInfo->isCausesWar();
	if (isGlobal()						== false)				m_bGlobal						= pClassInfo->isGlobal();
	if (isInBordersOnly()				== false)				m_bInBordersOnly				= pClassInfo->isInBordersOnly();
	if (isInCityOnly()					== false)				m_bInCityOnly					= pClassInfo->isInCityOnly();
	if (isPrereqSlaveTrade()			== false)				m_bPrereqSlaveTrade				= pClassInfo->isPrereqSlaveTrade();
	if (isResistable()					== false)				m_bResistable					= pClassInfo->isResistable();
	if (isDisplayWhenDisabled()			== false)				m_bDisplayWhenDisabled			= pClassInfo->isDisplayWhenDisabled();
	if (isHasCasted()					== false)				m_bHasCasted					= pClassInfo->isHasCasted();
	if (isIgnoreHasCasted()				== false)				m_bIgnoreHasCasted				= pClassInfo->isIgnoreHasCasted();
	if (getAIWeight()					== 0)					m_iAIWeight						= pClassInfo->getAIWeight();
	if (getCasterMinLevel()				== 0)					m_iCasterMinLevel				= pClassInfo->getCasterMinLevel();
	if (getHeal()						== 0)					m_iHeal							= pClassInfo->getHeal();
	if (getRange()						== 0)					m_iRange						= pClassInfo->getRange();
	if (getResistModify()				== 0)					m_iResistModify					= pClassInfo->getResistModify();
	if (getDamage()						== 0)					m_iDamage						= pClassInfo->getDamage();
	if (getDamageLimit()				== 0)					m_iDamageLimit					= pClassInfo->getDamageLimit();
	if (getCreateUnitNum()				== 0)					m_iCreateUnitNum				= pClassInfo->getCreateUnitNum();
	if (getChangePopulation()			== 0)					m_iChangePopulation				= pClassInfo->getChangePopulation();
	if (getCost()						== 0)					m_iCost							= pClassInfo->getCost();
	if (getDelay()						== 0)					m_iDelay						= pClassInfo->getDelay();
	if (getImmobileTurns()				== 0)					m_iImmobileTurns				= pClassInfo->getImmobileTurns();
	if (isDomination()					== 0)					m_bDomination					= pClassInfo->isDomination();
	if (getMiscastChance()				== 0)					m_iMiscastChance				= pClassInfo->getMiscastChance();
	if (getSound()						== cDefault)			m_szSound						= pClassInfo->getSound();
	if (getPyMiscast()					== cDefault)			m_szPyMiscast					= pClassInfo->getPyMiscast();
	if (getPyResult()					== cDefault)			m_szPyResult					= pClassInfo->getPyResult();
	if (getPyRequirement()				== cDefault)			m_szPyRequirement				= pClassInfo->getPyRequirement();
	if (getUnitPrereq()					== NO_UNIT)				m_iUnitPrereq					= pClassInfo->getUnitPrereq();
	if (getUnitInStackPrereq()			== NO_UNIT)				m_iUnitInStackPrereq			= pClassInfo->getUnitInStackPrereq();
	if (getCreateUnitType()				== NO_UNIT)				m_iCreateUnitType				= pClassInfo->getCreateUnitType();
	if (getConvertUnitType()			== NO_UNIT)				m_iConvertUnitType				= pClassInfo->getConvertUnitType();
	if (getTechPrereq()					== NO_TECH)				m_iTechPrereq					= pClassInfo->getTechPrereq();
	if (getEffect()						== NO_EFFECT)			m_iEffect						= pClassInfo->getEffect();
	if (getDamageType()					== NO_DAMAGE)			m_iDamageType					= pClassInfo->getDamageType();
	if (getCreateFeatureType()			== NO_FEATURE)			m_iCreateFeatureType			= pClassInfo->getCreateFeatureType();
	if (getFeatureOrPrereq1()			== NO_FEATURE)			m_iFeatureOrPrereq1				= pClassInfo->getFeatureOrPrereq1();
	if (getFeatureOrPrereq2()			== NO_FEATURE)			m_iFeatureOrPrereq2				= pClassInfo->getFeatureOrPrereq2();
	if (getSpreadReligion()				== NO_RELIGION)			m_iSpreadReligion				= pClassInfo->getSpreadReligion();
	if (getReligionPrereq()				== NO_RELIGION)			m_iReligionPrereq				= pClassInfo->getReligionPrereq();
	if (getStateReligionPrereq()		== NO_RELIGION)			m_iStateReligionPrereq			= pClassInfo->getStateReligionPrereq();
	if (getCreateBuildingType()			== NO_BUILDING)			m_iCreateBuildingType			= pClassInfo->getCreateBuildingType();
	if (getCreateBuildingType1()		== NO_BUILDING)			m_iCreateBuildingType1			= pClassInfo->getCreateBuildingType1();
	if (getCreateBuildingType2()		== NO_BUILDING)			m_iCreateBuildingType2			= pClassInfo->getCreateBuildingType2();
	if (getRemoveBuildingType()			== NO_BUILDING)			m_iRemoveBuildingType			= pClassInfo->getRemoveBuildingType();
	if (getBuildingPrereq()				== NO_BUILDING)			m_iBuildingPrereq				= pClassInfo->getBuildingPrereq();
	if (getPromotionPrereq1()			== NO_PROMOTION)		m_iPromotionPrereq1				= pClassInfo->getPromotionPrereq1();
	if (getPromotionPrereq2()			== NO_PROMOTION)		m_iPromotionPrereq2				= pClassInfo->getPromotionPrereq2();
	if (getPromotionPrereq3()			== NO_PROMOTION)		m_iPromotionPrereq3				= pClassInfo->getPromotionPrereq3();
	if (getPromotionPrereq4()			== NO_PROMOTION)		m_iPromotionPrereq4				= pClassInfo->getPromotionPrereq4();
	if (getPromotionInStackPrereq()		== NO_PROMOTION)		m_iPromotionInStackPrereq		= pClassInfo->getPromotionInStackPrereq();
	if (getCreateUnitPromotion()		== NO_PROMOTION)		m_iCreateUnitPromotion			= pClassInfo->getCreateUnitPromotion();
	if (getAddPromotionType1()			== NO_PROMOTION)		m_iAddPromotionType1			= pClassInfo->getAddPromotionType1();
	if (getAddPromotionType2()			== NO_PROMOTION)		m_iAddPromotionType2			= pClassInfo->getAddPromotionType2();
	if (getAddPromotionType3()			== NO_PROMOTION)		m_iAddPromotionType3			= pClassInfo->getAddPromotionType3();
	if (getAddPromotionType4()			== NO_PROMOTION)		m_iAddPromotionType4			= pClassInfo->getAddPromotionType4();
	if (getAddPromotionType5()			== NO_PROMOTION)		m_iAddPromotionType5			= pClassInfo->getAddPromotionType5();
	if (getRemovePromotionType1()		== NO_PROMOTION)		m_iRemovePromotionType1			= pClassInfo->getRemovePromotionType1();
	if (getRemovePromotionType2()		== NO_PROMOTION)		m_iRemovePromotionType2			= pClassInfo->getRemovePromotionType2();
	if (getRemovePromotionType3()		== NO_PROMOTION)		m_iRemovePromotionType3			= pClassInfo->getRemovePromotionType3();
	if (getUnitClassPrereq()			== NO_UNITCLASS)		m_iUnitClassPrereq				= pClassInfo->getUnitClassPrereq();
	if (getUnitCombatPrereq()			== NO_UNITCOMBAT)		m_iUnitCombatPrereq				= pClassInfo->getUnitCombatPrereq();
	if (getCorporationPrereq()			== NO_CORPORATION)		m_iCorporationPrereq			= pClassInfo->getCorporationPrereq();
	if (getCreateImprovementType()		== NO_IMPROVEMENT)		m_iCreateImprovementType		= pClassInfo->getCreateImprovementType();
	if (getImprovementPrereq()			== NO_IMPROVEMENT)		m_iImprovementPrereq			= pClassInfo->getImprovementPrereq();
	if (getCivilizationPrereq()			== NO_CIVILIZATION)		m_iCivilizationPrereq			= pClassInfo->getCivilizationPrereq();
	if (getBuildingClassOwnedPrereq()	== NO_BUILDINGCLASS)	m_iBuildingClassOwnedPrereq		= pClassInfo->getBuildingClassOwnedPrereq();

	if (isAllowAuto()                   == false)               m_bAllowAuto                    = pClassInfo->isAllowAuto();
	if (isExploreDungeon()              == false)               m_bExploreDungeon               = pClassInfo->isExploreDungeon();
	if (isNoDisplay()		            == false)               m_bNoDisplay	                = pClassInfo->isNoDisplay();
	if (getFaithCost()                  == 0)                   m_iFaithCost                    = pClassInfo->getFaithCost();
	if (getManaCost()                   == 0)                   m_iManaCost                     = pClassInfo->getManaCost();
	if (getPrereqAlignment()            == NO_ALIGNMENT)        m_iPrereqAlignment              = pClassInfo->getPrereqAlignment();
	if (isTargetedHostile()             == false)				m_bTargetedHostile              = pClassInfo->isTargetedHostile();
	if (isBombard()						== false)				m_bBombard						= pClassInfo->isBombard();
	if (isFlameFeatures()				== false)				m_bFlameFeatures				= pClassInfo->isFlameFeatures();
	if (isHighCrit()					== false)				m_bHighCrit						= pClassInfo->isHighCrit();
	if (isManaCostReductionBonus()		== false)				m_bManaCostReductionBonus		= pClassInfo->isManaCostReductionBonus();
	if (isThiefMission()				== false)				m_bThiefMission					= pClassInfo->isThiefMission();
	if (getThiefDifficulty()			== 0)					m_iThiefDifficulty				= pClassInfo->getThiefDifficulty();
	if (getThiefExperienceChange()		== 0)					m_iThiefExperienceChange		= pClassInfo->getThiefExperienceChange();
	if (getNumTargets()                 == -1)					m_iNumTargets					= pClassInfo->getNumTargets();
	if (getTriggerSecondaryPlotChance() == 0)					m_iTriggerSecondaryPlotChance   = pClassInfo->getTriggerSecondaryPlotChance();
	if (getForcedTeleport()				== 0)					m_iForcedTeleport				= pClassInfo->getForcedTeleport();
	if (getReduceDurability()			== 0)					m_iReduceDurability				= pClassInfo->getReduceDurability();
	if (getDestroyEnemyEquipment()		== 0)					m_iDestroyEnemyEquipment		= pClassInfo->getDestroyEnemyEquipment();
	if (getDoT()						== NO_PROMOTION)		m_iDoT							= pClassInfo->getDoT();
	if (getDamageSpellPrereqPromotion() == NO_PROMOTION)		m_iDamageSpellPrereqPromotion	= pClassInfo->getDamageSpellPrereqPromotion();
	if (getDamageSpellPrereqUnitCombat() == NO_UNITCOMBAT)		m_iDamageSpellPrereqUnitCombat	= pClassInfo->getDamageSpellPrereqUnitCombat();
	if (getUnitCombatCapture()			== NO_UNITCOMBAT)		m_iUnitCombatCapture			= pClassInfo->getUnitCombatCapture();
	if (getTerrainOrPrereq1()			== NO_TERRAIN)			m_iTerrainOrPrereq1				= pClassInfo->getTerrainOrPrereq1();
	if (getTerrainOrPrereq2()			== NO_TERRAIN)			m_iTerrainOrPrereq2				= pClassInfo->getTerrainOrPrereq2();
//>>>>Spell Interrupt Unit Cycling: Added by Denev 2009/10/17
	if (isNoInterruptUnitCycling()			== true)			m_bNoInterruptUnitCycling				= pClassInfo->isNoInterruptUnitCycling();
//<<<<Spell Interrupt Unit Cycling: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	for ( int j = 0; j < GC.getNumCorporationInfos(); j++)
	{
		if (getCorporationSupport((CorporationTypes)j)			== 0)				m_paiCorporationSupport[j]			= pClassInfo->getCorporationSupport((CorporationTypes)j);
		if (getCorporationSupportMultiplier((CorporationTypes)j)== 0)				m_paiCorporationSupportMod[j]		= pClassInfo->getCorporationSupportMultiplier((CorporationTypes)j);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	// Readpass3 stuff

	for ( int i = 0; i < pClassInfo->getObsoletedBySpellVectorSize(); i++ )
	{
		m_aszObsoletedBySpellforPass3.push_back(	pClassInfo->getObsoletedBySpellNamesVectorElement(i));
		m_abObsoletedBySpellforPass3.push_back(	pClassInfo->getObsoletedBySpellValuesVectorElement(i));
	}

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	BETTER AI (Better Promotions) Sephi                                      					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/

//======================================================================================================
//					CvAIPromotionSpecializationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAIPromotionSpecializationInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAIPromotionSpecializationInfo::CvAIPromotionSpecializationInfo() :
m_iAIGroup(NO_AIGROUP),
m_iCityAttack(0),
m_iCityDefense(0),
m_iCombatPromotions(0),
m_iDefensiveStrikes(0),
m_iFirstStrikes(0),
m_iGuardsman(0),
m_iHunter(0),
m_iLandscape(0),
m_iMobility(0),
m_iSight(0),
m_iWithdraw(0),
m_piPromotionValue(NULL)

{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpellInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAIPromotionSpecializationInfo::~CvAIPromotionSpecializationInfo()
{
	SAFE_DELETE_ARRAY(m_piPromotionValue);
}

int CvAIPromotionSpecializationInfo::getAIGroup() const
{
	return m_iAIGroup;
}

int CvAIPromotionSpecializationInfo::getCityAttack() const
{
	return m_iCityAttack;
}

int CvAIPromotionSpecializationInfo::getCityDefense() const
{
	return m_iCityDefense;
}

int CvAIPromotionSpecializationInfo::getCombatPromotions() const
{
	return m_iCombatPromotions;
}

int CvAIPromotionSpecializationInfo::getDefensiveStrikes() const
{
	return m_iDefensiveStrikes;
}

int CvAIPromotionSpecializationInfo::getFirstStrikes() const
{
	return m_iFirstStrikes;
}

int CvAIPromotionSpecializationInfo::getGuardsman() const
{
	return m_iGuardsman;
}

int CvAIPromotionSpecializationInfo::getHunter() const
{
	return m_iHunter;
}

int CvAIPromotionSpecializationInfo::getLandscape() const
{
	return m_iLandscape;
}

int CvAIPromotionSpecializationInfo::getMobility() const
{
	return m_iMobility;
}

int CvAIPromotionSpecializationInfo::getSight() const
{
	return m_iSight;
}

int CvAIPromotionSpecializationInfo::getWithdraw() const
{
	return m_iWithdraw;
}

int CvAIPromotionSpecializationInfo::isSaveUpPromotions() const
{
	return m_bSaveUpPromotions;
}

int CvAIPromotionSpecializationInfo::getPromotionValue(int i) const
{
	FAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPromotionValue ? m_piPromotionValue[i] : -1;
}

void CvAIPromotionSpecializationInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvAIPromotionSpecializationInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvAIPromotionSpecializationInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "AIGroup");
	if (szTextVal != "") m_iAIGroup = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iCityAttack, "iCityAttack",5);
	pXML->GetChildXmlValByName(&m_iCityDefense, "iCityDefense",0);
	pXML->GetChildXmlValByName(&m_iCombatPromotions, "iCombatPromotions",100);
	pXML->GetChildXmlValByName(&m_iDefensiveStrikes, "iDefensiveStrikes",0);
	pXML->GetChildXmlValByName(&m_iFirstStrikes, "iFirstStrikes",50);
	pXML->GetChildXmlValByName(&m_iGuardsman, "iGuardsman",4);
	pXML->GetChildXmlValByName(&m_iHunter, "iHunter",2);
	pXML->GetChildXmlValByName(&m_iLandscape, "iLandscape",2);
	pXML->GetChildXmlValByName(&m_iMobility, "iMobility",50);
	pXML->GetChildXmlValByName(&m_iSight, "iSight",2);
	pXML->GetChildXmlValByName(&m_iWithdraw, "iWithdraw",10);
	pXML->GetChildXmlValByName(&m_bSaveUpPromotions, "bSaveUpPromotions",0);

	pXML->SetVariableListTagPair(&m_piPromotionValue, "Promotions", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos());

	return true;
}
//FfH: End Add

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(SpellInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAIPromotionSpecializationInfo::copyNonDefaults(CvAIPromotionSpecializationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getAIGroup()					== NO_AIGROUP)			m_iAIGroup						= pClassInfo->getAIGroup();
	if (getCityAttack()			        == 0)					m_iCityAttack     				= pClassInfo->getCityAttack();
	if (getCityDefense()			    == 0)					m_iCityDefense  				= pClassInfo->getCityDefense();
	if (getCombatPromotions()			== 0)					m_iCombatPromotions				= pClassInfo->getCombatPromotions();
	if (getDefensiveStrikes()			== 0)					m_iDefensiveStrikes     		= pClassInfo->getDefensiveStrikes();
	if (getFirstStrikes()			    == 0)					m_iFirstStrikes				    = pClassInfo->getFirstStrikes();
	if (getGuardsman()			        == 0)					m_iGuardsman     				= pClassInfo->getGuardsman();
	if (getHunter()			            == 0)					m_iHunter  				        = pClassInfo->getHunter();
	if (getLandscape()			        == 0)					m_iLandscape				    = pClassInfo->getLandscape();
	if (getMobility()			        == 0)					m_iMobility     				= pClassInfo->getMobility();
	if (getSight()			            == 0)					m_iSight  				        = pClassInfo->getSight();
	if (getWithdraw()			        == 0)					m_iWithdraw				        = pClassInfo->getWithdraw();

	if (isSaveUpPromotions()		    == false)				m_bSaveUpPromotions		        = pClassInfo->isSaveUpPromotions();

	for ( int i = 0; i < GC.getNumPromotionInfos(); i++ )
	{
		if(getPromotionValue(i)		== 0)						m_piPromotionValue[i]			= pClassInfo->getPromotionValue(i);
	}

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/**	ADDON (Adventures) Sephi                                                      					**/

//======================================================================================================
//					CvAdventureInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAdventureInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAdventureInfo::CvAdventureInfo() :
m_bDisabled(false),
m_bVictory(false),
m_bVictoryFailed(false),
m_iPrereqAC(0),
m_piAdventureCounters(NULL),
m_pbPrereqLeaders(NULL),
m_pbPrereqCivs(NULL),
m_pbPrereqCivsMet(NULL),
m_pbPrereqReligionsFounded(NULL)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAdventureInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAdventureInfo::~CvAdventureInfo()
{
	SAFE_DELETE_ARRAY(m_pbPrereqLeaders);
	SAFE_DELETE_ARRAY(m_pbPrereqCivs);
	SAFE_DELETE_ARRAY(m_piAdventureCounters);
    SAFE_DELETE_ARRAY(m_pbPrereqCivsMet);
    SAFE_DELETE_ARRAY(m_pbPrereqReligionsFounded);
}

bool CvAdventureInfo::isDisabled() const
{
	return m_bDisabled;
}

bool CvAdventureInfo::isVictory() const
{
	return m_bVictory;
}

bool CvAdventureInfo::isVictoryFailed() const
{
	return m_bVictoryFailed;
}

int CvAdventureInfo::getAdventureCounter(int iNumber) const
{
    if (!m_piAdventureCounters)
    {
        return -1;
    }
    //return max. five different results (so we do not have to use that much mem in CvPlayer)
	int iCounter=0;
    for (int iI=0;iI<GC.getNumAdventureStepInfos();iI++)
    {
        if(m_piAdventureCounters[iI]>0)
        {
            if(iNumber==iCounter)
            {
                return m_piAdventureCounters[iI];
            }
            else
            {
                iCounter++;
            }
        }
    }
	return -1;
}

int CvAdventureInfo::getAdventureStep(int iNumber) const
{
    if (!m_piAdventureCounters)
    {
        return -1;
    }
    //return max. five different results (so we do not have to use that much mem in CvPlayer)
	int iCounter=0;
    for (int iI=0;iI<GC.getNumAdventureStepInfos();iI++)
    {
        if(m_piAdventureCounters[iI]>0)
        {
            if(iNumber==iCounter)
            {
                return iI;
            }
            else
            {
                iCounter++;
            }
        }
    }
	return -1;
}

bool CvAdventureInfo::isPrereqLeader(int iLeader) const
{
	return m_pbPrereqLeaders[iLeader];
}

bool CvAdventureInfo::isPrereqCiv(int iCiv) const
{
	return m_pbPrereqCivs[iCiv];
}

bool CvAdventureInfo::isPrereqCivMet(int iCiv) const
{
    return m_pbPrereqCivsMet[iCiv];
}

bool CvAdventureInfo::isPrereqReligionFounded(int iCiv) const
{
    return m_pbPrereqReligionsFounded[iCiv];
}

int CvAdventureInfo::getPrereqAC() const
{
    return m_iPrereqAC;
}

const TCHAR* CvAdventureInfo::getPyIsFinished() const
{
	return m_szPyIsFinished;
}

void CvAdventureInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvAdventureInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvAdventureInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDisabled, "bDisabled");
	pXML->GetChildXmlValByName(&m_bVictory, "bVictory",false);
	pXML->GetChildXmlValByName(&m_bVictoryFailed, "bVictoryFailed",false);

	pXML->GetChildXmlValByName(&m_iPrereqAC, "iPrereqAC",-1);
	pXML->SetVariableListTagPair(&m_pbPrereqLeaders, "PrereqLeaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());
	pXML->SetVariableListTagPair(&m_pbPrereqCivs, "PrereqCivs", sizeof(GC.getCivilizationInfo((CivilizationTypes)0)), GC.getNumCivilizationInfos());
	pXML->SetVariableListTagPair(&m_pbPrereqCivsMet, "PrereqCivsMet", sizeof(GC.getCivilizationInfo((CivilizationTypes)0)), GC.getNumCivilizationInfos());
	pXML->SetVariableListTagPair(&m_pbPrereqReligionsFounded, "PrereqReligionsFounded", sizeof(GC.getReligionInfo((ReligionTypes)0)), GC.getNumReligionInfos());

	pXML->SetVariableListTagPair(&m_piAdventureCounters, "AdventureCounters", sizeof(GC.getAdventureStepInfo((AdventureStepTypes)0)), GC.getNumAdventureStepInfos());

	pXML->GetChildXmlValByName(m_szPyIsFinished, "PyIsFinished");
	return true;
}
//FfH: End Add

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(SpellInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAdventureInfo::copyNonDefaults(CvAdventureInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if(isDisabled()					== false)			m_bDisabled						= pClassInfo->isDisabled();
	if(isVictory()					== false)			m_bVictory						= pClassInfo->isVictory();
	if(isVictoryFailed()			== false)			m_bVictoryFailed				= pClassInfo->isVictoryFailed();
	if(getPrereqAC()                == -1)              m_iPrereqAC                     = pClassInfo->getPrereqAC();

	for (int i = 0; i < GC.getNumAdventureStepInfos(); i++)
	{
	    if(getAdventureCounter(i)   == 0)           m_piAdventureCounters[i]         = pClassInfo->getAdventureCounter(i);
	}

	for ( int i = 0; i < GC.getNumLeaderHeadInfos(); i++ )
	{
		if (isPrereqLeader(i)	== false)			m_pbPrereqLeaders[i]		= pClassInfo->isPrereqLeader(i);
	}

	for ( int i = 0; i < GC.getNumCivilizationInfos(); i++ )
	{
		if (isPrereqCiv(i)	== false)			m_pbPrereqCivs[i]		= pClassInfo->isPrereqCiv(i);
		if (isPrereqCivMet(i)== false)			m_pbPrereqCivsMet[i]	= pClassInfo->isPrereqCivMet(i);
	}

	for ( int i = 0; i < GC.getNumReligionInfos(); i++ )
	{
		if (isPrereqReligionFounded(i)	== false)	m_pbPrereqReligionsFounded[i]	= pClassInfo->isPrereqReligionFounded(i);
	}

	if (getPyIsFinished()					== cDefault)		m_szPyIsFinished					= pClassInfo->getPyIsFinished();

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAdventureStepInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAdventureStepInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAdventureStepInfo::CvAdventureStepInfo() :
m_bCivsDestroyed(false),
m_bImprovementPillaged(false),
m_bNoBarBarian(false),
m_bUnitCreated(false),
m_bUnitKill(false),
m_bTroophyFromAnimal(false),
m_iUnitType(0),

m_bCastAnySpell(false),
m_bCivicDuration(false),
m_bDestroyCivilization(false),
m_bDiscoverWholeMap(false),
m_bGlobalEnchantment(false),
m_bGovannonsLegacy(false),
m_bMazatlAmbushDeepJungle(false),
m_bNeverAdoptCivic(false),
m_bSheaimSummonDemon(false),
m_bSpell(false),
m_bSpreadFeature(false),
m_bUnitPromoted(false),
m_iACabove(0),
m_iACbelow(0),
m_iCivicType(0),
m_iCivilizationType(0),
m_iFeatureType(0),
m_iReligionType(0),
m_iProjectType(0),
m_iPromotionType(0),
m_iPurityCounter(0),
m_iRazeHolyCity(0),
m_iSpellType(0),
m_iUnitLevel(0),

m_bMimicPromotion(false),
m_iNumBuildingOwned(0),
m_iBuildingType(0),

m_bSpreadReligion(false),
m_bKillHeroNetherblade(false),
m_bPaxPatria(false),
m_bWorldUnitDefeated(false),
m_bCreateWorldWonder(false),
m_bLeadOvercouncil(false),
m_bLeadUndercouncil(false),
m_bDeclareWarAtFriendly(false),
m_bNeverLooseCity(false),
m_bConvertAllCivs(false),
m_bDeclareWar(false),

m_iCapitalPopulation(0),
m_iGoldTreasury(0),
m_iUnitCount(0),
m_iNumUnitsOwned(0),
m_iNumBonusOwned(0),
m_iBonusType(0),

m_bRemoveReligionFromAllCities(0),
m_bLanunCaptureShip(0),
m_bPlunderGold(0)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAdventureInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAdventureStepInfo::~CvAdventureStepInfo()
{
}

bool CvAdventureStepInfo::isCivsDestroyed() const
{
	return m_bCivsDestroyed;
}

bool CvAdventureStepInfo::isImprovementPillaged() const
{
	return m_bImprovementPillaged;
}

bool CvAdventureStepInfo::isNoBarBarian() const
{
	return m_bNoBarBarian;
}

bool CvAdventureStepInfo::isUnitCreated() const
{
	return m_bUnitCreated;
}

int CvAdventureStepInfo::getUnitLevel() const
{
	return m_iUnitLevel;
}

bool CvAdventureStepInfo::isUnitKill() const
{
	return m_bUnitKill;
}

bool CvAdventureStepInfo::isTroophyFromAnimal() const
{
	return m_bTroophyFromAnimal;
}

int CvAdventureStepInfo::getUnitType() const
{
	return m_iUnitType;
}

bool CvAdventureStepInfo::isCastAnySpell() const
{
    return m_bCastAnySpell;
}
bool CvAdventureStepInfo::isCivicDuration() const
{
    return m_bCivicDuration;
}
bool CvAdventureStepInfo::isDestroyCivilization() const
{
    return m_bDestroyCivilization;
}

bool CvAdventureStepInfo::isDiscoverWholeMap() const
{
    return m_bDiscoverWholeMap;
}
bool CvAdventureStepInfo::isGlobalEnchantment() const
{
    return m_bGlobalEnchantment;
}
bool CvAdventureStepInfo::isGovannonsLegacy() const
{
    return m_bGovannonsLegacy;
}
bool CvAdventureStepInfo::isMazatlAmbushDeepJungle() const
{
    return m_bMazatlAmbushDeepJungle;
}
bool CvAdventureStepInfo::isNeverAdoptCivic() const
{
    return m_bNeverAdoptCivic;
}
bool CvAdventureStepInfo::isSheaimSummonDemon() const
{
    return m_bSheaimSummonDemon;
}
bool CvAdventureStepInfo::isSpell() const
{
    return m_bSpell;
}
bool CvAdventureStepInfo::isSpreadFeature() const
{
    return m_bSpreadFeature;
}
bool CvAdventureStepInfo::isUnitPromoted() const
{
    return m_bUnitPromoted;
}

int CvAdventureStepInfo::getACabove() const{ return m_iACabove;}
int CvAdventureStepInfo::getACbelow() const{ return m_iACbelow;}
int CvAdventureStepInfo::getCivicType() const{ return m_iCivicType;}
int CvAdventureStepInfo::getCivilizationType() const{ return m_iCivilizationType;}
int CvAdventureStepInfo::getFeatureType() const{ return m_iFeatureType;}
int CvAdventureStepInfo::getReligionType() const{ return m_iReligionType;}
int CvAdventureStepInfo::getProjectType() const{ return m_iProjectType;}
int CvAdventureStepInfo::getPromotionType() const{ return m_iPromotionType;}
int CvAdventureStepInfo::getPurityCounter() const{ return m_iPurityCounter;}
int CvAdventureStepInfo::getRazeHolyCity() const{ return m_iRazeHolyCity;}
int CvAdventureStepInfo::getSpellType() const{ return m_iSpellType;}

bool CvAdventureStepInfo::isMimicPromotion() const { return m_bMimicPromotion;}
int CvAdventureStepInfo::getNumBuildingOwned() const { return m_iNumBuildingOwned;}
int CvAdventureStepInfo::getBuildingType() const { return m_iBuildingType;}

bool CvAdventureStepInfo::isSpreadReligion() const { return m_bSpreadReligion;}
bool CvAdventureStepInfo::isKillHeroNetherblade() const { return m_bKillHeroNetherblade;}
bool CvAdventureStepInfo::isPaxPatria() const { return m_bPaxPatria;}
bool CvAdventureStepInfo::isWorldUnitDefeated() const { return m_bWorldUnitDefeated;}
bool CvAdventureStepInfo::isCreateWorldWonder() const { return m_bCreateWorldWonder;}
bool CvAdventureStepInfo::isLeadOvercouncil() const { return m_bLeadOvercouncil;}
bool CvAdventureStepInfo::isLeadUndercouncil() const { return m_bLeadUndercouncil;}
bool CvAdventureStepInfo::isDeclareWarAtFriendly() const { return m_bDeclareWarAtFriendly;}
bool CvAdventureStepInfo::isNeverLooseCity() const { return m_bNeverLooseCity;}
bool CvAdventureStepInfo::isConvertAllCivs() const { return m_bConvertAllCivs;}
bool CvAdventureStepInfo::isDeclareWar() const { return m_bDeclareWar;}

int CvAdventureStepInfo::getCapitalPopulation() const { return m_iCapitalPopulation;}
int CvAdventureStepInfo::getGoldTreasury() const { return m_iGoldTreasury;}
int CvAdventureStepInfo::getUnitCount() const { return m_iUnitCount;}
int CvAdventureStepInfo::getNumUnitsOwned() const { return m_iNumUnitsOwned;}
int CvAdventureStepInfo::getNumBonusOwned() const { return m_iNumBonusOwned;}
int CvAdventureStepInfo::getBonusType() const { return m_iBonusType;}

bool CvAdventureStepInfo::isRemoveReligionFromAllCities() const { return m_bRemoveReligionFromAllCities;}
bool CvAdventureStepInfo::isLanunCaptureShip() const { return m_bLanunCaptureShip;}
bool CvAdventureStepInfo::isPlunderGold() const { return m_bPlunderGold;}

void CvAdventureStepInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvAdventureStepInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvAdventureStepInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bCivsDestroyed, "bCivsDestroyed",false);
	pXML->GetChildXmlValByName(&m_bImprovementPillaged, "bImprovementPillaged",false);
	pXML->GetChildXmlValByName(&m_bNoBarBarian, "bNoBarBarian",false);
	pXML->GetChildXmlValByName(&m_bUnitCreated, "bUnitCreated",false);
	pXML->GetChildXmlValByName(&m_bUnitKill, "bUnitKill",false);
	pXML->GetChildXmlValByName(&m_bTroophyFromAnimal, "bTroophyFromAnimal",false);
	pXML->GetChildXmlValByName(szTextVal, "UnitType");
	m_iUnitType = pXML->FindInInfoClass(szTextVal);


    pXML->GetChildXmlValByName(&m_bCastAnySpell, "bCastAnySpell",false);
    pXML->GetChildXmlValByName(&m_bCivicDuration, "bCivicDuration",false);
    pXML->GetChildXmlValByName(&m_bDestroyCivilization, "bDestroyCivilization",false);
    pXML->GetChildXmlValByName(&m_bDiscoverWholeMap, "bDiscoverWholeMap",false);
    pXML->GetChildXmlValByName(&m_bGlobalEnchantment, "bGlobalEnchantment",false);
    pXML->GetChildXmlValByName(&m_bGovannonsLegacy, "bGovannonsLegacy",false);
    pXML->GetChildXmlValByName(&m_bMazatlAmbushDeepJungle, "bMazatlAmbushDeepJungle",false);
    pXML->GetChildXmlValByName(&m_bNeverAdoptCivic, "bNeverAdoptCivic",false);
    pXML->GetChildXmlValByName(&m_bSheaimSummonDemon, "bSheaimSummonDemon",false);
    pXML->GetChildXmlValByName(&m_bSpell, "bSpell",false);
    pXML->GetChildXmlValByName(&m_bSpreadFeature, "bSpreadFeature",false);
    pXML->GetChildXmlValByName(&m_bUnitPromoted, "bUnitPromoted",false);
	pXML->GetChildXmlValByName(&m_iACabove, "iACabove",-1);
	pXML->GetChildXmlValByName(&m_iACbelow, "iACbelow",-1);
	pXML->GetChildXmlValByName(&m_iUnitLevel, "iUnitLevel",-1);
    pXML->GetChildXmlValByName(szTextVal, "CivicType");
    m_iCivicType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "CivilizationType");
    m_iCivilizationType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "FeatureType");
    m_iFeatureType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "ReligionType");
    m_iReligionType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "ProjectType");
    m_iProjectType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "PromotionType");
    m_iPromotionType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iPurityCounter, "iPurityCounter",0);
    pXML->GetChildXmlValByName(szTextVal, "RazeHolyCity");
    m_iRazeHolyCity = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "SpellType");
    m_iSpellType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bMimicPromotion, "bMimicPromotion",false);
	pXML->GetChildXmlValByName(&m_iNumBuildingOwned, "iNumBuildingOwned",0);
    pXML->GetChildXmlValByName(szTextVal, "BuildingType");
    m_iBuildingType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bSpreadReligion, "bSpreadReligion",false);
	pXML->GetChildXmlValByName(&m_bKillHeroNetherblade, "bKillHeroNetherblade",false);
	pXML->GetChildXmlValByName(&m_bPaxPatria, "bPaxPatria",false);
	pXML->GetChildXmlValByName(&m_bWorldUnitDefeated, "bWorldUnitDefeated",false);
	pXML->GetChildXmlValByName(&m_bCreateWorldWonder, "bCreateWorldWonder",false);
	pXML->GetChildXmlValByName(&m_bLeadOvercouncil, "bLeadOvercouncil",false);
	pXML->GetChildXmlValByName(&m_bLeadUndercouncil, "bLeadUndercouncil",false);
	pXML->GetChildXmlValByName(&m_bDeclareWarAtFriendly, "bDeclareWarAtFriendly",false);
	pXML->GetChildXmlValByName(&m_bNeverLooseCity, "bNeverLooseCity",false);
	pXML->GetChildXmlValByName(&m_bConvertAllCivs, "bConvertAllCivs",false);
	pXML->GetChildXmlValByName(&m_bDeclareWar, "bDeclareWar",false);

	pXML->GetChildXmlValByName(&m_iCapitalPopulation, "iCapitalPopulation",-1);
    pXML->GetChildXmlValByName(&m_iUnitCount, "iUnitCount",-1);
    pXML->GetChildXmlValByName(&m_iGoldTreasury, "iGoldTreasury",-1);
	pXML->GetChildXmlValByName(&m_iNumUnitsOwned, "iNumUnitsOwned",-1);
    pXML->GetChildXmlValByName(&m_iNumBonusOwned, "iNumBonusOwned",-1);
    pXML->GetChildXmlValByName(szTextVal, "BonusType");
    m_iBonusType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bRemoveReligionFromAllCities, "bRemoveReligionFromAllCities",false);
	pXML->GetChildXmlValByName(&m_bLanunCaptureShip, "bLanunCaptureShip",false);
	pXML->GetChildXmlValByName(&m_bPlunderGold, "bPlunderGold",false);

    return true;
}
//FfH: End Add

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(SpellInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAdventureStepInfo::copyNonDefaults(CvAdventureStepInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if(isCivsDestroyed()			== false)	            m_bCivsDestroyed					= pClassInfo->isCivsDestroyed();
	if(isImprovementPillaged()		== false)	            m_bImprovementPillaged				= pClassInfo->isImprovementPillaged();
	if(isNoBarBarian()				== false)	            m_bNoBarBarian						= pClassInfo->isNoBarBarian();
	if(isUnitCreated()				== false)	            m_bUnitCreated						= pClassInfo->isUnitCreated();
	if(isUnitKill()					== false)	            m_bUnitKill							= pClassInfo->isUnitKill();
	if(isTroophyFromAnimal()		== false)	            m_bTroophyFromAnimal				= pClassInfo->isTroophyFromAnimal();
	if(getUnitType()				== NO_UNIT	)	        m_iUnitType							= pClassInfo->getUnitType();

    if(isCastAnySpell()             == false)               m_bCastAnySpell                     = pClassInfo->isCastAnySpell();
    if(isCivicDuration()            == false)               m_bCivicDuration                    = pClassInfo->isCivicDuration();
    if(isDestroyCivilization()      == false)               m_bDestroyCivilization              = pClassInfo->isDestroyCivilization();
    if(isDiscoverWholeMap()         == false)               m_bDiscoverWholeMap                 = pClassInfo->isDiscoverWholeMap();
    if(isGlobalEnchantment()        == false)               m_bGlobalEnchantment                = pClassInfo->isGlobalEnchantment();
    if(isGovannonsLegacy()          == false)               m_bGovannonsLegacy                  = pClassInfo->isGovannonsLegacy();
    if(isMazatlAmbushDeepJungle()   == false)               m_bMazatlAmbushDeepJungle           = pClassInfo->isMazatlAmbushDeepJungle();
    if(isNeverAdoptCivic()          == false)               m_bNeverAdoptCivic                  = pClassInfo->isNeverAdoptCivic();
    if(isSheaimSummonDemon()        == false)               m_bSheaimSummonDemon                = pClassInfo->isSheaimSummonDemon();
    if(isSpell()                    == false)               m_bSpell                            = pClassInfo->isSpell();
    if(isSpreadFeature()            == false)               m_bSpreadFeature                    = pClassInfo->isSpreadFeature();
    if(isUnitPromoted()             == false)               m_bUnitPromoted                     = pClassInfo->isUnitPromoted();
    if(getACabove()                 == -1)                  m_iACabove                          = pClassInfo->getACabove();
    if(getACbelow()                 == -1)                  m_iACbelow                          = pClassInfo->getACbelow();
	if(getUnitLevel()				== -1)	                m_iUnitLevel						= pClassInfo->getUnitLevel();
    if(getCivicType()               == NO_CIVIC)            m_iCivicType                        = pClassInfo->getCivicType();
    if(getCivilizationType()        == NO_CIVILIZATION)     m_iCivilizationType                 = pClassInfo->getCivilizationType();
    if(getFeatureType()             == NO_FEATURE)          m_iFeatureType                      = pClassInfo->getFeatureType();
    if(getReligionType()           == NO_RELIGION)         m_iReligionType                    = pClassInfo->getReligionType();
    if(getPromotionType()           == NO_PROMOTION)        m_iPromotionType                    = pClassInfo->getPromotionType();
    if(getPurityCounter()           == 0)                   m_iPurityCounter                    = pClassInfo->getPurityCounter();
    if(getRazeHolyCity()            == NO_RELIGION)         m_iRazeHolyCity                     = pClassInfo->getRazeHolyCity();
    if(getSpellType()               == NO_SPELL)            m_iSpellType                        = pClassInfo->getSpellType();

    if(isMimicPromotion()           == false)               m_bMimicPromotion                   = pClassInfo->isMimicPromotion();
    if(getNumBuildingOwned()        == 0)                   m_iNumBuildingOwned                 = pClassInfo->getNumBuildingOwned();
    if(getBuildingType()            == NO_BUILDING)         m_iBuildingType                     = pClassInfo->getBuildingType();

    if(isSpreadReligion()           == false)               m_bSpreadReligion                   = pClassInfo->isSpreadReligion();
    if(isKillHeroNetherblade()      == false)               m_bKillHeroNetherblade              = pClassInfo->isKillHeroNetherblade();
    if(isPaxPatria()                == false)               m_bPaxPatria                        = pClassInfo->isPaxPatria();
    if(isWorldUnitDefeated()        == false)               m_bWorldUnitDefeated                = pClassInfo->isWorldUnitDefeated();
    if(isCreateWorldWonder()        == false)               m_bCreateWorldWonder                = pClassInfo->isCreateWorldWonder();
    if(isLeadOvercouncil()          == false)               m_bLeadOvercouncil                  = pClassInfo->isLeadOvercouncil();
    if(isLeadUndercouncil()         == false)               m_bLeadUndercouncil                 = pClassInfo->isLeadUndercouncil();
    if(isDeclareWarAtFriendly()     == false)               m_bDeclareWarAtFriendly             = pClassInfo->isDeclareWarAtFriendly();
    if(isNeverLooseCity()           == false)               m_bNeverLooseCity                   = pClassInfo->isNeverLooseCity();
    if(isConvertAllCivs()           == false)               m_bConvertAllCivs                   = pClassInfo->isConvertAllCivs();
    if(isDeclareWar()               == false)               m_bDeclareWar                       = pClassInfo->isDeclareWar();

    if(getCapitalPopulation()       == -1)                  m_iCapitalPopulation                = pClassInfo->getCapitalPopulation();
    if(getGoldTreasury()            == -1)                  m_iGoldTreasury                     = pClassInfo->getGoldTreasury();
    if(getUnitCount()               == -1)                  m_iUnitCount                        = pClassInfo->getUnitCount();
    if(getNumUnitsOwned()           == -1)                  m_iNumUnitsOwned                    = pClassInfo->getNumUnitsOwned();
    if(getNumBonusOwned()           == -1)                  m_iNumBonusOwned                    = pClassInfo->getNumBonusOwned();
    if(getBonusType()               == NO_BONUS)            m_iBonusType                        = pClassInfo->getBonusType();

    if(isRemoveReligionFromAllCities()== false)             m_bRemoveReligionFromAllCities      = pClassInfo->isRemoveReligionFromAllCities();
    if(isLanunCaptureShip()          == false)              m_bLanunCaptureShip                 = pClassInfo->isLanunCaptureShip();
    if(isPlunderGold()               == false)              m_bPlunderGold                      = pClassInfo->isPlunderGold();

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/**	ADDON (Mana Schools) Sephi                                                      					**/
CvManaschoolInfo::CvManaschoolInfo() :
m_iBonusSummonStrength(NO_BONUS),
m_iBonusReducedTerraformCost(NO_BONUS),
m_iBonusIncreasedSpellResearch(NO_BONUS),
m_iBonusReducedGlobalEnchantment(NO_BONUS),
m_iBonusIncreasedTerraformEffect(NO_BONUS),
m_iBonusIncreasedMana(NO_BONUS),

m_pbBonusLinked(NULL),
m_piTechLevel(NULL),
m_piSpellResearchAlignmentMod(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvMissionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvManaschoolInfo::~CvManaschoolInfo()
{
    SAFE_DELETE_ARRAY(m_pbBonusLinked);
    SAFE_DELETE_ARRAY(m_piTechLevel);
    SAFE_DELETE_ARRAY(m_piSpellResearchAlignmentMod);
}
int CvManaschoolInfo::getBonusSummonStrength() const { return m_iBonusSummonStrength;}
int CvManaschoolInfo::getBonusReducedTerraformCost() const{ return m_iBonusReducedTerraformCost;}
int CvManaschoolInfo::getBonusIncreasedSpellResearch() const{ return m_iBonusIncreasedSpellResearch;}
int CvManaschoolInfo::getBonusReducedGlobalEnchantment() const{ return m_iBonusReducedGlobalEnchantment;}
int CvManaschoolInfo::getBonusIncreasedTerraformEffect() const{ return m_iBonusIncreasedTerraformEffect;}
int CvManaschoolInfo::getBonusIncreasedMana() const{ return m_iBonusIncreasedMana;}

bool CvManaschoolInfo::isBonusLinked(int iBonus) const { return m_pbBonusLinked[iBonus];}
int CvManaschoolInfo::getTechLevel(int iTech) const { return m_piTechLevel[iTech];}
int CvManaschoolInfo::getSpellResearchAlignmentMod(int iAlignment) const { return m_piSpellResearchAlignmentMod[iAlignment];}

const TCHAR* CvManaschoolInfo::getPicture() const 
{
	if(m_szPicture.IsEmpty()) {
		return NULL;
	}

	return m_szPicture;
}

void CvManaschoolInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvManaschoolInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvManaschoolInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTmp;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}
    pXML->GetChildXmlValByName(szTmp, "BonusSummonStrength");
    m_iBonusSummonStrength = pXML->FindInInfoClass(szTmp);
    pXML->GetChildXmlValByName(szTmp, "BonusReducedTerraformCost");
    m_iBonusReducedTerraformCost = pXML->FindInInfoClass(szTmp);
    pXML->GetChildXmlValByName(szTmp, "BonusIncreasedSpellResearch");
    m_iBonusIncreasedSpellResearch = pXML->FindInInfoClass(szTmp);
    pXML->GetChildXmlValByName(szTmp, "BonusReducedGlobalEnchantment");
    m_iBonusReducedGlobalEnchantment = pXML->FindInInfoClass(szTmp);
    pXML->GetChildXmlValByName(szTmp, "BonusIncreasedTerraformEffect");
    m_iBonusIncreasedTerraformEffect = pXML->FindInInfoClass(szTmp);
    pXML->GetChildXmlValByName(szTmp, "BonusIncreasedMana");
    m_iBonusIncreasedMana = pXML->FindInInfoClass(szTmp);

	pXML->GetChildXmlValByName(m_szPicture, "Picture");

    pXML->SetVariableListTagPair(&m_pbBonusLinked,"BonusLinked", sizeof(GC.getBonusInfo((BonusTypes)0)),GC.getNumBonusInfos());
    pXML->SetVariableListTagPair(&m_piTechLevel,"TechLevels", sizeof(GC.getTechInfo((TechTypes)0)),GC.getNumTechInfos());
    pXML->SetVariableListTagPair(&m_piSpellResearchAlignmentMod,"SpellResearchAlignmentMods", sizeof(GC.getAlignmentInfo((AlignmentTypes)0)),GC.getNumAlignmentInfos());
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvManaschoolInfo::copyNonDefaults(CvManaschoolInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

    if(getBonusSummonStrength()               == NO_BONUS)            m_iBonusSummonStrength                        = pClassInfo->getBonusSummonStrength();
    if(getBonusReducedTerraformCost()         == NO_BONUS)            m_iBonusReducedTerraformCost                  = pClassInfo->getBonusReducedTerraformCost();
    if(getBonusIncreasedSpellResearch()       == NO_BONUS)            m_iBonusIncreasedSpellResearch                = pClassInfo->getBonusIncreasedSpellResearch();
    if(getBonusReducedGlobalEnchantment()     == NO_BONUS)            m_iBonusReducedGlobalEnchantment              = pClassInfo->getBonusReducedGlobalEnchantment();
    if(getBonusIncreasedTerraformEffect()     == NO_BONUS)            m_iBonusIncreasedTerraformEffect              = pClassInfo->getBonusIncreasedTerraformEffect();
    if(getBonusIncreasedMana()				  == NO_BONUS)            m_iBonusIncreasedMana                         = pClassInfo->getBonusIncreasedMana();

	if(getPicture()                           == cDefault)            m_szPicture                                  = pClassInfo->getPicture();

	for (int i = 0; i < GC.getNumBonusInfos(); i++)
	{
	    if(isBonusLinked(i)   == false)           m_pbBonusLinked[i]         = pClassInfo->isBonusLinked(i);
	}

	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
	    if(getTechLevel(i)   == 0)           m_piTechLevel[i]         = pClassInfo->getTechLevel(i);
	}

	for (int i = 0; i < GC.getNumAlignmentInfos(); i++)
	{
	    if(getSpellResearchAlignmentMod(i)   == 0)           m_piSpellResearchAlignmentMod[i]         = pClassInfo->getSpellResearchAlignmentMod(i);
	}
}

/**	ADDON (CombatAuras) Sephi                                                      					**/
CvCombatAuraInfo::CvCombatAuraInfo() :
m_bBlessing(false),
m_bPrereqAlive(false),
m_iCombatAuraClassType(0),

m_iPrereqPromotion(NO_PROMOTION),
m_iPrereqUnitClass(NO_PROMOTION),
m_iPrereqUnitCombat(NO_PROMOTION),
m_iRange(0),
m_iTier(0),
m_iTargets(0),

m_iFear(0),
m_iStrength(0),

m_iAlignmentType(NO_ALIGNMENT),
m_iAttackAlignmentBonus(0),
m_iAttackPromotionBonus(0),
m_iCityAttack(0),
m_iDamage(0),
m_iDamageType(NO_DAMAGE),
m_iExperience(0),
m_iFirststrikes(0),
m_iGoldFromCombat(0),
m_iGuardianAngel(0),
m_iHealing(0),
m_iHealthRegeneration(0),
m_iIgnoreFirststrikes(0),
m_iMagicResistance(0),
m_iSpellPower(0),
m_iPromotionType(NO_PROMOTION),
m_iRust(0),
m_iSpellcasterXP(0),
m_iUpgradePercent(0),

m_pbPromotionApply(NULL),
m_pbPromotionRemove(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCombatAuraInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCombatAuraInfo::~CvCombatAuraInfo()
{
}
bool CvCombatAuraInfo::isBlessing() const { return m_bBlessing;}
bool CvCombatAuraInfo::isPrereqAlive() const { return m_bPrereqAlive;}
int CvCombatAuraInfo::getStrength() const { return m_iStrength;}
int CvCombatAuraInfo::getCombatAuraClassType() const { return m_iCombatAuraClassType;}
int CvCombatAuraInfo::getFear() const { return m_iFear;}
int CvCombatAuraInfo::getPrereqPromotion() const { return m_iPrereqPromotion;}
int CvCombatAuraInfo::getPrereqUnitClass() const { return m_iPrereqUnitClass;}
int CvCombatAuraInfo::getPrereqUnitCombat() const { return m_iPrereqUnitCombat;}
int CvCombatAuraInfo::getRange() const { return m_iRange;}
int CvCombatAuraInfo::getTier() const { return m_iTier;}
int CvCombatAuraInfo::getTargets() const { return m_iTargets;}

int CvCombatAuraInfo::getAlignmentType() const { return m_iAlignmentType;}
int CvCombatAuraInfo::getAttackAlignmentBonus() const { return m_iAttackAlignmentBonus;}
int CvCombatAuraInfo::getAttackPromotionBonus() const { return m_iAttackPromotionBonus;}
int CvCombatAuraInfo::getCityAttack() const { return m_iCityAttack;}
int CvCombatAuraInfo::getDamage() const { return m_iDamage;}
int CvCombatAuraInfo::getDamageType() const { return m_iDamageType;}
int CvCombatAuraInfo::getExperience() const { return m_iExperience;}
int CvCombatAuraInfo::getFirststrikes() const { return m_iFirststrikes;}
int CvCombatAuraInfo::getGoldFromCombat() const { return m_iGoldFromCombat;}
int CvCombatAuraInfo::getGuardianAngel() const { return m_iGuardianAngel;}
int CvCombatAuraInfo::getHealing() const { return m_iHealing;}
int CvCombatAuraInfo::getHealthRegeneration() const { return m_iHealthRegeneration;}
int CvCombatAuraInfo::getIgnoreFirststrikes() const { return m_iIgnoreFirststrikes;}
int CvCombatAuraInfo::getMagicResistance() const { return m_iMagicResistance;}
int CvCombatAuraInfo::getSpellPower() const { return m_iSpellPower;}
int CvCombatAuraInfo::getPromotionType() const { return m_iPromotionType;}
int CvCombatAuraInfo::getRust() const { return m_iRust;}
int CvCombatAuraInfo::getSpellcasterXP() const { return m_iSpellcasterXP;}
int CvCombatAuraInfo::getUpgradePercent() const { return m_iUpgradePercent;}

bool CvCombatAuraInfo::isPromotionApply(int iPromotion) const { return m_pbPromotionApply[iPromotion];}
bool CvCombatAuraInfo::isPromotionRemove(int iPromotion) const { return m_pbPromotionRemove[iPromotion];}

void CvCombatAuraInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvCombatAuraInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvCombatAuraInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

    pXML->GetChildXmlValByName(&m_bBlessing, "bBlessing");
    pXML->GetChildXmlValByName(&m_bPrereqAlive, "bPrereqAlive");

    pXML->GetChildXmlValByName(&m_iStrength, "iStrength");
    pXML->GetChildXmlValByName(szTextVal, "CombatAuraClassType");
    m_iCombatAuraClassType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iFear, "iFear");
    pXML->GetChildXmlValByName(szTextVal, "PrereqPromotion");
    m_iPrereqPromotion = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "PrereqUnitClass");
    m_iPrereqUnitClass = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "PrereqUnitCombat");
    m_iPrereqUnitCombat = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iRange, "iRange");
    pXML->GetChildXmlValByName(&m_iTier, "iTier");
    pXML->GetChildXmlValByName(&m_iTargets, "iTargets");

    pXML->GetChildXmlValByName(szTextVal, "AlignmentType");
    m_iAlignmentType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iAttackAlignmentBonus, "iAttackAlignmentBonus");
    pXML->GetChildXmlValByName(&m_iAttackPromotionBonus, "iAttackPromotionBonus");
    pXML->GetChildXmlValByName(&m_iCityAttack, "iCityAttack");
    pXML->GetChildXmlValByName(&m_iDamage, "iDamage");
    pXML->GetChildXmlValByName(szTextVal, "DamageType");
    m_iDamageType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iExperience, "iExperience");
    pXML->GetChildXmlValByName(&m_iFirststrikes, "iFirststrikes");
    pXML->GetChildXmlValByName(&m_iGoldFromCombat, "iGoldFromCombat");
    pXML->GetChildXmlValByName(&m_iGuardianAngel, "iGuardianAngel");
    pXML->GetChildXmlValByName(&m_iHealing, "iHealing");
    pXML->GetChildXmlValByName(&m_iHealthRegeneration, "iHealthRegeneration");
    pXML->GetChildXmlValByName(&m_iIgnoreFirststrikes, "iIgnoreFirststrikes");
    pXML->GetChildXmlValByName(&m_iMagicResistance, "iMagicResistance");
    pXML->GetChildXmlValByName(&m_iSpellPower, "iSpellPower");
    pXML->GetChildXmlValByName(szTextVal, "PromotionType");
    m_iPromotionType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iRust, "iRust");
    pXML->GetChildXmlValByName(&m_iSpellcasterXP, "iSpellcasterXP");
    pXML->GetChildXmlValByName(&m_iUpgradePercent, "iUpgradePercent");

    pXML->SetVariableListTagPair(&m_pbPromotionApply,"PromotionsApply", sizeof(GC.getPromotionInfo((PromotionTypes)0)),GC.getNumPromotionInfos());
    pXML->SetVariableListTagPair(&m_pbPromotionRemove,"PromotionsRemove", sizeof(GC.getPromotionInfo((PromotionTypes)0)),GC.getNumPromotionInfos());

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCombatAuraInfo::copyNonDefaults(CvCombatAuraInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

    if(isBlessing()== false)       m_bBlessing     = pClassInfo->isBlessing();
    if(isPrereqAlive()== false)    m_bPrereqAlive  = pClassInfo->isPrereqAlive();

	if(getCombatAuraClassType() == NO_COMBATAURACLASS) m_iCombatAuraClassType = pClassInfo->getCombatAuraClassType();
    if(getPrereqPromotion()  == NO_PROMOTION)      m_iPrereqPromotion = pClassInfo->getPrereqPromotion();
    if(getPrereqUnitClass()  == NO_UNITCLASS)      m_iPrereqUnitClass = pClassInfo->getPrereqUnitClass();
    if(getPrereqUnitCombat() == NO_UNITCOMBAT)     m_iPrereqUnitCombat= pClassInfo->getPrereqUnitCombat();
    if(getRange()  == 0)           m_iRange        = pClassInfo->getRange();
    if(getTier()   == 0)           m_iTier         = pClassInfo->getTier();
    if(getTargets()   == 0)        m_iTargets      = pClassInfo->getTargets();

	if(getStrength()  == 0)		   m_iStrength	   = pClassInfo->getStrength();
    if(getFear()   == 0)           m_iFear         = pClassInfo->getFear();

	if(getAlignmentType()  == NO_ALIGNMENT)	m_iAlignmentType	   = pClassInfo->getAlignmentType();
    if(getAttackAlignmentBonus()   == 0) m_iAttackAlignmentBonus = pClassInfo->getAttackAlignmentBonus();
	if(getAttackPromotionBonus()  == 0)	m_iAttackPromotionBonus	   = pClassInfo->getAttackPromotionBonus();
    if(getCityAttack()   == 0)     m_iCityAttack         = pClassInfo->getCityAttack();
	if(getDamage()  == 0)		   m_iDamage	   = pClassInfo->getDamage();
    if(getDamageType()   == NO_DAMAGE)           m_iDamageType         = pClassInfo->getDamageType();
	if(getExperience()  == 0)		   m_iExperience	   = pClassInfo->getExperience();
    if(getFirststrikes()   == 0)           m_iFirststrikes         = pClassInfo->getFirststrikes();
	if(getGoldFromCombat()  == 0)		   m_iGoldFromCombat	   = pClassInfo->getGoldFromCombat();
    if(getGuardianAngel()   == 0)           m_iGuardianAngel         = pClassInfo->getGuardianAngel();
	if(getHealing()  == 0)		   m_iHealing	   = pClassInfo->getHealing();
    if(getHealthRegeneration()   == 0)           m_iHealthRegeneration         = pClassInfo->getHealthRegeneration();
	if(getIgnoreFirststrikes()  == 0)		   m_iIgnoreFirststrikes	   = pClassInfo->getIgnoreFirststrikes();
    if(getMagicResistance()   == 0)           m_iMagicResistance         = pClassInfo->getMagicResistance();
    if(getSpellPower()   == 0)           m_iSpellPower         = pClassInfo->getSpellPower();
	if(getPromotionType()  == NO_PROMOTION)		   m_iPromotionType	   = pClassInfo->getPromotionType();
    if(getRust()   == 0)           m_iRust         = pClassInfo->getRust();
	if(getSpellcasterXP()  == 0)		   m_iSpellcasterXP	   = pClassInfo->getSpellcasterXP();
    if(getUpgradePercent()   == 0)           m_iUpgradePercent         = pClassInfo->getUpgradePercent();

	for (int i = 0; i < GC.getNumPromotionInfos(); i++)
	{
	    if(isPromotionApply(i)   == false) m_pbPromotionApply[i] = pClassInfo->isPromotionApply(i);
	    if(isPromotionRemove(i)   == false) m_pbPromotionRemove[i] = pClassInfo->isPromotionRemove(i);
	}

}


CvCombatAuraClassInfo::CvCombatAuraClassInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCombatAuraInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCombatAuraClassInfo::~CvCombatAuraClassInfo()
{
}

void CvCombatAuraClassInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvCombatAuraClassInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvCombatAuraClassInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTmp;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCombatAuraClassInfo::copyNonDefaults(CvCombatAuraClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);
}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

//======================================================================================================
//					CvEquipmentCategoryInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvEquipmentCategoryInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvEquipmentCategoryInfo::CvEquipmentCategoryInfo() :
m_iMinLevel(0)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvEquipmentCategoryInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvEquipmentCategoryInfo::~CvEquipmentCategoryInfo()
{
}

int CvEquipmentCategoryInfo::getMinLevel() const { return m_iMinLevel; }

void CvEquipmentCategoryInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvEquipmentCategoryInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvEquipmentCategoryInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iMinLevel, "iMinLevel");

	return true;
}

void CvEquipmentCategoryInfo::copyNonDefaults(CvEquipmentCategoryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getMinLevel()				== 0)		m_iMinLevel			= pClassInfo->getMinLevel();
}

//======================================================================================================
//					CvDurabilityInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvDurabilityInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvDurabilityInfo::CvDurabilityInfo() :
m_iValue(0),
m_iValidByTier(0)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDurabilityInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvDurabilityInfo::~CvDurabilityInfo()
{
}

int CvDurabilityInfo::getValue() const { return m_iValue; }
int CvDurabilityInfo::getValidByTier() const { return m_iValidByTier; }

void CvDurabilityInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvDurabilityInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvDurabilityInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iValue, "iValue");
	pXML->GetChildXmlValByName(&m_iValidByTier, "iValidByTier");

	return true;
}

void CvDurabilityInfo::copyNonDefaults(CvDurabilityInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getValue()				== 0)						m_iValue			= pClassInfo->getValue();
	if (getValidByTier()		== 0)						m_iValidByTier		= pClassInfo->getValidByTier();
}

//======================================================================================================
//					CvDungeonInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvDungeonInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvDungeonInfo::CvDungeonInfo() :
m_pbLairResult(NULL),
m_iImprovementType(NO_IMPROVEMENT)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDungeonInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvDungeonInfo::~CvDungeonInfo()
{
	SAFE_DELETE_ARRAY(m_pbLairResult);
}

int CvDungeonInfo::getImprovementType() const { return m_iImprovementType; }

bool CvDungeonInfo::isLairResult(int iLairResult) const 
{ 
	FAssertMsg(iLairResult>=0,"Invalid Call of CvLairResultInfo::isLairResult");
	FAssertMsg(iLairResult<GC.getNumLairResultInfos(),"Invalid Call of CvLairResultInfo::isLairResult");
	return m_pbLairResult[iLairResult]; 
}

void CvDungeonInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvDungeonInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvDungeonInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->SetVariableListTagPair(&m_pbLairResult,"LairResults", sizeof(GC.getLairResultInfo((LairResultTypes)0)), GC.getNumLairResultInfos());
    pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
    m_iImprovementType = pXML->FindInInfoClass(szTextVal);

	return true;
}

void CvDungeonInfo::copyNonDefaults(CvDungeonInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getImprovementType()				== NO_IMPROVEMENT)				m_iImprovementType			= pClassInfo->getImprovementType();
	for(int iI=0;iI<GC.getNumLairResultInfos();iI++)
	{
		if (isLairResult(iI)				== false)						m_pbLairResult[iI]			= pClassInfo->isLairResult(iI);
	}
}

//======================================================================================================
//					CvUnitCombatInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitCombatInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvUnitCombatInfo::CvUnitCombatInfo() :
m_bArcherSupport(false),
m_bDefensiveBonuses(false),
m_bCityDefensiveBonuses(false),
m_bNoPromotions(false),
m_iCityAttack(0),
m_iWithdrawal(0)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDungeonEventInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvUnitCombatInfo::~CvUnitCombatInfo()
{
}

bool CvUnitCombatInfo::isArcherSupport() const { return m_bArcherSupport; }
bool CvUnitCombatInfo::isCityDefensiveBonuses() const { return m_bCityDefensiveBonuses; }
bool CvUnitCombatInfo::isDefensiveBonuses() const { return m_bDefensiveBonuses; }
bool CvUnitCombatInfo::isNoPromotions() const { return m_bNoPromotions; }
int CvUnitCombatInfo::getCityAttack() const { return m_iCityAttack; }
int CvUnitCombatInfo::getWithdrawal() const { return m_iWithdrawal; }

void CvUnitCombatInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvUnitCombatInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvUnitCombatInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

    pXML->GetChildXmlValByName(&m_bArcherSupport, "bArcherSupport");
    pXML->GetChildXmlValByName(&m_bCityDefensiveBonuses, "bCityDefensiveBonuses");
    pXML->GetChildXmlValByName(&m_bDefensiveBonuses, "bDefensiveBonuses");
	pXML->GetChildXmlValByName(&m_bNoPromotions, "bNoPromotions");
	pXML->GetChildXmlValByName(&m_iCityAttack, "iCityAttack");
	pXML->GetChildXmlValByName(&m_iWithdrawal, "iWithdrawal");
	

	return true;
}

void CvUnitCombatInfo::copyNonDefaults(CvUnitCombatInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isArcherSupport()			== false)				m_bArcherSupport		= pClassInfo->isArcherSupport();
	if (isDefensiveBonuses()		== false)				m_bDefensiveBonuses		= pClassInfo->isDefensiveBonuses();
	if (isCityDefensiveBonuses()	== false)				m_bCityDefensiveBonuses	= pClassInfo->isCityDefensiveBonuses();
	if (isNoPromotions()            == false)               m_bNoPromotions			= pClassInfo->isNoPromotions();
	if (getCityAttack()				==     0)				m_iCityAttack			= pClassInfo->getCityAttack();
	if (getWithdrawal()				==     0)				m_iWithdrawal			= pClassInfo->getWithdrawal();

}



//======================================================================================================
//					CvDungeonEventInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvDungeonEventInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvDungeonEventInfo::CvDungeonEventInfo() :
m_pbPrereqAttitude(NULL),
m_bPositive(false),
m_bThreaten(false),
m_bTaunt(false),
m_bConvert(false),
m_bDonateUnits(false),
m_iGold(0),
m_iPopulation(0),
m_iLeather(0),
m_iMetal(0),
m_iPowerChange(0),
m_iPopulationChange(0)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDungeonEventInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvDungeonEventInfo::~CvDungeonEventInfo()
{
	SAFE_DELETE_ARRAY(m_pbPrereqAttitude);
}

bool CvDungeonEventInfo::isThreaten() const { return m_bThreaten; }
bool CvDungeonEventInfo::isTaunt() const { return m_bTaunt; }
bool CvDungeonEventInfo::isConvert() const { return m_bConvert; }
bool CvDungeonEventInfo::isDonateUnits() const { return m_bDonateUnits; }
int CvDungeonEventInfo::getGold() const { return m_iGold; }
int CvDungeonEventInfo::getPopulation() const { return m_iPopulation; }
int CvDungeonEventInfo::getLeather() const { return m_iLeather; }
int CvDungeonEventInfo::getMetal() const { return m_iMetal; }
bool CvDungeonEventInfo::isPrereqAttitude(int i) const { return m_pbPrereqAttitude[i]; }
int CvDungeonEventInfo::getPowerChange() const { return m_iPowerChange; }
int CvDungeonEventInfo::getPopulationChange() const { return m_iPopulationChange; }

bool CvDungeonEventInfo::isPositive() const 
{ 
	return m_bPositive;
}

void CvDungeonEventInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvDungeonEventInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvDungeonEventInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

    pXML->GetChildXmlValByName(&m_bPositive, "bPositive");
    pXML->GetChildXmlValByName(&m_bTaunt, "bTaunt");
    pXML->GetChildXmlValByName(&m_bThreaten, "bThreaten");
    pXML->GetChildXmlValByName(&m_bConvert, "bConvert");
    pXML->GetChildXmlValByName(&m_bDonateUnits, "bDonateUnits");
    pXML->GetChildXmlValByName(&m_iGold, "iGold");
    pXML->GetChildXmlValByName(&m_iPopulation, "iPopulation");
    pXML->GetChildXmlValByName(&m_iLeather, "iLeather");
    pXML->GetChildXmlValByName(&m_iMetal, "iMetal");
    pXML->GetChildXmlValByName(&m_iPowerChange, "iPowerChange");
    pXML->GetChildXmlValByName(&m_iPopulationChange, "iPopulationChange");

	pXML->SetVariableListTagPair(&m_pbPrereqAttitude, "PrereqOrAttitudes", sizeof(GC.getAttitudeInfo((AttitudeTypes)0)), NUM_ATTITUDE_TYPES);

	return true;
}

void CvDungeonEventInfo::copyNonDefaults(CvDungeonEventInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isPositive()				== false)				m_bPositive			= pClassInfo->isPositive();
	if (isThreaten()				== false)				m_bThreaten			= pClassInfo->isThreaten();
	if (isTaunt()					== false)				m_bTaunt			= pClassInfo->isTaunt();
	if (isConvert()					== false)				m_bConvert			= pClassInfo->isConvert();
	if (isDonateUnits()				== false)				m_bDonateUnits		= pClassInfo->isDonateUnits();
	if (getGold()					== 0)					m_iGold				= pClassInfo->getGold();
	if (getPopulation()				== 0)					m_iPopulation		= pClassInfo->getPopulation();
	if (getLeather()				== 0)					m_iLeather			= pClassInfo->getLeather();
	if (getMetal()					== 0)					m_iMetal			= pClassInfo->getMetal();
	if (getPowerChange()			== 0)					m_iPowerChange		= pClassInfo->getPowerChange();
	if (getPopulationChange()		== 0)					m_iPopulationChange	= pClassInfo->getPopulationChange();

	for(int i = 0; i < NUM_ATTITUDE_TYPES; ++i) {
		if(isPrereqAttitude(i)      == false)				m_pbPrereqAttitude[i] = pClassInfo->isPrereqAttitude(i);
	}
}

//======================================================================================================
//					CvCityStateInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCityStateInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCityStateInfo::CvCityStateInfo() :
m_iCivilizationType(NO_CIVILIZATION),
m_iLeaderType(NO_LEADER),
m_iReligionType(NO_RELIGION),
m_bCoastal(false),
m_iNativeFeature(NO_FEATURE),
m_iNativeImprovement(NO_IMPROVEMENT),
m_iNativeTerrain(NO_TERRAIN)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCityStateInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCityStateInfo::~CvCityStateInfo()
{
}

int  CvCityStateInfo::getCivilizationType() const { return m_iCivilizationType; }
int  CvCityStateInfo::getLeaderType() const { return m_iLeaderType; }
int  CvCityStateInfo::getReligionType() const { return m_iReligionType; }
bool  CvCityStateInfo::isCoastal() const { return m_bCoastal; }
int  CvCityStateInfo::getNativeFeature() const { return m_iNativeFeature; }
int  CvCityStateInfo::getNativeImprovement() const { return m_iNativeImprovement; }
int  CvCityStateInfo::getNativeTerrain() const { return m_iNativeTerrain; }

void CvCityStateInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvCityStateInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvCityStateInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "CivilizationType");
    m_iCivilizationType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "LeaderType");
    m_iLeaderType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ReligionType");
    m_iReligionType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "NativeFeature");
    m_iNativeFeature = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "NativeImprovement");
    m_iNativeImprovement = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "NativeTerrain");
    m_iNativeTerrain = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_bCoastal, "bCoastal");

	return true;
}

void CvCityStateInfo::copyNonDefaults(CvCityStateInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getReligionType()		== NO_RELIGION)		m_iReligionType		= pClassInfo->getReligionType();
	if (getCivilizationType()		== NO_CIVILIZATION)		m_iCivilizationType		= pClassInfo->getCivilizationType();
	if (getLeaderType()		== NO_LEADER)		m_iLeaderType		= pClassInfo->getLeaderType();

	if (isCoastal()					== false)		m_bCoastal = pClassInfo->isCoastal();
	if (getNativeTerrain()		== NO_TERRAIN)		m_iNativeTerrain	= pClassInfo->getNativeTerrain();
	if (getNativeFeature()		== NO_FEATURE)		m_iNativeFeature	= pClassInfo->getNativeFeature();
	if (getNativeImprovement()	== NO_IMPROVEMENT)	m_iNativeImprovement= pClassInfo->getNativeImprovement();
}

//======================================================================================================
//					CvPlaneInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvPlaneInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvPlaneInfo::CvPlaneInfo() :
m_iNativeTerrainTypes(NULL),
m_iNativeFeatureTypes(NULL),
m_pbBonusSpawn(NULL),
m_bReplaceWaterWithPeaks(false),
m_bGoodies(false),
m_bNoRiver(false)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvPlaneInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvPlaneInfo::~CvPlaneInfo()
{
	SAFE_DELETE_ARRAY(m_iNativeTerrainTypes);
	SAFE_DELETE_ARRAY(m_iNativeFeatureTypes);
	SAFE_DELETE_ARRAY(m_pbBonusSpawn);
}

int CvPlaneInfo::getNativeTerrainType(int iTerrainClass) const
{
	FAssertMsg(iTerrainClass < GC.getNumTerrainClassInfos(), "Index out of bounds");
	FAssertMsg(iTerrainClass > -1, "Index out of bounds");
	return m_iNativeTerrainTypes ? m_iNativeTerrainTypes[iTerrainClass] : -1;
}

int CvPlaneInfo::getNativeFeatureType(int iFeatureClass) const
{
	FAssertMsg(iFeatureClass < GC.getNumFeatureClassInfos(), "Index out of bounds");
	FAssertMsg(iFeatureClass > -1, "Index out of bounds");
	return m_iNativeFeatureTypes ? m_iNativeFeatureTypes[iFeatureClass] : -1;
}

bool CvPlaneInfo::isBonusSpawn(int iBonus) const
{
	FAssertMsg(iBonus < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(iBonus > -1, "Index out of bounds");
	return m_pbBonusSpawn ? m_pbBonusSpawn[iBonus] : false;
}

bool CvPlaneInfo::isReplaceWaterWithPeaks() const
{
	return m_bReplaceWaterWithPeaks;
}

bool CvPlaneInfo::isGoodies() const
{
	return m_bGoodies;
}

bool CvPlaneInfo::isNoRiver() const
{
	return m_bNoRiver;
}

void CvPlaneInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvPlaneInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvPlaneInfo::read(CvXMLLoadUtility* pXML)
{
	char szClassVal[256];					// holds the text value of the relevant classinfo

	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bReplaceWaterWithPeaks, "bReplaceWaterWithPeaks");
	pXML->GetChildXmlValByName(&m_bGoodies, "bGoodies");	
	pXML->GetChildXmlValByName(&m_bNoRiver, "bNoRiver");
    pXML->SetVariableListTagPair(&m_pbBonusSpawn,"BonusesSpawn", sizeof(GC.getBonusInfo((BonusTypes)0)),GC.getNumBonusInfos());

	int iNumSibs;
	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Terrains"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default civilization buildings
			pXML->InitTerrainDefaults(&m_iNativeTerrainTypes);
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ( (0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())) )
			{
				int iTerrainClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumTerrainClassInfos()) ,"In SetGlobalPlaneInfo iNumSibs is greater than GC.getNumTerrainClassInfos()");

				// loop through all the siblings
				for (int j=0;j<iNumSibs;j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// get the index into the array based on the building class type
						iTerrainClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iTerrainClassIndex)
						{
							// get the next value which should be the building type to set this civilization's version of this building class too
							pXML->GetNextXmlVal( szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_iNativeTerrainTypes[iTerrainClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0,"TerrainClass index is -1 in SetGlobalCivilizationInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Features"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default civilization buildings
			pXML->InitTerrainDefaults(&m_iNativeFeatureTypes);
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ( (0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())) )
			{
				int iFeatureClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumFeatureClassInfos()) ,"In SetGlobalPlaneInfo iNumSibs is greater than GC.getNumTerrainClassInfos()");

				// loop through all the siblings
				for (int j=0;j<iNumSibs;j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// get the index into the array based on the building class type
						iFeatureClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iFeatureClassIndex)
						{
							// get the next value which should be the building type to set this civilization's version of this building class too
							pXML->GetNextXmlVal( szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_iNativeFeatureTypes[iFeatureClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0,"FeatureClass index is -1 in SetGlobalCivilizationInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}

void CvPlaneInfo::copyNonDefaults(CvPlaneInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	for ( int i = 0; i < GC.getNumTerrainClassInfos(); i++)
	{
		int iDefaultTerrain = GC.getTerrainClassInfo((TerrainClassTypes) i).getDefaultTerrainIndex();
		if (getNativeTerrainType(i)				== iDefaultTerrain)	m_iNativeTerrainTypes[i]			= pClassInfo->getNativeTerrainType(i);
	}

	for ( int i = 0; i < GC.getNumFeatureClassInfos(); i++)
	{
		int iDefaultFeature = GC.getFeatureClassInfo((FeatureClassTypes) i).getDefaultFeatureIndex();
		if (getNativeFeatureType(i)				== iDefaultFeature)	m_iNativeFeatureTypes[i]			= pClassInfo->getNativeFeatureType(i);
	}

	if (isReplaceWaterWithPeaks()				== false)	m_bReplaceWaterWithPeaks			= pClassInfo->isReplaceWaterWithPeaks();
	if (isGoodies()								== false)	m_bGoodies			= pClassInfo->isGoodies();
	if (isNoRiver()								== false)	m_bNoRiver			= pClassInfo->isNoRiver();

	for (int i = 0; i <GC.getNumBonusInfos(); i++)
	{
		if(isBonusSpawn(i)   == false)           m_pbBonusSpawn[i]         = pClassInfo->isBonusSpawn(i);
	}
}

//======================================================================================================
//					CvTerrainClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTerrainClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTerrainClassInfo::CvTerrainClassInfo() :
m_iDefaultTerrainIndex(NO_TERRAIN)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCityStateInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTerrainClassInfo::~CvTerrainClassInfo()
{
}

int  CvTerrainClassInfo::getDefaultTerrainIndex() const { return m_iDefaultTerrainIndex; }

void CvTerrainClassInfo::setDefaultTerrainIndex(int i)
{
	m_iDefaultTerrainIndex = i;
}

void CvTerrainClassInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvTerrainClassInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvTerrainClassInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "DefaultTerrain");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	return true;
}

bool CvTerrainClassInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iDefaultBuildingIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iTextDefault = -1;
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]) != iTextDefault)
		{
			m_iDefaultTerrainIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();

	return true;
}


void CvTerrainClassInfo::copyNonDefaults(CvTerrainClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);
}

//======================================================================================================
//					CvFeatureClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvFeatureClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvFeatureClassInfo::CvFeatureClassInfo() :
m_iDefaultFeatureIndex(NO_FEATURE)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvFeatureInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvFeatureClassInfo::~CvFeatureClassInfo()
{
}

int  CvFeatureClassInfo::getDefaultFeatureIndex() const { return m_iDefaultFeatureIndex; }

void CvFeatureClassInfo::setDefaultFeatureIndex(int i)
{
	m_iDefaultFeatureIndex = i;
}

void CvFeatureClassInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvFeatureClassInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvFeatureClassInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "DefaultFeature");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	return true;
}

bool CvFeatureClassInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iDefaultBuildingIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iTextDefault = -1;
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]) != iTextDefault)
		{
			m_iDefaultFeatureIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();

	return true;
}


void CvFeatureClassInfo::copyNonDefaults(CvFeatureClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);
}

//======================================================================================================
//					CvCitySpecializationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCitySpecializationInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCitySpecializationInfo::CvCitySpecializationInfo() :
m_iCivilizationType(NO_CIVILIZATION)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCitySpecializationInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCitySpecializationInfo::~CvCitySpecializationInfo()
{
}

int  CvCitySpecializationInfo::getCivilizationType() const { return m_iCivilizationType; }

void CvCitySpecializationInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvCitySpecializationInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvCitySpecializationInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "CivilizationType");
    m_iCivilizationType = pXML->FindInInfoClass(szTextVal);

	return true;
}

void CvCitySpecializationInfo::copyNonDefaults(CvCitySpecializationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getCivilizationType()		== NO_CIVILIZATION)		m_iCivilizationType		= pClassInfo->getCivilizationType();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvLairResultInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvLairResultInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvLairResultInfo::CvLairResultInfo() :
m_iValue(0),
m_iWeight(0),
m_iGameTurnMod(100)
{
}
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvLairResultInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvLairResultInfo::~CvLairResultInfo()
{
}

const TCHAR* CvLairResultInfo::getPyResult() const { return m_szPyResult; }
const TCHAR* CvLairResultInfo::getPyRequirement() const { return m_szPyRequirement; }
int CvLairResultInfo::getValue() const { return m_iValue;}
int CvLairResultInfo::getGameTurnMod() const { return m_iGameTurnMod;}
int CvLairResultInfo::getWeight() const { return m_iWeight;}
void CvLairResultInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

}

void CvLairResultInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag = 0;
	stream->Write(uiFlag);		// flag for expansion

}

bool CvLairResultInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szPyResult, "PyResult");
	pXML->GetChildXmlValByName(m_szPyRequirement, "PyRequirement");
	pXML->GetChildXmlValByName(&m_iValue, "iValue");
	pXML->GetChildXmlValByName(&m_iWeight, "iWeight",100);
	pXML->GetChildXmlValByName(&m_iGameTurnMod, "iGameTurnMod",100);

	return true;
}

void CvLairResultInfo::copyNonDefaults(CvLairResultInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getPyResult()				== cDefault)			m_szPyResult			= pClassInfo->getPyResult();
	if (getPyRequirement()			== cDefault)			m_szPyRequirement		= pClassInfo->getPyRequirement();
	if (getValue()					== 0)					m_iValue			= pClassInfo->getValue();
	if (getWeight()					== 100)					m_iWeight			= pClassInfo->getWeight();
	if (getGameTurnMod()			== 100)					m_iGameTurnMod			= pClassInfo->getGameTurnMod();
}

/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvMissionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvMissionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvMissionInfo::CvMissionInfo() :
m_iTime(0),
m_bSound(false),
m_bTarget(false),
m_bBuild(false),
m_bVisible(false),
m_eEntityEvent(ENTITY_EVENT_NONE)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvMissionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvMissionInfo::~CvMissionInfo()
{
}

int CvMissionInfo::getTime() const
{
	return m_iTime;
}

bool CvMissionInfo::isSound() const
{
	return m_bSound;
}

bool CvMissionInfo::isTarget() const
{
	return m_bTarget;
}

bool CvMissionInfo::isBuild() const
{
	return m_bBuild;
}

bool CvMissionInfo::getVisible() const
{
	return m_bVisible;
}

const TCHAR* CvMissionInfo::getWaypoint() const
{
	return m_szWaypoint;
}

EntityEventTypes CvMissionInfo::getEntityEvent() const
{
	return m_eEntityEvent;
}

bool CvMissionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTmp;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szWaypoint, "Waypoint");
	pXML->GetChildXmlValByName(&m_iTime, "iTime");
	pXML->GetChildXmlValByName(&m_bSound, "bSound");
	pXML->GetChildXmlValByName(&m_bTarget, "bTarget");
	pXML->GetChildXmlValByName(&m_bBuild, "bBuild");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	if ( pXML->GetChildXmlValByName(szTmp, "EntityEventType") )
	{
		m_eEntityEvent = (EntityEventTypes)pXML->FindInInfoClass(szTmp);
	}
	else
	{
		m_eEntityEvent = ENTITY_EVENT_NONE;
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvMissionInfo::copyNonDefaults(CvMissionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getTime()				== 0)						m_iTime			= pClassInfo->getTime();
	if (isSound()				== false)					m_bSound		= pClassInfo->isSound();
	if (isTarget()				== false)					m_bTarget		= pClassInfo->isTarget();
	if (isBuild()				== false)					m_bBuild		= pClassInfo->isBuild();
	if (getVisible()			== false)					m_bVisible		= pClassInfo->getVisible();
	if (getEntityEvent()		== ENTITY_EVENT_NONE)		m_eEntityEvent	= pClassInfo->getEntityEvent();
	if (getWaypoint()			== cDefault)				m_szWaypoint	= pClassInfo->getWaypoint();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvControlInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvControlInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvControlInfo::CvControlInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvControlInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvControlInfo::~CvControlInfo()
{
}

bool CvControlInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvControlInfo::copyNonDefaults(CvControlInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCommandInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCommandInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCommandInfo::CvCommandInfo() :
m_iAutomate(NO_AUTOMATE),
m_bConfirmCommand(false),
m_bVisible(false),
m_bAll(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCommandInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCommandInfo::~CvCommandInfo()
{
}

int CvCommandInfo::getAutomate() const
{
	return m_iAutomate;
}

void CvCommandInfo::setAutomate(int i)
{
	m_iAutomate = i;
}

bool CvCommandInfo::getConfirmCommand() const
{
	return m_bConfirmCommand;
}

bool CvCommandInfo::getVisible() const
{
	return m_bVisible;
}

bool CvCommandInfo::getAll() const
{
	return m_bAll;
}

bool CvCommandInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	if (pXML->GetChildXmlValByName(szTextVal, "Automate"))
	{
		setAutomate(GC.getTypesEnum(szTextVal));
	}

	pXML->GetChildXmlValByName(&m_bConfirmCommand, "bConfirmCommand");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");
	pXML->GetChildXmlValByName(&m_bAll, "bAll");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCommandInfo::copyNonDefaults(CvCommandInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getAutomate()		== NO_AUTOMATE)		setAutomate(		pClassInfo->getAutomate());
	if (getConfirmCommand()	== false)			m_bConfirmCommand	= pClassInfo->getConfirmCommand();
	if (getVisible()		== false)			m_bVisible			= pClassInfo->getVisible();
	if (getAll()			== false)			m_bAll				= pClassInfo->getAll();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAutomateInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAutomateInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAutomateInfo::CvAutomateInfo() :
m_iCommand(NO_COMMAND),
m_iAutomate(NO_AUTOMATE),
m_bConfirmCommand(false),
m_bVisible(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAutomateInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAutomateInfo::~CvAutomateInfo()
{
}

int CvAutomateInfo::getCommand() const
{
	return m_iCommand;
}

void CvAutomateInfo::setCommand(int i)
{
	m_iCommand = i;
}

int CvAutomateInfo::getAutomate() const
{
	return m_iAutomate;
}

void CvAutomateInfo::setAutomate(int i)
{
	m_iAutomate = i;
}

bool CvAutomateInfo::getConfirmCommand() const
{
	return m_bConfirmCommand;
}

bool CvAutomateInfo::getVisible() const
{
	return m_bVisible;
}

bool CvAutomateInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Command");
	setCommand(pXML->FindInInfoClass(szTextVal));

	pXML->GetChildXmlValByName(szTextVal, "Automate");
	setAutomate(GC.getTypesEnum(szTextVal));

	pXML->GetChildXmlValByName(&m_bConfirmCommand, "bConfirmCommand");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAutomateInfo::copyNonDefaults(CvAutomateInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getCommand()		== NO_COMMAND)		setCommand(			pClassInfo->getCommand());
	if (getAutomate()		== NO_AUTOMATE)		setAutomate(		pClassInfo->getAutomate());
	if (getConfirmCommand()	== false)			m_bConfirmCommand	= pClassInfo->getConfirmCommand();
	if (getVisible()		== false)			m_bVisible			= pClassInfo->getVisible();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvActionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvActionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvActionInfo::CvActionInfo() :
m_iOriginalIndex(-1),
m_eSubType(NO_ACTIONSUBTYPE)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvActionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvActionInfo::~CvActionInfo()
{
}

int CvActionInfo::getMissionData() const
{

	if	(
				(ACTIONSUBTYPE_BUILD == m_eSubType)				||
				(ACTIONSUBTYPE_RELIGION == m_eSubType)		||
				(ACTIONSUBTYPE_CORPORATION == m_eSubType)		||
				(ACTIONSUBTYPE_SPECIALIST == m_eSubType)	||
				(ACTIONSUBTYPE_BUILDING == m_eSubType)
			)
	{
		return m_iOriginalIndex;
	}

	return -1;
}

int CvActionInfo::getCommandData() const
{

	if	(
				(ACTIONSUBTYPE_PROMOTION == m_eSubType)	||
				(ACTIONSUBTYPE_UNIT == m_eSubType)

//FfH Spell System: Added by Kael 07/23/2007
				|| (ACTIONSUBTYPE_SPELL == m_eSubType)
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (automatic Spellcasting) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
                || (ACTIONSUBTYPE_AUTOMATE_SPELL == m_eSubType)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
			)
	{
		return m_iOriginalIndex;
	}
	else if (ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getAutomate();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getAutomate();
	}

	return -1;
}

int CvActionInfo::getAutomateType() const
{

	if (ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getAutomate();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getAutomate();
	}

	return NO_AUTOMATE;
}

int CvActionInfo::getInterfaceModeType() const
{
	if (ACTIONSUBTYPE_INTERFACEMODE == m_eSubType)
	{
		return m_iOriginalIndex;
	}
/*************************************************************************************************/
/**	ADDON(INTERFACEMODE_SPELL_OFFENSIVE) Sephi					                                                        **/
/*************************************************************************************************/
	if( ACTIONSUBTYPE_SPELL == m_eSubType)
	{
		if(GC.getSpellInfo((SpellTypes)m_iOriginalIndex).isTargetedHostile())
		{
			return INTERFACEMODE_SPELL_OFFENSIVE;
		}
	}
/*************************************************************************************************/
/**	END                                                                                         **/
/*************************************************************************************************/
	return NO_INTERFACEMODE;
}

int CvActionInfo::getMissionType() const
{
	if (ACTIONSUBTYPE_BUILD == m_eSubType)
	{
		return GC.getBuildInfo((BuildTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_RELIGION == m_eSubType)
	{
		return GC.getReligionInfo((ReligionTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_CORPORATION == m_eSubType)
	{
		return GC.getCorporationInfo((CorporationTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_SPECIALIST == m_eSubType)
	{
		return GC.getSpecialistInfo((SpecialistTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_BUILDING == m_eSubType)
	{
		return GC.getBuildingInfo((BuildingTypes)m_iOriginalIndex).getMissionType();
	}
	else if (ACTIONSUBTYPE_MISSION == m_eSubType)
	{
		return m_iOriginalIndex;
	}

	return NO_MISSION;
}

int CvActionInfo::getCommandType() const
{
	if (ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return m_iOriginalIndex;
	}
	else if (ACTIONSUBTYPE_PROMOTION == m_eSubType)
	{
		return GC.getPromotionInfo((PromotionTypes)m_iOriginalIndex).getCommandType();
	}
	else if (ACTIONSUBTYPE_UNIT == m_eSubType)
	{
		return GC.getUnitInfo((UnitTypes)m_iOriginalIndex).getCommandType();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getCommand();
	}

//FfH Spell System: Added by Kael 07/23/2007
	else if (ACTIONSUBTYPE_SPELL == m_eSubType )
	{
		return GC.getSpellInfo((SpellTypes)m_iOriginalIndex).getCommandType();
	}
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (automatic spellcasting) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	else if (ACTIONSUBTYPE_AUTOMATE_SPELL == m_eSubType )
	{
		return COMMAND_AUTOMATE_SPELL;
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	return NO_COMMAND;
}

int CvActionInfo::getControlType() const
{
	if (ACTIONSUBTYPE_CONTROL == m_eSubType)
	{
		return m_iOriginalIndex;
	}
	return -1;
}

int CvActionInfo::getOriginalIndex() const
{
	return m_iOriginalIndex;
}

void CvActionInfo::setOriginalIndex(int i)
{
	m_iOriginalIndex = i;
}

bool CvActionInfo::isConfirmCommand() const
{
	if	(ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getConfirmCommand();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getConfirmCommand();
	}

	return false;
}

bool CvActionInfo::isVisible() const
{

	if (ACTIONSUBTYPE_CONTROL == m_eSubType)
	{
		return false;
	}
	else if	(ACTIONSUBTYPE_COMMAND == m_eSubType)
	{
		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex).getVisible();
	}
	else if (ACTIONSUBTYPE_AUTOMATE == m_eSubType)
	{
		return GC.getAutomateInfo(m_iOriginalIndex).getVisible();
	}
	else if (ACTIONSUBTYPE_MISSION == m_eSubType)
	{
		return GC.getMissionInfo((MissionTypes)m_iOriginalIndex).getVisible();
	}
	else if (ACTIONSUBTYPE_INTERFACEMODE== m_eSubType)
	{
		return GC.getInterfaceModeInfo((InterfaceModeTypes)m_iOriginalIndex).getVisible();
	}

	return true;
}

ActionSubTypes CvActionInfo::getSubType() const
{
	return m_eSubType;
}

void CvActionInfo::setSubType(ActionSubTypes eSubType)
{
	m_eSubType = eSubType;
}

CvHotkeyInfo* CvActionInfo::getHotkeyInfo() const
{
	switch (getSubType())
	{
		case ACTIONSUBTYPE_INTERFACEMODE:
			return &GC.getInterfaceModeInfo((InterfaceModeTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_COMMAND:
			return &GC.getCommandInfo((CommandTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_BUILD:
			return &GC.getBuildInfo((BuildTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_PROMOTION:
			return &GC.getPromotionInfo((PromotionTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_UNIT:
			return &GC.getUnitInfo((UnitTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_RELIGION:
			return &GC.getReligionInfo((ReligionTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_CORPORATION:
			return &GC.getCorporationInfo((CorporationTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_SPECIALIST:
			return &GC.getSpecialistInfo((SpecialistTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_BUILDING:
			return &GC.getBuildingInfo((BuildingTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_CONTROL:
			return &GC.getControlInfo((ControlTypes)getOriginalIndex());
			break;
		case ACTIONSUBTYPE_AUTOMATE:
			return &GC.getAutomateInfo(getOriginalIndex());
			break;

//FfH Spell System: Added by Kael 07/23/2007
        case ACTIONSUBTYPE_SPELL:
			return &GC.getSpellInfo((SpellTypes)getOriginalIndex());
			break;
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (automatic spellcasting) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/

        case ACTIONSUBTYPE_AUTOMATE_SPELL:
			return &GC.getSpellInfo((SpellTypes)getOriginalIndex());
			break;
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
		case ACTIONSUBTYPE_MISSION:
			return &GC.getMissionInfo((MissionTypes)getOriginalIndex());
			break;
	}

	FAssertMsg((0) ,"Unknown Action Subtype in CvActionInfo::getHotkeyInfo");
	return NULL;
}

const TCHAR* CvActionInfo::getType() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getType();
	}

	return NULL;
}

const wchar* CvActionInfo::getDescription() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getDescription();
	}

	return L"";
}

const wchar* CvActionInfo::getCivilopedia() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getCivilopedia();
	}

	return L"";
}

const wchar* CvActionInfo::getHelp() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHelp();
	}

	return L"";
}

const wchar* CvActionInfo::getStrategy() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getStrategy();
	}

	return L"";
}

const TCHAR* CvActionInfo::getButton() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getButton();
	}

	return NULL;
}

const wchar* CvActionInfo::getTextKeyWide() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getTextKeyWide();
	}

	return NULL;
}

int CvActionInfo::getActionInfoIndex() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getActionInfoIndex();
	}

	return -1;
}

int CvActionInfo::getHotKeyVal() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyVal();
	}

	return -1;
}

int CvActionInfo::getHotKeyPriority() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyPriority();
	}

	return -1;
}

int CvActionInfo::getHotKeyValAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyValAlt();
	}

	return -1;
}

int CvActionInfo::getHotKeyPriorityAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyPriorityAlt();
	}

	return -1;
}

int CvActionInfo::getOrderPriority() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getOrderPriority();
	}

	return -1;
}

bool CvActionInfo::isAltDown() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isAltDown();
	}

	return false;
}

bool CvActionInfo::isShiftDown() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isShiftDown();
	}

	return false;
}

bool CvActionInfo::isCtrlDown() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isCtrlDown();
	}

	return false;
}

bool CvActionInfo::isAltDownAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isAltDownAlt();
	}

	return false;
}

bool CvActionInfo::isShiftDownAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isShiftDownAlt();
	}

	return false;
}

bool CvActionInfo::isCtrlDownAlt() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->isCtrlDownAlt();
	}

	return false;
}

const TCHAR* CvActionInfo::getHotKey() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKey();
	}

	return NULL;
}

std::wstring CvActionInfo::getHotKeyDescription() const
{
	if (getHotkeyInfo())
	{
		return getHotkeyInfo()->getHotKeyDescription();
	}

	return L"";
}

//======================================================================================================
//					CvUnitInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvUnitInfo::CvUnitInfo() :
m_iAIWeight(0),
m_iProductionCost(0),
m_iHurryCostModifier(0),
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iMinAreaSize(-1),
m_iMoves(0),
m_iAirRange(0),
m_iAirUnitCap(0),
m_iDropRange(0),
m_iNukeRange(-1),
m_iWorkRate(0),
m_iBaseDiscover(0),
m_iDiscoverMultiplier(0),
m_iBaseHurry(0),
m_iHurryMultiplier(0),
m_iBaseTrade(0),
m_iTradeMultiplier(0),
m_iGreatWorkCulture(0),
m_iEspionagePoints(0),
m_iCombat(0),
m_iCombatLimit(100),
m_iAirCombat(0),
m_iAirCombatLimit(0),
m_iXPValueAttack(8),
m_iXPValueDefense(4),
m_iFirstStrikes(0),
m_iChanceFirstStrikes(0),
m_iInterceptionProbability(0),
m_iEvasionProbability(0),
m_iWithdrawalProbability(0),
m_iCollateralDamage(0),
m_iCollateralDamageLimit(0),
m_iCollateralDamageMaxUnits(0),
m_iCityAttackModifier(0),
m_iCityDefenseModifier(0),
m_iAnimalCombatModifier(0),
m_iHillsAttackModifier(0),
m_iHillsDefenseModifier(0),
m_iBombRate(0),
m_iBombardRate(0),
m_iBombardRange(0),
m_iSpecialCargo(0),
m_iDomainCargo(0),
m_iCargoSpace(0),
m_iConscriptionValue(0),
m_iCultureGarrisonValue(0),
m_iExtraCost(0),
m_iAssetValue(0),
m_iPowerValue(0),
m_iUnitClassType(NO_UNITCLASS),
m_iSpecialUnitType(NO_SPECIALUNIT),
m_iUnitCaptureClassType(NO_UNITCLASS),
m_iUnitCombatType(NO_UNITCOMBAT),
m_iDomainType(NO_DOMAIN),
m_iDefaultUnitAIType(NO_UNITAI),
m_iInvisibleType(NO_INVISIBLE),
m_iAdvisorType(NO_ADVISOR),
m_iHolyCity(NO_RELIGION),
m_iReligionType(NO_RELIGION),
m_iStateReligion(NO_RELIGION),
m_iPrereqReligion(NO_RELIGION),
m_iPrereqCorporation(NO_CORPORATION),
m_iPrereqBuilding(NO_BUILDING),
m_iPrereqAndTech(NO_TECH),
m_iPrereqAndBonus(NO_BONUS),
m_iGroupSize(0),
m_iGroupDefinitions(0),
m_iUnitMeleeWaveSize(0),
m_iUnitRangedWaveSize(0),
m_iNumUnitNames(0),
m_iCommandType(NO_COMMAND),
m_bAnimal(false),
m_bFoodProduction(false),
m_bNoBadGoodies(false),
m_bOnlyDefensive(false),
m_bNoCapture(false),
m_iCaptureDifficulty(0),
m_bQuickCombat(false),
m_bRivalTerritory(false),
m_bMilitaryHappiness(false),
m_bMilitarySupport(false),
m_bMilitaryProduction(false),
m_bNoPillage(false),
m_bSpy(false),
m_bCanUpgradeManaNodes(false),
m_bSabotage(false),
m_bDestroy(false),
m_bStealPlans(false),
m_bInvestigate(false),
m_bCounterSpy(false),
m_bFound(false),
m_bGoldenAge(false),
m_bInvisible(false),
m_bFirstStrikeImmune(false),
m_bNoDefensiveBonus(false),
m_bIgnoreBuildingDefense(false),
m_bCanMoveImpassable(false),
m_bCanMoveAllTerrain(false),
m_bFlatMovementCost(false),
m_bIgnoreTerrainCost(false),
m_bNukeImmune(false),
m_bPrereqBonuses(false),
m_bPrereqReligion(false),
m_bMechanized(false),
m_bRenderBelowWater(false),
m_bRenderAlways(false),
m_bSuicide(false),
m_bLineOfSight(false),
m_bHiddenNationality(false),
m_bAlwaysHostile(false),
m_bNoRevealMap(false),
m_fUnitMaxSpeed(0.0f),
m_fUnitPadTime(0.0f),
m_pbUpgradeUnitClass(NULL),
m_pbTargetUnitClass(NULL),
m_pbTargetUnitCombat(NULL),
m_pbDefenderUnitClass(NULL),
m_pbDefenderUnitCombat(NULL),
m_piFlankingStrikeUnitClass(NULL),
m_pbUnitAIType(NULL),
m_pbNotUnitAIType(NULL),
m_pbBuilds(NULL),
m_piReligionSpreads(NULL),
m_piCorporationSpreads(NULL),
m_piTerrainPassableTech(NULL),
m_piFeaturePassableTech(NULL),
m_pbGreatPeoples(NULL),
m_pbBuildings(NULL),
m_pbForceBuildings(NULL),
m_pbTerrainImpassable(NULL),
m_pbFeatureImpassable(NULL),
m_piPrereqAndTechs(NULL),
m_piPrereqOrBonuses(NULL),
m_piProductionTraits(NULL),
m_piFlavorValue(NULL),
m_piTerrainAttackModifier(NULL),
m_piTerrainDefenseModifier(NULL),
m_piFeatureAttackModifier(NULL),
m_piFeatureDefenseModifier(NULL),
m_piUnitClassAttackModifier(NULL),
m_piUnitClassDefenseModifier(NULL),
m_piUnitCombatModifier(NULL),
m_piUnitCombatCollateralImmune(NULL),
m_piDomainModifier(NULL),
m_piBonusProductionModifier(NULL),
m_piUnitGroupRequired(NULL),
m_pbTerrainNative(NULL),
m_pbFeatureNative(NULL),
m_pbFreePromotions(NULL),
m_paszEarlyArtDefineTags(NULL),
m_paszLateArtDefineTags(NULL),
m_paszMiddleArtDefineTags(NULL),
m_paszUnitNames(NULL),

//FfH Units: Added by Kael 08/04/2007
m_bAbandon(false),
m_bAutoRaze(false),
m_bDisableUpgradeTo(false),
m_bExplodeInCombat(false),
m_bImmortal(false),
m_bImmuneToDefensiveStrike(false),
m_bNeverObsolete(false),
m_bNoWarWeariness(false),
m_iCombatDefense(0),
m_iDefensiveStrikeChance(0),
m_iDefensiveStrikeDamage(0),
m_iDurationFromCombat(0),
m_iEnslavementChance(0),
m_iFreePromotionPick(0),
m_iGoldFromCombat(0),
m_iMinLevel(0),
m_iMiscastChance(0),
m_iModifyGlobalCounter(0),
m_iDiploVoteType(NO_VOTESOURCE),
m_iEquipmentPromotion(NO_PROMOTION),
m_iPrereqAlignment(NO_ALIGNMENT),
m_iPrereqBuildingClass(NO_BUILDINGCLASS),
m_iPrereqCiv(NO_CIVILIZATION),
m_iPrereqCivic(NO_CIVIC),
m_iPrereqGlobalCounter(0),
m_iPromotionFromCombat(NO_PROMOTION),
m_iTier(0),
m_iUnitConvertFromCombat(NO_UNIT),
m_iUnitConvertFromCombatChance(0),
m_iUnitCreateFromCombat(NO_UNIT),
m_iUnitCreateFromCombatChance(0),
m_iUpgradeCiv(NO_CIVILIZATION),
m_iWeaponTier(0),
m_iWithdrawlProbDefensive(0),
m_piBonusAffinity(NULL),
m_piDamageTypeCombat(NULL),
m_szImage(NULL),
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
m_bAIblockPermDefense(false),
m_bAIblockPatrol(false),
m_bAIblockExplore(false),
m_bBarbarianSpawn(false),
m_bWildmanaGuardian(false),
m_bArcaneAura(false),
m_iObsoleteTech(NO_TECH),
m_piBonusAptitude(NULL),
m_iArcaneRange(0),
m_iAppearanceProb(0),
m_piAppearanceTechs(NULL),
m_piCityCommerceChanges(NULL),
m_iFaithUpkeep(0),
m_iManaUpkeep(0),
m_iReducedCostByYieldOverwrite(NO_YIELD),
m_iPopulationCost(0),
m_iGlobalYieldTypeCost(0),
m_iGlobalYieldCost(0),
m_iExtraLives(0),
m_iBonusNearUF(0),
m_bNoCitySupportNeeded(false),
m_bNoEquipment(false),
m_bNoXP(false),
m_bScaleWithTech(false),
m_iMinWilderness(0),
m_iMaxWilderness(MAX_INT),
m_iCombatAuraType(NO_COMBATAURA),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Units can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
m_iRequiredGameOption(NO_GAMEOPTION),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
m_bDefensiveStrikes(false),
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
m_iCorporationSupportNeeded(NO_CORPORATION),
 m_paiCorporationSupport(NULL),
 m_paiCorporationSupportMod(NULL)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvUnitInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvUnitInfo::~CvUnitInfo()
{
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    SAFE_DELETE_ARRAY(m_piBonusAptitude);
    SAFE_DELETE_ARRAY(m_piAppearanceTechs);
    SAFE_DELETE_ARRAY(m_piCityCommerceChanges);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//FfH Damage Types: Added by Kael 08/23/2007
	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
//FfH: End Add

	SAFE_DELETE_ARRAY(m_pbUpgradeUnitClass);
	SAFE_DELETE_ARRAY(m_pbTargetUnitClass);
	SAFE_DELETE_ARRAY(m_pbTargetUnitCombat);
	SAFE_DELETE_ARRAY(m_pbDefenderUnitClass);
	SAFE_DELETE_ARRAY(m_pbDefenderUnitCombat);
	SAFE_DELETE_ARRAY(m_piFlankingStrikeUnitClass);
	SAFE_DELETE_ARRAY(m_pbUnitAIType);
	SAFE_DELETE_ARRAY(m_pbNotUnitAIType);
	SAFE_DELETE_ARRAY(m_pbBuilds);
	SAFE_DELETE_ARRAY(m_piReligionSpreads);
	SAFE_DELETE_ARRAY(m_piCorporationSpreads);
	SAFE_DELETE_ARRAY(m_piTerrainPassableTech);
	SAFE_DELETE_ARRAY(m_piFeaturePassableTech);
	SAFE_DELETE_ARRAY(m_pbGreatPeoples);
	SAFE_DELETE_ARRAY(m_pbBuildings);
	SAFE_DELETE_ARRAY(m_pbForceBuildings);
	SAFE_DELETE_ARRAY(m_pbTerrainImpassable);
	SAFE_DELETE_ARRAY(m_pbFeatureImpassable);
	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	SAFE_DELETE_ARRAY(m_piProductionTraits);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piTerrainAttackModifier);
	SAFE_DELETE_ARRAY(m_piTerrainDefenseModifier);
	SAFE_DELETE_ARRAY(m_piFeatureAttackModifier);
	SAFE_DELETE_ARRAY(m_piFeatureDefenseModifier);
	SAFE_DELETE_ARRAY(m_piUnitClassAttackModifier);
	SAFE_DELETE_ARRAY(m_piUnitClassDefenseModifier);
	SAFE_DELETE_ARRAY(m_piUnitCombatModifier);
	SAFE_DELETE_ARRAY(m_piUnitCombatCollateralImmune);
	SAFE_DELETE_ARRAY(m_piDomainModifier);
	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	SAFE_DELETE_ARRAY(m_piUnitGroupRequired);
	SAFE_DELETE_ARRAY(m_pbTerrainNative);
	SAFE_DELETE_ARRAY(m_pbFeatureNative);
	SAFE_DELETE_ARRAY(m_pbFreePromotions);
	SAFE_DELETE_ARRAY(m_paszEarlyArtDefineTags);
	SAFE_DELETE_ARRAY(m_paszLateArtDefineTags);
	SAFE_DELETE_ARRAY(m_paszMiddleArtDefineTags);
	SAFE_DELETE_ARRAY(m_paszUnitNames);
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

int CvUnitInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvUnitInfo::getProductionCost() const
{
	return m_iProductionCost;
}

int CvUnitInfo::getHurryCostModifier() const
{
	return m_iHurryCostModifier;
}

int CvUnitInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvUnitInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvUnitInfo::getMinAreaSize() const
{
	return m_iMinAreaSize;
}

int CvUnitInfo::getMoves() const
{
	return m_iMoves;
}

int CvUnitInfo::getAirRange() const
{
	return m_iAirRange;
}

int CvUnitInfo::getAirUnitCap() const
{
	return m_iAirUnitCap;
}

int CvUnitInfo::getDropRange() const
{
	return m_iDropRange;
}

int CvUnitInfo::getNukeRange() const
{
	return m_iNukeRange;
}

int CvUnitInfo::getWorkRate() const
{
	return m_iWorkRate;
}

int CvUnitInfo::getBaseDiscover() const
{
	return m_iBaseDiscover;
}

int CvUnitInfo::getDiscoverMultiplier() const
{
	return m_iDiscoverMultiplier;
}

int CvUnitInfo::getBaseHurry() const
{
	return m_iBaseHurry;
}

int CvUnitInfo::getHurryMultiplier() const
{
	return m_iHurryMultiplier;
}

int CvUnitInfo::getBaseTrade() const
{
	return m_iBaseTrade;
}

int CvUnitInfo::getTradeMultiplier() const
{
	return m_iTradeMultiplier;
}

int CvUnitInfo::getGreatWorkCulture() const
{
	return m_iGreatWorkCulture;
}

int CvUnitInfo::getEspionagePoints() const
{
	return m_iEspionagePoints;
}

int CvUnitInfo::getCombat() const
{
	return m_iCombat;
}

void CvUnitInfo::setCombat(int iNum)
{
	m_iCombat = iNum;
}

int CvUnitInfo::getCombatLimit() const
{
	return m_iCombatLimit;
}

int CvUnitInfo::getAirCombat() const
{
	return m_iAirCombat;
}

int CvUnitInfo::getAirCombatLimit() const
{
	return m_iAirCombatLimit;
}

int CvUnitInfo::getXPValueAttack() const
{
	return m_iXPValueAttack;
}

int CvUnitInfo::getXPValueDefense() const
{
	return m_iXPValueDefense;
}

int CvUnitInfo::getFirstStrikes() const
{
	return m_iFirstStrikes;
}

int CvUnitInfo::getChanceFirstStrikes() const
{
	return m_iChanceFirstStrikes;
}

int CvUnitInfo::getInterceptionProbability() const
{
	return m_iInterceptionProbability;
}

int CvUnitInfo::getEvasionProbability() const
{
	return m_iEvasionProbability;
}

int CvUnitInfo::getWithdrawalProbability() const
{
	return m_iWithdrawalProbability + ((getUnitCombatType() != NO_UNITCOMBAT) ? GC.getUnitCombatInfo((UnitCombatTypes)getUnitCombatType()).getWithdrawal() : 0);
}

int CvUnitInfo::getCollateralDamage() const
{
	return m_iCollateralDamage;
}

int CvUnitInfo::getCollateralDamageLimit() const
{
	return m_iCollateralDamageLimit;
}

int CvUnitInfo::getCollateralDamageMaxUnits() const
{
	return m_iCollateralDamageMaxUnits;
}

int CvUnitInfo::getCityAttackModifier() const
{
	return m_iCityAttackModifier + ((getUnitCombatType() != NO_UNITCOMBAT) ? GC.getUnitCombatInfo((UnitCombatTypes)getUnitCombatType()).getCityAttack() : 0);
}

int CvUnitInfo::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

int CvUnitInfo::getAnimalCombatModifier() const
{
	return m_iAnimalCombatModifier;
}

int CvUnitInfo::getHillsAttackModifier() const
{
	return m_iHillsAttackModifier;
}

int CvUnitInfo::getHillsDefenseModifier() const
{
	return m_iHillsDefenseModifier;
}

int CvUnitInfo::getBombRate() const
{
	return m_iBombRate;
}

int CvUnitInfo::getBombardRate() const
{
	return m_iBombardRate;
}

int CvUnitInfo::getBombardRange() const
{
	return m_iBombardRange;
}

int CvUnitInfo::getSpecialCargo() const
{
	return m_iSpecialCargo;
}

int CvUnitInfo::getDomainCargo() const
{
	return m_iDomainCargo;
}

int CvUnitInfo::getCargoSpace() const
{
	return m_iCargoSpace;
}

int CvUnitInfo::getConscriptionValue() const
{
	return m_iConscriptionValue;
}

int CvUnitInfo::getCultureGarrisonValue() const
{
	return m_iCultureGarrisonValue;
}

int CvUnitInfo::getExtraCost() const
{
	return m_iExtraCost;
}

int CvUnitInfo::getAssetValue() const
{
	return m_iAssetValue;
}

int CvUnitInfo::getPowerValue() const
{
	return m_iPowerValue;
}

int CvUnitInfo::getUnitClassType() const
{
	return m_iUnitClassType;
}

int CvUnitInfo::getSpecialUnitType() const
{
	return m_iSpecialUnitType;
}

int CvUnitInfo::getUnitCaptureClassType() const
{
	return m_iUnitCaptureClassType;
}

int CvUnitInfo::getUnitCombatType() const
{
	return m_iUnitCombatType;
}

int CvUnitInfo::getDomainType() const
{
	return m_iDomainType;
}

int CvUnitInfo::getDefaultUnitAIType() const
{
	return m_iDefaultUnitAIType;
}

int CvUnitInfo::getInvisibleType() const
{
	return m_iInvisibleType;
}

int CvUnitInfo::getSeeInvisibleType(int i) const
{
	FAssert(i < (int)m_aiSeeInvisibleTypes.size());

	return m_aiSeeInvisibleTypes[i];
}

int CvUnitInfo::getNumSeeInvisibleTypes() const
{
	return (int)m_aiSeeInvisibleTypes.size();
}

int CvUnitInfo::getAdvisorType() const
{
	return m_iAdvisorType;
}

int CvUnitInfo::getHolyCity() const
{
	return m_iHolyCity;
}

int CvUnitInfo::getReligionType() const
{
	return m_iReligionType;
}

int CvUnitInfo::getStateReligion() const
{
	return m_iStateReligion;
}

int CvUnitInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}

int CvUnitInfo::getPrereqCorporation() const
{
	return m_iPrereqCorporation;
}

int CvUnitInfo::getPrereqBuilding() const
{
	return m_iPrereqBuilding;
}

int CvUnitInfo::getPrereqAndTech() const
{
	return m_iPrereqAndTech;
}

int CvUnitInfo::getPrereqAndBonus() const
{
	return m_iPrereqAndBonus;
}

int CvUnitInfo::getGroupSize() const// the initial number of individuals in the unit group
{
	return m_iGroupSize;
}

int CvUnitInfo::getGroupDefinitions() const// the number of UnitMeshGroups for this unit
{
	return m_iGroupDefinitions;
}

int CvUnitInfo::getMeleeWaveSize() const
{
	return m_iUnitMeleeWaveSize;
}

int CvUnitInfo::getRangedWaveSize() const
{
	return m_iUnitRangedWaveSize;
}

int CvUnitInfo::getNumUnitNames() const
{
	return m_iNumUnitNames;
}

bool CvUnitInfo::isAnimal() const
{
	return m_bAnimal;
}

bool CvUnitInfo::isFoodProduction() const
{
	return m_bFoodProduction;
}

bool CvUnitInfo::isNoBadGoodies() const
{
	return m_bNoBadGoodies;
}

bool CvUnitInfo::isOnlyDefensive() const
{
	return m_bOnlyDefensive;
}

bool CvUnitInfo::isNoCapture() const
{
	return m_bNoCapture;
}

int CvUnitInfo::getCaptureDifficulty() const
{
	return m_iCaptureDifficulty;
}

bool CvUnitInfo::isQuickCombat() const
{
	return m_bQuickCombat;
}

bool CvUnitInfo::isRivalTerritory() const
{
	return m_bRivalTerritory;
}

bool CvUnitInfo::isMilitaryHappiness() const
{
	return m_bMilitaryHappiness;
}

bool CvUnitInfo::isMilitarySupport() const
{
	return m_bMilitarySupport;
}

bool CvUnitInfo::isMilitaryProduction() const
{
	return m_bMilitaryProduction;
}

bool CvUnitInfo::isNoPillage() const
{
	return m_bNoPillage;
}

bool CvUnitInfo::isSpy() const
{
	return m_bSpy;
}

bool CvUnitInfo::isCanUpgradeManaNodes() const
{
	return m_bCanUpgradeManaNodes;
}

bool CvUnitInfo::isSabotage() const
{
	return m_bSabotage;
}

bool CvUnitInfo::isDestroy() const
{
	return m_bDestroy;
}

bool CvUnitInfo::isStealPlans() const
{
	return m_bStealPlans;
}

bool CvUnitInfo::isInvestigate() const
{
	return m_bInvestigate;
}

bool CvUnitInfo::isCounterSpy() const
{
	return m_bCounterSpy;
}

bool CvUnitInfo::isFound() const
{
	return m_bFound;
}

bool CvUnitInfo::isGoldenAge() const
{
	return m_bGoldenAge;
}

bool CvUnitInfo::isInvisible() const
{
	return m_bInvisible;
}

void CvUnitInfo::setInvisible(bool bEnable)
{
	m_bInvisible = bEnable;
}

bool CvUnitInfo::isFirstStrikeImmune() const
{
	return m_bFirstStrikeImmune;
}

bool CvUnitInfo::isNoDefensiveBonus() const
{
	return m_bNoDefensiveBonus;
}

bool CvUnitInfo::isIgnoreBuildingDefense() const
{
	return m_bIgnoreBuildingDefense;
}

bool CvUnitInfo::isCanMoveImpassable() const
{
	return m_bCanMoveImpassable;
}

bool CvUnitInfo::isCanMoveAllTerrain() const
{
	return m_bCanMoveAllTerrain;
}

bool CvUnitInfo::isFlatMovementCost() const
{
	return m_bFlatMovementCost;
}

bool CvUnitInfo::isIgnoreTerrainCost() const
{
	return m_bIgnoreTerrainCost;
}

bool CvUnitInfo::isNukeImmune() const
{
	return m_bNukeImmune;
}

bool CvUnitInfo::isPrereqBonuses() const
{
	return m_bPrereqBonuses;
}

bool CvUnitInfo::isPrereqReligion() const
{
	return m_bPrereqReligion;
}

bool CvUnitInfo::isMechUnit() const
{
	return m_bMechanized;
}

bool CvUnitInfo::isRenderBelowWater() const
{
	return m_bRenderBelowWater;
}

bool CvUnitInfo::isRenderAlways() const
{
	return m_bRenderAlways;
}

bool CvUnitInfo::isSuicide() const
{
	return m_bSuicide;
}

bool CvUnitInfo::isLineOfSight() const
{
	return m_bLineOfSight;
}

bool CvUnitInfo::isHiddenNationality() const
{
	return m_bHiddenNationality;
}

bool CvUnitInfo::isAlwaysHostile() const
{
	return m_bAlwaysHostile;
}

bool CvUnitInfo::isNoRevealMap() const
{
	return m_bNoRevealMap;
}

float CvUnitInfo::getUnitMaxSpeed() const
{
	return m_fUnitMaxSpeed;
}

float CvUnitInfo::getUnitPadTime() const
{
	return m_fUnitPadTime;
}

int CvUnitInfo::getCommandType() const
{
	return m_iCommandType;
}

void CvUnitInfo::setCommandType(int iNewType)
{
	m_iCommandType = iNewType;
}

//FfH Units: Added by Kael 08/04/2007
bool CvUnitInfo::isAbandon() const
{
	return m_bAbandon;
}

bool CvUnitInfo::isAutoRaze() const
{
	return m_bAutoRaze;
}

bool CvUnitInfo::isDisableUpgradeTo() const
{
	return m_bDisableUpgradeTo;
}

bool CvUnitInfo::isExplodeInCombat() const
{
	return m_bExplodeInCombat;
}

const TCHAR* CvUnitInfo::getImage() const
{
	return m_szImage;
}

bool CvUnitInfo::isImmortal() const
{
	return m_bImmortal;
}

bool CvUnitInfo::isImmuneToDefensiveStrike() const
{
	return m_bImmuneToDefensiveStrike;
}

bool CvUnitInfo::isNeverObsolete() const
{
	return m_bNeverObsolete;
}

bool CvUnitInfo::isNoWarWeariness() const
{
	return m_bNoWarWeariness;
}

int CvUnitInfo::getCombatDefense() const
{
	/**
	return m_iCombatDefense;
	**/
	if(m_iCombatDefense == 0)
		return (getCombat()*100)/100;
	return m_iCombatDefense;
}

int CvUnitInfo::getDefensiveStrikeChance() const
{
	return m_iDefensiveStrikeChance;
}

int CvUnitInfo::getDefensiveStrikeDamage() const
{
	return m_iDefensiveStrikeDamage;
}

int CvUnitInfo::getDiploVoteType() const
{
	return m_iDiploVoteType;
}

int CvUnitInfo::getDurationFromCombat() const
{
	return m_iDurationFromCombat;
}

int CvUnitInfo::getEnslavementChance() const
{
	return m_iEnslavementChance;
}

int CvUnitInfo::getEquipmentPromotion() const
{
	return m_iEquipmentPromotion;
}

int CvUnitInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

int CvUnitInfo::getFreePromotionPick() const
{
	return m_iFreePromotionPick;
}

int CvUnitInfo::getGoldFromCombat() const
{
	return m_iGoldFromCombat;
}

int CvUnitInfo::getMinLevel() const
{
	return m_iMinLevel;
}

int CvUnitInfo::getMiscastChance() const
{
	return m_iMiscastChance;
}

int CvUnitInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvUnitInfo::getPrereqGlobalCounter() const
{
	return m_iPrereqGlobalCounter;
}

int CvUnitInfo::getPrereqBuildingClass() const
{
	return m_iPrereqBuildingClass;
}

int CvUnitInfo::getPrereqCiv() const
{
	return m_iPrereqCiv;
}

int CvUnitInfo::getPrereqCivic() const
{
	return m_iPrereqCivic;
}

int CvUnitInfo::getPromotionFromCombat() const
{
	return m_iPromotionFromCombat;
}

const TCHAR *CvUnitInfo::getPyPostCombatLost() const
{
	return m_szPyPostCombatLost;
}

const TCHAR *CvUnitInfo::getPyPostCombatWon() const
{
	return m_szPyPostCombatWon;
}

int CvUnitInfo::getTier() const
{
	return m_iTier;
}

int CvUnitInfo::getUnitConvertFromCombat() const
{
	return m_iUnitConvertFromCombat;
}

int CvUnitInfo::getUnitConvertFromCombatChance() const
{
	return m_iUnitConvertFromCombatChance;
}

int CvUnitInfo::getUnitCreateFromCombat() const
{
	return m_iUnitCreateFromCombat;
}

int CvUnitInfo::getUnitCreateFromCombatChance() const
{
	return m_iUnitCreateFromCombatChance;
}

int CvUnitInfo::getUpgradeCiv() const
{
	return m_iUpgradeCiv;
}

int CvUnitInfo::getWeaponTier() const
{
	return m_iWeaponTier;
}

int CvUnitInfo::getWithdrawlProbDefensive() const
{
	return m_iWithdrawlProbDefensive;
}

int CvUnitInfo::getBonusAffinity(int i) const
{
	return m_piBonusAffinity ? m_piBonusAffinity[i] : -1;
}

int CvUnitInfo::getDamageTypeCombat(int i) const
{
	return m_piDamageTypeCombat ? m_piDamageTypeCombat[i] : -1;
}
//FfH: End Add
// Arrays

int CvUnitInfo::getPrereqAndTechs(int i) const
{
	FAssertMsg(i < GC.getNUM_UNIT_AND_TECH_PREREQS(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;
}

int CvUnitInfo::getPrereqOrBonuses(int i) const
{
	FAssertMsg(i < GC.getNUM_UNIT_PREREQ_OR_BONUSES(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqOrBonuses ? m_piPrereqOrBonuses[i] : -1;
}

int CvUnitInfo::getProductionTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
}

int CvUnitInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvUnitInfo::getTerrainAttackModifier(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainAttackModifier ? m_piTerrainAttackModifier[i] : -1;
}

int CvUnitInfo::getTerrainDefenseModifier(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainDefenseModifier ? m_piTerrainDefenseModifier[i] : -1;
}

int CvUnitInfo::getFeatureAttackModifier(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureAttackModifier ? m_piFeatureAttackModifier[i] : -1;
}

int CvUnitInfo::getFeatureDefenseModifier(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeatureDefenseModifier ? m_piFeatureDefenseModifier[i] : -1;
}

int CvUnitInfo::getUnitClassAttackModifier(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitClassAttackModifier ? m_piUnitClassAttackModifier[i] : -1;
}

int CvUnitInfo::getUnitClassDefenseModifier(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitClassDefenseModifier ? m_piUnitClassDefenseModifier[i] : -1;
}

int CvUnitInfo::getUnitCombatModifier(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatModifier ? m_piUnitCombatModifier[i] : -1;
}

int CvUnitInfo::getUnitCombatCollateralImmune(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatCollateralImmune ? m_piUnitCombatCollateralImmune[i] : -1;
}

int CvUnitInfo::getDomainModifier(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDomainModifier ? m_piDomainModifier[i] : -1;
}

int CvUnitInfo::getBonusProductionModifier(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusProductionModifier ? m_piBonusProductionModifier[i] : -1;
}

int CvUnitInfo::getUnitGroupRequired(int i) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitGroupRequired ? m_piUnitGroupRequired[i] : NULL;
}

bool CvUnitInfo::getUpgradeUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbUpgradeUnitClass ? m_pbUpgradeUnitClass[i] : false;
}

bool CvUnitInfo::getTargetUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTargetUnitClass ? m_pbTargetUnitClass[i] : false;
}

bool CvUnitInfo::getTargetUnitCombat(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTargetUnitCombat ? m_pbTargetUnitCombat[i] : false;
}

bool CvUnitInfo::getDefenderUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbDefenderUnitClass ? m_pbDefenderUnitClass[i] : false;
}

bool CvUnitInfo::getDefenderUnitCombat(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbDefenderUnitCombat ? m_pbDefenderUnitCombat[i] : false;
}

int CvUnitInfo::getFlankingStrikeUnitClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlankingStrikeUnitClass ? m_piFlankingStrikeUnitClass[i] : -1;
}

bool CvUnitInfo::getUnitAIType(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbUnitAIType ? m_pbUnitAIType[i] : false;
}

bool CvUnitInfo::getNotUnitAIType(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbNotUnitAIType ? m_pbNotUnitAIType[i] : false;
}

bool CvUnitInfo::getBuilds(int i) const
{
	FAssertMsg(i < GC.getNumBuildInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbBuilds ? m_pbBuilds[i] : false;
}

int CvUnitInfo::getReligionSpreads(int i) const
{
	FAssertMsg(i < GC.getNumReligionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piReligionSpreads ? m_piReligionSpreads[i] : -1;
}

int CvUnitInfo::getCorporationSpreads(int i) const
{
	FAssertMsg(i < GC.getNumCorporationInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCorporationSpreads ? m_piCorporationSpreads[i] : -1;
}

int CvUnitInfo::getTerrainPassableTech(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTerrainPassableTech ? m_piTerrainPassableTech[i] : -1;
}

int CvUnitInfo::getFeaturePassableTech(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFeaturePassableTech ? m_piFeaturePassableTech[i] : -1;
}

bool CvUnitInfo::getGreatPeoples(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbGreatPeoples ? m_pbGreatPeoples[i] : false;
}

bool CvUnitInfo::getBuildings(int i) const
{
	FAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbBuildings ? m_pbBuildings[i] : false;
}

bool CvUnitInfo::getForceBuildings(int i) const
{
	FAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbForceBuildings ? m_pbForceBuildings[i] : false;
}

bool CvUnitInfo::getTerrainImpassable(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainImpassable ? m_pbTerrainImpassable[i] : false;
}

bool CvUnitInfo::getFeatureImpassable(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureImpassable ? m_pbFeatureImpassable[i] : false;
}

bool CvUnitInfo::getTerrainNative(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainNative ? m_pbTerrainNative[i] : false;
}

bool CvUnitInfo::getFeatureNative(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureNative ? m_pbFeatureNative[i] : false;
}

bool CvUnitInfo::getFreePromotions(int i) const
{
	FAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFreePromotions ? m_pbFreePromotions[i] : false;
}

int CvUnitInfo::getLeaderPromotion() const
{
	return m_iLeaderPromotion;
}

int CvUnitInfo::getLeaderExperience() const
{
	return m_iLeaderExperience;
}

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
 int CvUnitInfo::getBonusAptitude(int i) const
{
	return m_piBonusAptitude ? m_piBonusAptitude[i] : -1;
}

bool CvUnitInfo::isAIblockPermDefense() const
{
    return m_bAIblockPermDefense;
}

bool CvUnitInfo::isAIblockPatrol() const
{
    return m_bAIblockPatrol;
}

bool CvUnitInfo::isAIblockExplore() const
{
    return m_bAIblockExplore;
}

bool CvUnitInfo::isBarbarianSpawn() const
{
	return m_bBarbarianSpawn;
}

bool CvUnitInfo::isWildmanaGuardian() const
{
	return m_bWildmanaGuardian;
}

 bool CvUnitInfo::isArcaneAura() const
 {
	 return m_bArcaneAura;
 }

int CvUnitInfo::getObsoleteTech() const
{
	return m_iObsoleteTech;
}

int CvUnitInfo::getAppearanceProb() const
{
	return m_iAppearanceProb;
}

int CvUnitInfo::getArcaneRange() const
{
	return m_iArcaneRange;
}

int CvUnitInfo::getAppearanceTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAppearanceTechs ? m_piAppearanceTechs[i] : -1;
}

int CvUnitInfo::getCityCommerceChanges(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCityCommerceChanges ? m_piCityCommerceChanges[i] : -1;
}

int CvUnitInfo::getUpgradeCivVectorSize()						{return m_aszExtraXMLforPass3.size();}
CvString CvUnitInfo::getUpgradeCivVectorElement(int i)			{return m_aszExtraXMLforPass3[i];}
int CvUnitInfo::getPrereqCivVectorSize()						{return m_aszExtraXML1forPass3.size();}
CvString CvUnitInfo::getPrereqCivVectorElement(int i)			{return m_aszExtraXML1forPass3[i];}
int CvUnitInfo::getFaithUpkeep()						{return m_iFaithUpkeep;}
int CvUnitInfo::getManaUpkeep()						{return m_iManaUpkeep;}
int CvUnitInfo::getCombatAuraType()					{return m_iCombatAuraType;}
int CvUnitInfo::getReducedCostByYieldOverwrite() const	{return m_iReducedCostByYieldOverwrite;}
int CvUnitInfo::getPopulationCost() const			{return m_iPopulationCost;}
int CvUnitInfo::getGlobalYieldTypeCost() const		{return m_iGlobalYieldTypeCost;}
int CvUnitInfo::getGlobalYieldCost() const			{return m_iGlobalYieldCost;}
int CvUnitInfo::getExtraLives() const			{return m_iExtraLives;}
int CvUnitInfo::getBonusNearUF() const			{return m_iBonusNearUF;}
int CvUnitInfo::getMinWilderness() const			{return m_iMinWilderness;}
int CvUnitInfo::getMaxWilderness() const			{return m_iMaxWilderness;}
bool CvUnitInfo::isNoCitySupportNeeded() const { return m_bNoCitySupportNeeded;}
bool CvUnitInfo::isNoEquipment() const { return m_bNoEquipment;}
bool CvUnitInfo::isNoXP() const { return m_bNoXP;}
bool CvUnitInfo::isScaleWithTech() const { return m_bScaleWithTech;}
int CvUnitInfo::getReducedCostByYield() const
{
	if(getReducedCostByYieldOverwrite()==NO_UNIT)
	{
		return GC.getUnitClassInfo((UnitClassTypes)getUnitClassType()).getReducedCostByYield();
	}

	return getReducedCostByYieldOverwrite();
}

bool CvUnitInfo::isCitySupportNeeded() const
{
	if(isNoCitySupportNeeded())
	{
		return false;
	}

	if(isWorldUnitClass((UnitClassTypes)getUnitClassType()))
	{
		return false;
	}

	if(getEquipmentPromotion()!=NO_PROMOTION)
	{
		return false;
	}

	if(!isMilitarySupport())
	{
		return false;
	}

	if(getDomainType()!=DOMAIN_LAND)
	{
		return false;
	}

	return true;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Units can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
int CvUnitInfo::getRequiredGameOption() const
{
	return m_iRequiredGameOption;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
bool CvUnitInfo::isDefensiveStrikes() const
{
	return m_bDefensiveStrikes;
}
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvUnitInfo::getCorporationSupportNeeded() const
{
	return m_iCorporationSupportNeeded;
}

int CvUnitInfo::getCorporationSupport(int iCorporation) const
{
	return m_paiCorporationSupport[iCorporation];
}

int CvUnitInfo::getCorporationSupportMultiplier(int iCorporation) const
{
	return m_paiCorporationSupportMod[iCorporation];
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	SPEEDTWEAK (CAR MOD) merged Sephi                                         					**/
/**																								**/
/**	                                                                 							**/
/*************************************************************************************************/
std::vector<int> CvUnitInfo::getUpgradeUnitClassTypes() const
{
	return m_aiUpgradeUnitClassTypes;
}

void CvUnitInfo::addUpgradeUnitClassTypes(int i)
{
	FAssert (i > -1 && i < GC.getNumUnitClassInfos());
	if (find(m_aiUpgradeUnitClassTypes.begin(), m_aiUpgradeUnitClassTypes.end(), i) == m_aiUpgradeUnitClassTypes.end())
	{
		m_aiUpgradeUnitClassTypes.push_back(i);
	}
}

bool CvUnitInfo::isUpgradeUnitClassTypes(int i)
{
	FAssert (i > -1 && i < GC.getNumUnitClassInfos());
	if (find(m_aiUpgradeUnitClassTypes.begin(), m_aiUpgradeUnitClassTypes.end(), i) == m_aiUpgradeUnitClassTypes.end())
	{
		return false;
	}
	return true;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

const TCHAR* CvUnitInfo::getEarlyArtDefineTag(int i, UnitArtStyleTypes eStyle) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (NO_UNIT_ARTSTYLE != eStyle)
	{
		int iIndex = GC.getInfoTypeForString(getType());
		if (-1 != iIndex)
		{
			const TCHAR* pcTag = GC.getUnitArtStyleTypeInfo(eStyle).getEarlyArtDefineTag(i, iIndex);
			if (NULL != pcTag)
			{
				return pcTag;
			}
		}
	}

	return (m_paszEarlyArtDefineTags) ? m_paszEarlyArtDefineTags[i] : NULL;
}

void CvUnitInfo::setEarlyArtDefineTag(int i, const TCHAR* szVal)
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszEarlyArtDefineTags[i] = szVal;
}

const TCHAR* CvUnitInfo::getLateArtDefineTag(int i, UnitArtStyleTypes eStyle) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (NO_UNIT_ARTSTYLE != eStyle)
	{
		int iIndex = GC.getInfoTypeForString(getType());
		if (-1 != iIndex)
		{
			const TCHAR* pcTag = GC.getUnitArtStyleTypeInfo(eStyle).getLateArtDefineTag(i, iIndex);
			if (NULL != pcTag)
			{
				return pcTag;
			}
		}

	}

	return (m_paszLateArtDefineTags) ? m_paszLateArtDefineTags[i] : NULL;
}

void CvUnitInfo::setLateArtDefineTag(int i, const TCHAR* szVal)
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszLateArtDefineTags[i] = szVal;
}

const TCHAR* CvUnitInfo::getMiddleArtDefineTag(int i, UnitArtStyleTypes eStyle) const
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (NO_UNIT_ARTSTYLE != eStyle)
	{
		int iIndex = GC.getInfoTypeForString(getType());
		if (-1 != iIndex)
		{
			const TCHAR* pcTag = GC.getUnitArtStyleTypeInfo(eStyle).getMiddleArtDefineTag(i, iIndex);
			if (NULL != pcTag)
			{
				return pcTag;
			}
		}

	}

	return (m_paszMiddleArtDefineTags) ? m_paszMiddleArtDefineTags[i] : NULL;
}

void CvUnitInfo::setMiddleArtDefineTag(int i, const TCHAR* szVal)
{
	FAssertMsg(i < getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_paszMiddleArtDefineTags[i] = szVal;
}

const TCHAR* CvUnitInfo::getUnitNames(int i) const
{
	FAssertMsg(i < getNumUnitNames(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return (m_paszUnitNames) ? m_paszUnitNames[i] : NULL;
}

const TCHAR* CvUnitInfo::getFormationType() const
{
	return m_szFormationType;
}

const TCHAR* CvUnitInfo::getButton() const
{
	return m_szArtDefineButton;
}

//FfH: Added by Kael 02/06/2009
const TCHAR* CvUnitInfo::getUnitStyleButton(int iProm) const
{
	return getArtInfo(0, NO_ERA, (UnitArtStyleTypes)GC.getPromotionInfo((PromotionTypes)iProm).getUnitArtStyleType())->getButton();
}
//FfH: End Add
/*************************************************************************************************/
/**	FFHBUG denev																				**/
/**	ADDON (FFHBUG) merged Sephi																	**/
/**																								**/
/*************************************************************************************************/
//BUGFFH: Added by Denev 2009/09/04
//>>>>BUGFfH: Added by Denev 2009/09/04
const TCHAR* CvUnitInfo::getUnitButtonWithArtStyle(int iUnitArtStyle) const
{
	return getArtInfo(0, NO_ERA, (UnitArtStyleTypes)iUnitArtStyle)->getButton();
}

const TCHAR* CvUnitInfo::getUnitButtonWithCivArtStyle(int iCivilization) const
{
	UnitArtStyleTypes eUnitArtStyle = NO_UNIT_ARTSTYLE;
	if (iCivilization != NO_CIVILIZATION)
	{
		eUnitArtStyle = (UnitArtStyleTypes) GC.getCivilizationInfo((CivilizationTypes) iCivilization).getUnitArtStyleType();

		const PromotionTypes eDefaultRace = (PromotionTypes) GC.getCivilizationInfo((CivilizationTypes) iCivilization).getDefaultRace();
		if (eDefaultRace != NO_PROMOTION)
		{
			const UnitArtStyleTypes eUnitArtStyleByRace = (UnitArtStyleTypes) GC.getPromotionInfo(eDefaultRace).getUnitArtStyleType();
			if (eUnitArtStyleByRace != NO_UNIT_ARTSTYLE)
			{
				eUnitArtStyle = eUnitArtStyleByRace;
			}
		}
	}

	return getArtInfo(0, NO_ERA, eUnitArtStyle)->getButton();
}
//<<<<BUGFfH: End Add
//BUGFFH: End Add
/*************************************************************************************************/
/**	END																							**/
/*************************************************************************************************/
void CvUnitInfo::updateArtDefineButton()
{
	m_szArtDefineButton = getArtInfo(0, NO_ERA, NO_UNIT_ARTSTYLE)->getButton();
}

const CvArtInfoUnit* CvUnitInfo::getArtInfo(int i, EraTypes eEra, UnitArtStyleTypes eStyle) const
{
	if ((eEra > GC.getNumEraInfos() / 2) && !CvString(getLateArtDefineTag(i, eStyle)).empty())
	{
		return ARTFILEMGR.getUnitArtInfo(getLateArtDefineTag(i, eStyle));
	}
	else if ((eEra > GC.getNumEraInfos() / 4) && !CvString(getMiddleArtDefineTag(i, eStyle)).empty())
	{
		return ARTFILEMGR.getUnitArtInfo(getMiddleArtDefineTag(i, eStyle));
	}
	else
	{
		return ARTFILEMGR.getUnitArtInfo(getEarlyArtDefineTag(i, eStyle));
	}
}

void CvUnitInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iAIWeight);
	stream->Read(&m_iProductionCost);
	stream->Read(&m_iHurryCostModifier);
	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);
	stream->Read(&m_iMinAreaSize);
	stream->Read(&m_iMoves);
	stream->Read(&m_iAirRange);
	stream->Read(&m_iAirUnitCap);
	stream->Read(&m_iDropRange);
	stream->Read(&m_iNukeRange);
	stream->Read(&m_iWorkRate);
	stream->Read(&m_iBaseDiscover);
	stream->Read(&m_iDiscoverMultiplier);
	stream->Read(&m_iBaseHurry);
	stream->Read(&m_iHurryMultiplier);
	stream->Read(&m_iBaseTrade);
	stream->Read(&m_iTradeMultiplier);
	stream->Read(&m_iGreatWorkCulture);
	stream->Read(&m_iEspionagePoints);
	stream->Read(&m_iCombat);
	stream->Read(&m_iCombatLimit);
	stream->Read(&m_iAirCombat);
	stream->Read(&m_iAirCombatLimit);
	stream->Read(&m_iXPValueAttack);
	stream->Read(&m_iXPValueDefense);
	stream->Read(&m_iFirstStrikes);
	stream->Read(&m_iChanceFirstStrikes);
	stream->Read(&m_iInterceptionProbability);
	stream->Read(&m_iEvasionProbability);
	stream->Read(&m_iWithdrawalProbability);
	stream->Read(&m_iCollateralDamage);
	stream->Read(&m_iCollateralDamageLimit);
	stream->Read(&m_iCollateralDamageMaxUnits);
	stream->Read(&m_iCityAttackModifier);
	stream->Read(&m_iCityDefenseModifier);
	stream->Read(&m_iAnimalCombatModifier);
	stream->Read(&m_iHillsAttackModifier);
	stream->Read(&m_iHillsDefenseModifier);
	stream->Read(&m_iBombRate);
	stream->Read(&m_iBombardRate);
	stream->Read(&m_iSpecialCargo);
	stream->Read(&m_iDomainCargo);
	stream->Read(&m_iCargoSpace);
	stream->Read(&m_iConscriptionValue);
	stream->Read(&m_iCultureGarrisonValue);
	stream->Read(&m_iExtraCost);
	stream->Read(&m_iAssetValue);
	stream->Read(&m_iPowerValue);
	stream->Read(&m_iUnitClassType);
	stream->Read(&m_iSpecialUnitType);
	stream->Read(&m_iUnitCaptureClassType);
	stream->Read(&m_iUnitCombatType);
	stream->Read(&m_iDomainType);
	stream->Read(&m_iDefaultUnitAIType);
	stream->Read(&m_iInvisibleType);

	int iNumInvisibleTypes;
	stream->Read(&iNumInvisibleTypes);
	for(int i=0;i<iNumInvisibleTypes;i++)
	{
		int iSeeInvisibleType;
		stream->Read(&iSeeInvisibleType);
		m_aiSeeInvisibleTypes.push_back(iSeeInvisibleType);
	}

/*************************************************************************************************/
/**	SPEEDTWEAK (CAR MOD) merged Sephi                                         					**/
/**																								**/
/**	                                                                 							**/
/*************************************************************************************************/
	int iNumUpgradeUnitClassTypes;
	stream->Read(&iNumUpgradeUnitClassTypes);
	for(int i=0; i<iNumUpgradeUnitClassTypes;i++)
	{
		int iUnitClassType;
		stream->Read(&iUnitClassType);
		m_aiUpgradeUnitClassTypes.push_back(iUnitClassType);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	stream->Read(&m_iAdvisorType);
	stream->Read(&m_iHolyCity);
	stream->Read(&m_iReligionType);
	stream->Read(&m_iStateReligion);
	stream->Read(&m_iPrereqReligion);
	stream->Read(&m_iPrereqCorporation);
	stream->Read(&m_iPrereqBuilding);
	stream->Read(&m_iPrereqAndTech);
	stream->Read(&m_iPrereqAndBonus);
	stream->Read(&m_iGroupSize);
	stream->Read(&m_iGroupDefinitions);
	stream->Read(&m_iUnitMeleeWaveSize);
	stream->Read(&m_iUnitRangedWaveSize);
	stream->Read(&m_iNumUnitNames);
	stream->Read(&m_iCommandType);

	stream->Read(&m_bAnimal);
	stream->Read(&m_bFoodProduction);
	stream->Read(&m_bNoBadGoodies);
	stream->Read(&m_bOnlyDefensive);
	stream->Read(&m_bNoCapture);
	stream->Read(&m_bQuickCombat);
	stream->Read(&m_bRivalTerritory);
	stream->Read(&m_bMilitaryHappiness);
	stream->Read(&m_bMilitarySupport);
	stream->Read(&m_bMilitaryProduction);
	stream->Read(&m_bNoPillage);
	stream->Read(&m_bSpy);
	stream->Read(&m_bSabotage);
	stream->Read(&m_bDestroy);
	stream->Read(&m_bStealPlans);
	stream->Read(&m_bInvestigate);
	stream->Read(&m_bCounterSpy);
	stream->Read(&m_bFound);
	stream->Read(&m_bGoldenAge);
	stream->Read(&m_bInvisible);
	stream->Read(&m_bFirstStrikeImmune);
	stream->Read(&m_bNoDefensiveBonus);
	stream->Read(&m_bIgnoreBuildingDefense);
	stream->Read(&m_bCanMoveImpassable);
	stream->Read(&m_bCanMoveAllTerrain);
	stream->Read(&m_bFlatMovementCost);
	stream->Read(&m_bIgnoreTerrainCost);
	stream->Read(&m_bNukeImmune);
	stream->Read(&m_bPrereqBonuses);
	stream->Read(&m_bPrereqReligion);
	stream->Read(&m_bMechanized);
	stream->Read(&m_bRenderBelowWater);
	stream->Read(&m_bRenderAlways);
	stream->Read(&m_bSuicide);
	stream->Read(&m_bLineOfSight);
	stream->Read(&m_bHiddenNationality);
	stream->Read(&m_bAlwaysHostile);
	stream->Read(&m_bNoRevealMap);

	stream->Read(&m_fUnitMaxSpeed);
	stream->Read(&m_fUnitPadTime);

//FfH Units: Added by Kael 08/04/2007
	stream->Read(&m_bAbandon);
	stream->Read(&m_bAutoRaze);
	stream->Read(&m_bDisableUpgradeTo);
	stream->Read(&m_bExplodeInCombat);
	stream->Read(&m_bImmortal);
	stream->Read(&m_bImmuneToDefensiveStrike);
	stream->Read(&m_bNeverObsolete);
	stream->Read(&m_bNoWarWeariness);
	stream->Read(&m_iCombatDefense);
	stream->Read(&m_iDefensiveStrikeChance);
	stream->Read(&m_iDefensiveStrikeDamage);
	stream->Read(&m_iDiploVoteType);
	stream->Read(&m_iDurationFromCombat);
	stream->Read(&m_iEnslavementChance);
	stream->Read(&m_iFreePromotionPick);
	stream->Read(&m_iGoldFromCombat);
	stream->Read(&m_iMinLevel);
	stream->Read(&m_iMiscastChance);
	stream->Read(&m_iModifyGlobalCounter);
	stream->Read(&m_iEquipmentPromotion);
	stream->Read(&m_iPrereqAlignment);
	stream->Read(&m_iPrereqBuildingClass);
	stream->Read(&m_iPrereqCiv);
	stream->Read(&m_iPrereqCivic);
	stream->Read(&m_iPrereqGlobalCounter);
	stream->Read(&m_iPromotionFromCombat);
	stream->Read(&m_iTier);
	stream->Read(&m_iUnitConvertFromCombat);
	stream->Read(&m_iUnitConvertFromCombatChance);
	stream->Read(&m_iUnitCreateFromCombat);
	stream->Read(&m_iUnitCreateFromCombatChance);
	stream->Read(&m_iUpgradeCiv);
	stream->Read(&m_iWeaponTier);
	stream->Read(&m_iWithdrawlProbDefensive);
	stream->ReadString(m_szImage);
	stream->ReadString(m_szPyPostCombatLost);
	stream->ReadString(m_szPyPostCombatWon);

	SAFE_DELETE_ARRAY(m_piBonusAffinity);
	m_piBonusAffinity = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusAffinity);

	SAFE_DELETE_ARRAY(m_piDamageTypeCombat);
	m_piDamageTypeCombat = new int[GC.getNumDamageTypeInfos()];
	stream->Read(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);
//FfH: End Add

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    stream->Read(&m_bAIblockExplore);
    stream->Read(&m_bAIblockPatrol);
    stream->Read(&m_bAIblockPermDefense);
    stream->Read(&m_bBarbarianSpawn);
	stream->Read(&m_bArcaneAura);

    SAFE_DELETE_ARRAY(m_piBonusAptitude);
	m_piBonusAptitude = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusAptitude);

    stream->Read(&m_iAppearanceProb);

	SAFE_DELETE_ARRAY(m_piAppearanceTechs);
	m_piAppearanceTechs = new int[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_piAppearanceTechs);

    stream->Read(&m_iFaithUpkeep);
    stream->Read(&m_iManaUpkeep);
	stream->Read(&m_iCombatAuraType);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Units can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	stream->Read(&m_iRequiredGameOption);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	stream->Read(&m_bDefensiveStrikes);
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Read(&m_iCorporationSupportNeeded);
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupport);

	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	m_piPrereqAndTechs = new int[GC.getNUM_UNIT_AND_TECH_PREREQS()];
	stream->Read(GC.getNUM_UNIT_AND_TECH_PREREQS(), m_piPrereqAndTechs);

	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	m_piPrereqOrBonuses = new int[GC.getNUM_UNIT_PREREQ_OR_BONUSES()];
	stream->Read(GC.getNUM_UNIT_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);

	SAFE_DELETE_ARRAY(m_piProductionTraits);
	m_piProductionTraits = new int[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_piProductionTraits);

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piTerrainAttackModifier);
	m_piTerrainAttackModifier = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainAttackModifier);

	SAFE_DELETE_ARRAY(m_piTerrainDefenseModifier);
	m_piTerrainDefenseModifier = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainDefenseModifier);

	SAFE_DELETE_ARRAY(m_piFeatureAttackModifier);
	m_piFeatureAttackModifier = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureAttackModifier);

	SAFE_DELETE_ARRAY(m_piFeatureDefenseModifier);
	m_piFeatureDefenseModifier = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeatureDefenseModifier);

	SAFE_DELETE_ARRAY(m_piUnitClassAttackModifier);
	m_piUnitClassAttackModifier = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piUnitClassAttackModifier);

	SAFE_DELETE_ARRAY(m_piUnitClassDefenseModifier);
	m_piUnitClassDefenseModifier = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piUnitClassDefenseModifier);

	SAFE_DELETE_ARRAY(m_piUnitCombatModifier);
	m_piUnitCombatModifier = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatModifier);

	SAFE_DELETE_ARRAY(m_piUnitCombatCollateralImmune);
	m_piUnitCombatCollateralImmune = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatCollateralImmune);

	SAFE_DELETE_ARRAY(m_piDomainModifier);
	m_piDomainModifier = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainModifier);

	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	m_piBonusProductionModifier = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusProductionModifier);

	SAFE_DELETE_ARRAY(m_piUnitGroupRequired);
	m_piUnitGroupRequired = new int[m_iGroupDefinitions];
	stream->Read(m_iGroupDefinitions, m_piUnitGroupRequired);

	SAFE_DELETE_ARRAY(m_pbUpgradeUnitClass);
	m_pbUpgradeUnitClass = new bool[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_pbUpgradeUnitClass);

	SAFE_DELETE_ARRAY(m_pbTargetUnitClass);
	m_pbTargetUnitClass = new bool[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_pbTargetUnitClass);

	SAFE_DELETE_ARRAY(m_pbTargetUnitCombat);
	m_pbTargetUnitCombat = new bool[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pbTargetUnitCombat);

	SAFE_DELETE_ARRAY(m_pbDefenderUnitClass);
	m_pbDefenderUnitClass = new bool[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_pbDefenderUnitClass);

	SAFE_DELETE_ARRAY(m_pbDefenderUnitCombat);
	m_pbDefenderUnitCombat = new bool[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_pbDefenderUnitCombat);

	SAFE_DELETE_ARRAY(m_piFlankingStrikeUnitClass);
	m_piFlankingStrikeUnitClass = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piFlankingStrikeUnitClass);

	SAFE_DELETE_ARRAY(m_pbUnitAIType);
	m_pbUnitAIType = new bool[NUM_UNITAI_TYPES];
	stream->Read(NUM_UNITAI_TYPES, m_pbUnitAIType);

	SAFE_DELETE_ARRAY(m_pbNotUnitAIType);
	m_pbNotUnitAIType = new bool[NUM_UNITAI_TYPES];
	stream->Read(NUM_UNITAI_TYPES, m_pbNotUnitAIType);

	SAFE_DELETE_ARRAY(m_pbBuilds);
	m_pbBuilds = new bool[GC.getNumBuildInfos()];
	stream->Read(GC.getNumBuildInfos(), m_pbBuilds);

	SAFE_DELETE_ARRAY(m_piReligionSpreads);
	m_piReligionSpreads = new int[GC.getNumReligionInfos()];
	stream->Read(GC.getNumReligionInfos(), m_piReligionSpreads);

	SAFE_DELETE_ARRAY(m_piCorporationSpreads);
	m_piCorporationSpreads = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_piCorporationSpreads);

	SAFE_DELETE_ARRAY(m_piTerrainPassableTech);
	m_piTerrainPassableTech = new int[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_piTerrainPassableTech);

	SAFE_DELETE_ARRAY(m_piFeaturePassableTech);
	m_piFeaturePassableTech = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_piFeaturePassableTech);

	SAFE_DELETE_ARRAY(m_pbGreatPeoples);
	m_pbGreatPeoples = new bool[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_pbGreatPeoples);

	SAFE_DELETE_ARRAY(m_pbBuildings);
	m_pbBuildings = new bool[GC.getNumBuildingInfos()];
	stream->Read(GC.getNumBuildingInfos(), m_pbBuildings);

	SAFE_DELETE_ARRAY(m_pbForceBuildings);
	m_pbForceBuildings = new bool[GC.getNumBuildingInfos()];
	stream->Read(GC.getNumBuildingInfos(), m_pbForceBuildings);

	SAFE_DELETE_ARRAY(m_pbTerrainNative);
	m_pbTerrainNative = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainNative);

	SAFE_DELETE_ARRAY(m_pbFeatureNative);
	m_pbFeatureNative = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureNative);

	SAFE_DELETE_ARRAY(m_pbTerrainImpassable);
	m_pbTerrainImpassable = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainImpassable);

	SAFE_DELETE_ARRAY(m_pbFeatureImpassable);
	m_pbFeatureImpassable = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureImpassable);

	SAFE_DELETE_ARRAY(m_pbFreePromotions);
	m_pbFreePromotions = new bool[GC.getNumPromotionInfos()];
	stream->Read(GC.getNumPromotionInfos(), m_pbFreePromotions);

	stream->Read(&m_iLeaderPromotion);
	stream->Read(&m_iLeaderExperience);

	SAFE_DELETE_ARRAY(m_paszEarlyArtDefineTags);
	m_paszEarlyArtDefineTags = new CvString [m_iGroupDefinitions];
	stream->ReadString(m_iGroupDefinitions, m_paszEarlyArtDefineTags);

	SAFE_DELETE_ARRAY(m_paszLateArtDefineTags);
	m_paszLateArtDefineTags = new CvString [m_iGroupDefinitions];
	stream->ReadString(m_iGroupDefinitions, m_paszLateArtDefineTags);

	SAFE_DELETE_ARRAY(m_paszMiddleArtDefineTags);
	m_paszMiddleArtDefineTags = new CvString [m_iGroupDefinitions];
	stream->ReadString(m_iGroupDefinitions, m_paszMiddleArtDefineTags);

	SAFE_DELETE_ARRAY(m_paszUnitNames);
	m_paszUnitNames = new CvString[m_iNumUnitNames];
	stream->ReadString(m_iNumUnitNames, m_paszUnitNames);

	stream->ReadString(m_szFormationType);

	updateArtDefineButton();
}

void CvUnitInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iAIWeight);
	stream->Write(m_iProductionCost);
	stream->Write(m_iHurryCostModifier);
	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);
	stream->Write(m_iMinAreaSize);
	stream->Write(m_iMoves);
	stream->Write(m_iAirRange);
	stream->Write(m_iAirUnitCap);
	stream->Write(m_iDropRange);
	stream->Write(m_iNukeRange);
	stream->Write(m_iWorkRate);
	stream->Write(m_iBaseDiscover);
	stream->Write(m_iDiscoverMultiplier);
	stream->Write(m_iBaseHurry);
	stream->Write(m_iHurryMultiplier);
	stream->Write(m_iBaseTrade);
	stream->Write(m_iTradeMultiplier);
	stream->Write(m_iGreatWorkCulture);
	stream->Write(m_iEspionagePoints);
	stream->Write(m_iCombat);
	stream->Write(m_iCombatLimit);
	stream->Write(m_iAirCombat);
	stream->Write(m_iAirCombatLimit);
	stream->Write(m_iXPValueAttack);
	stream->Write(m_iXPValueDefense);
	stream->Write(m_iFirstStrikes);
	stream->Write(m_iChanceFirstStrikes);
	stream->Write(m_iInterceptionProbability);
	stream->Write(m_iEvasionProbability);
	stream->Write(m_iWithdrawalProbability);
	stream->Write(m_iCollateralDamage);
	stream->Write(m_iCollateralDamageLimit);
	stream->Write(m_iCollateralDamageMaxUnits);
	stream->Write(m_iCityAttackModifier);
	stream->Write(m_iCityDefenseModifier);
	stream->Write(m_iAnimalCombatModifier);
	stream->Write(m_iHillsAttackModifier);
	stream->Write(m_iHillsDefenseModifier);
	stream->Write(m_iBombRate);
	stream->Write(m_iBombardRate);
	stream->Write(m_iSpecialCargo);
	stream->Write(m_iDomainCargo);
	stream->Write(m_iCargoSpace);
	stream->Write(m_iConscriptionValue);
	stream->Write(m_iCultureGarrisonValue);
	stream->Write(m_iExtraCost);
	stream->Write(m_iAssetValue);
	stream->Write(m_iPowerValue);
	stream->Write(m_iUnitClassType);
	stream->Write(m_iSpecialUnitType);
	stream->Write(m_iUnitCaptureClassType);
	stream->Write(m_iUnitCombatType);
	stream->Write(m_iDomainType);
	stream->Write(m_iDefaultUnitAIType);
	stream->Write(m_iInvisibleType);

	stream->Write((int)m_aiSeeInvisibleTypes.size());
	for(int i=0;i<(int)m_aiSeeInvisibleTypes.size();i++)
	{
		stream->Write(m_aiSeeInvisibleTypes[i]);
	}

/*************************************************************************************************/
/**	SPEEDTWEAK (CAR MOD) merged Sephi                                         					**/
/**																								**/
/**	                                                                 							**/
/*************************************************************************************************/
	stream->Write((int)m_aiUpgradeUnitClassTypes.size());
	for(int i=0;i<(int)m_aiUpgradeUnitClassTypes.size();i++)
	{
		stream->Write(m_aiUpgradeUnitClassTypes[i]);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	stream->Write(m_iAdvisorType);
	stream->Write(m_iHolyCity);
	stream->Write(m_iReligionType);
	stream->Write(m_iStateReligion);
	stream->Write(m_iPrereqReligion);
	stream->Write(m_iPrereqCorporation);
	stream->Write(m_iPrereqBuilding);
	stream->Write(m_iPrereqAndTech);
	stream->Write(m_iPrereqAndBonus);
	stream->Write(m_iGroupSize);
	stream->Write(m_iGroupDefinitions);
	stream->Write(m_iUnitMeleeWaveSize);
	stream->Write(m_iUnitRangedWaveSize);
	stream->Write(m_iNumUnitNames);
	stream->Write(m_iCommandType);

	stream->Write(m_bAnimal);
	stream->Write(m_bFoodProduction);
	stream->Write(m_bNoBadGoodies);
	stream->Write(m_bOnlyDefensive);
	stream->Write(m_bNoCapture);
	stream->Write(m_bQuickCombat);
	stream->Write(m_bRivalTerritory);
	stream->Write(m_bMilitaryHappiness);
	stream->Write(m_bMilitarySupport);
	stream->Write(m_bMilitaryProduction);
	stream->Write(m_bNoPillage);
	stream->Write(m_bSpy);
	stream->Write(m_bSabotage);
	stream->Write(m_bDestroy);
	stream->Write(m_bStealPlans);
	stream->Write(m_bInvestigate);
	stream->Write(m_bCounterSpy);
	stream->Write(m_bFound);
	stream->Write(m_bGoldenAge);
	stream->Write(m_bInvisible);
	stream->Write(m_bFirstStrikeImmune);
	stream->Write(m_bNoDefensiveBonus);
	stream->Write(m_bIgnoreBuildingDefense);
	stream->Write(m_bCanMoveImpassable);
	stream->Write(m_bCanMoveAllTerrain);
	stream->Write(m_bFlatMovementCost);
	stream->Write(m_bIgnoreTerrainCost);
	stream->Write(m_bNukeImmune);
	stream->Write(m_bPrereqBonuses);
	stream->Write(m_bPrereqReligion);
	stream->Write(m_bMechanized);
	stream->Write(m_bRenderBelowWater);
	stream->Write(m_bRenderAlways);
	stream->Write(m_bSuicide);
	stream->Write(m_bLineOfSight);
	stream->Write(m_bHiddenNationality);
	stream->Write(m_bAlwaysHostile);
	stream->Write(m_bNoRevealMap);

	stream->Write(m_fUnitMaxSpeed);
	stream->Write(m_fUnitPadTime);

//FfH Units: Added by Kael 08/04/2007
	stream->Write(m_bAbandon);
	stream->Write(m_bAutoRaze);
	stream->Write(m_bDisableUpgradeTo);
	stream->Write(m_bExplodeInCombat);
	stream->Write(m_bImmortal);
	stream->Write(m_bImmuneToDefensiveStrike);
	stream->Write(m_bNeverObsolete);
	stream->Write(m_bNoWarWeariness);
	stream->Write(m_iCombatDefense);
	stream->Write(m_iDefensiveStrikeChance);
	stream->Write(m_iDefensiveStrikeDamage);
	stream->Write(m_iDiploVoteType);
	stream->Write(m_iDurationFromCombat);
	stream->Write(m_iEnslavementChance);
	stream->Write(m_iFreePromotionPick);
	stream->Write(m_iGoldFromCombat);
	stream->Write(m_iMinLevel);
	stream->Write(m_iMiscastChance);
	stream->Write(m_iModifyGlobalCounter);
	stream->Write(m_iEquipmentPromotion);
	stream->Write(m_iPrereqAlignment);
	stream->Write(m_iPrereqBuildingClass);
	stream->Write(m_iPrereqCiv);
	stream->Write(m_iPrereqCivic);
	stream->Write(m_iPrereqGlobalCounter);
	stream->Write(m_iPromotionFromCombat);
	stream->Write(m_iTier);
	stream->Write(m_iUnitConvertFromCombat);
	stream->Write(m_iUnitConvertFromCombatChance);
	stream->Write(m_iUnitCreateFromCombat);
	stream->Write(m_iUnitCreateFromCombatChance);
	stream->Write(m_iUpgradeCiv);
	stream->Write(m_iWeaponTier);
	stream->Write(m_iWithdrawlProbDefensive);
	stream->WriteString(m_szImage);
	stream->WriteString(m_szPyPostCombatLost);
	stream->WriteString(m_szPyPostCombatWon);

	stream->Write(GC.getNumBonusInfos(), m_piBonusAffinity);
	stream->Write(GC.getNumDamageTypeInfos(), m_piDamageTypeCombat);
//FfH: End Add

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    stream->Write(m_bAIblockExplore);
    stream->Write(m_bAIblockPatrol);
    stream->Write(m_bAIblockPermDefense);
    stream->Write(m_bBarbarianSpawn);
	stream->Write(m_bArcaneAura);
	stream->Write(GC.getNumBonusInfos(), m_piBonusAptitude);
    stream->Write(m_iAppearanceProb);
    stream->Write(GC.getNumTechInfos(), m_piAppearanceTechs);

    stream->Write(m_iFaithUpkeep);
    stream->Write(m_iManaUpkeep);
	stream->Write(m_iCombatAuraType);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Units can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	stream->Write(m_iRequiredGameOption);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	stream->Write(m_bDefensiveStrikes);
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Write(m_iCorporationSupportNeeded);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupport);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	stream->Write(GC.getNUM_UNIT_AND_TECH_PREREQS(), m_piPrereqAndTechs);
	stream->Write(GC.getNUM_UNIT_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);
	stream->Write(GC.getNumTraitInfos(), m_piProductionTraits);
	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainAttackModifier);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainDefenseModifier);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureAttackModifier);
	stream->Write(GC.getNumFeatureInfos(), m_piFeatureDefenseModifier);
	stream->Write(GC.getNumUnitClassInfos(), m_piUnitClassAttackModifier);
	stream->Write(GC.getNumUnitClassInfos(), m_piUnitClassDefenseModifier);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatModifier);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatCollateralImmune);
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainModifier);
	stream->Write(GC.getNumBonusInfos(), m_piBonusProductionModifier);
	stream->Write(m_iGroupDefinitions, m_piUnitGroupRequired);

	stream->Write(GC.getNumUnitClassInfos(), m_pbUpgradeUnitClass);
	stream->Write(GC.getNumUnitClassInfos(), m_pbTargetUnitClass);
	stream->Write(GC.getNumUnitCombatInfos(), m_pbTargetUnitCombat);
	stream->Write(GC.getNumUnitClassInfos(), m_pbDefenderUnitClass);
	stream->Write(GC.getNumUnitCombatInfos(), m_pbDefenderUnitCombat);
	stream->Write(GC.getNumUnitClassInfos(), m_piFlankingStrikeUnitClass);
	stream->Write(NUM_UNITAI_TYPES, m_pbUnitAIType);
	stream->Write(NUM_UNITAI_TYPES, m_pbNotUnitAIType);
	stream->Write(GC.getNumBuildInfos(), m_pbBuilds);
	stream->Write(GC.getNumReligionInfos(), m_piReligionSpreads);
	stream->Write(GC.getNumCorporationInfos(), m_piCorporationSpreads);
	stream->Write(GC.getNumTerrainInfos(), m_piTerrainPassableTech);
	stream->Write(GC.getNumFeatureInfos(), m_piFeaturePassableTech);
	stream->Write(GC.getNumSpecialistInfos(), m_pbGreatPeoples);
	stream->Write(GC.getNumBuildingInfos(), m_pbBuildings);
	stream->Write(GC.getNumBuildingInfos(), m_pbForceBuildings);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainNative);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureNative);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainImpassable);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureImpassable);
	stream->Write(GC.getNumPromotionInfos(), m_pbFreePromotions);
	stream->Write(m_iLeaderPromotion);
	stream->Write(m_iLeaderExperience);

	stream->WriteString(m_iGroupDefinitions, m_paszEarlyArtDefineTags);
	stream->WriteString(m_iGroupDefinitions, m_paszLateArtDefineTags);
	stream->WriteString(m_iGroupDefinitions, m_paszMiddleArtDefineTags);
	stream->WriteString(m_iNumUnitNames, m_paszUnitNames);

	stream->WriteString(m_szFormationType);
}

//
// read from xml
//
bool CvUnitInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	int j=0;				//loop counter
	int k=0;				//loop counter
	int iNumSibs=0;				// the number of siblings the current xml node has
	int iIndexVal;

	pXML->GetChildXmlValByName(szTextVal, "Class");
	m_iUnitClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Special");
	m_iSpecialUnitType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Capture");
	m_iUnitCaptureClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Combat");
	m_iUnitCombatType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Domain", "DOMAIN_LAND");
	m_iDomainType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DefaultUnitAI", "UNITAI_UNKNOWN");
	m_iDefaultUnitAIType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Invisible");
	m_iInvisibleType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SeeInvisible");
	std::vector<CvString> tokens;
	szTextVal.getTokens(",", tokens);
	for(int i=0;i<(int)tokens.size();i++)
	{
		int iInvisibleType = pXML->FindInInfoClass(tokens[i]);
		if(iInvisibleType != NO_INVISIBLE)
		{
			m_aiSeeInvisibleTypes.push_back(iInvisibleType);
		}
	}

	pXML->GetChildXmlValByName(szTextVal, "Advisor");
	m_iAdvisorType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bAnimal, "bAnimal");
	pXML->GetChildXmlValByName(&m_bFoodProduction, "bFood");
	pXML->GetChildXmlValByName(&m_bNoBadGoodies, "bNoBadGoodies");
	pXML->GetChildXmlValByName(&m_bOnlyDefensive, "bOnlyDefensive");
	pXML->GetChildXmlValByName(&m_bNoCapture, "bNoCapture");
	pXML->GetChildXmlValByName(&m_iCaptureDifficulty, "iCaptureDifficulty");
	pXML->GetChildXmlValByName(&m_bQuickCombat, "bQuickCombat");
	pXML->GetChildXmlValByName(&m_bRivalTerritory, "bRivalTerritory");
	pXML->GetChildXmlValByName(&m_bMilitaryHappiness, "bMilitaryHappiness", true);
	pXML->GetChildXmlValByName(&m_bMilitarySupport, "bMilitarySupport", true);
	pXML->GetChildXmlValByName(&m_bMilitaryProduction, "bMilitaryProduction", true);
	pXML->GetChildXmlValByName(&m_bNoPillage, "bNoPillage");
	pXML->GetChildXmlValByName(&m_bSpy, "bSpy");
	pXML->GetChildXmlValByName(&m_bCanUpgradeManaNodes, "bCanUpgradeManaNodes");
	pXML->GetChildXmlValByName(&m_bSabotage, "bSabotage");
	pXML->GetChildXmlValByName(&m_bDestroy, "bDestroy");
	pXML->GetChildXmlValByName(&m_bStealPlans, "bStealPlans");
	pXML->GetChildXmlValByName(&m_bInvestigate, "bInvestigate");
	pXML->GetChildXmlValByName(&m_bCounterSpy, "bCounterSpy");
	pXML->GetChildXmlValByName(&m_bFound, "bFound");
	pXML->GetChildXmlValByName(&m_bGoldenAge, "bGoldenAge");
	pXML->GetChildXmlValByName(&m_bInvisible, "bInvisible");
	pXML->GetChildXmlValByName(&m_bFirstStrikeImmune, "bFirstStrikeImmune");
	pXML->GetChildXmlValByName(&m_bNoDefensiveBonus, "bNoDefensiveBonus");
	pXML->GetChildXmlValByName(&m_bIgnoreBuildingDefense, "bIgnoreBuildingDefense");
	pXML->GetChildXmlValByName(&m_bCanMoveImpassable, "bCanMoveImpassable");
	pXML->GetChildXmlValByName(&m_bCanMoveAllTerrain, "bCanMoveAllTerrain");
	pXML->GetChildXmlValByName(&m_bFlatMovementCost, "bFlatMovementCost");
	pXML->GetChildXmlValByName(&m_bIgnoreTerrainCost, "bIgnoreTerrainCost");
	pXML->GetChildXmlValByName(&m_bNukeImmune, "bNukeImmune");
	pXML->GetChildXmlValByName(&m_bPrereqBonuses, "bPrereqBonuses");
	pXML->GetChildXmlValByName(&m_bPrereqReligion, "bPrereqReligion");
	pXML->GetChildXmlValByName(&m_bMechanized,"bMechanized",false);
	pXML->GetChildXmlValByName(&m_bRenderBelowWater,"bRenderBelowWater",false);
	pXML->GetChildXmlValByName(&m_bRenderAlways,"bRenderAlways",false);
	pXML->GetChildXmlValByName(&m_bSuicide,"bSuicide");
	pXML->GetChildXmlValByName(&m_bLineOfSight,"bLineOfSight",false);
	pXML->GetChildXmlValByName(&m_bHiddenNationality,"bHiddenNationality",false);
	pXML->GetChildXmlValByName(&m_bAlwaysHostile,"bAlwaysHostile",false);
	pXML->GetChildXmlValByName(&m_bNoRevealMap,"bNoRevealMap",false);

	pXML->SetVariableListTagPair(&m_pbUpgradeUnitClass, "UnitClassUpgrades", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_pbTargetUnitClass, "UnitClassTargets", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_pbTargetUnitCombat, "UnitCombatTargets", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_pbDefenderUnitClass, "UnitClassDefenders", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_pbDefenderUnitCombat, "UnitCombatDefenders", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_piFlankingStrikeUnitClass, "FlankingStrikes", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_pbUnitAIType, "UnitAIs", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);
	pXML->SetVariableListTagPair(&m_pbNotUnitAIType, "NotUnitAIs", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);

	pXML->SetVariableListTagPair(&m_pbBuilds, "Builds", sizeof(GC.getBuildInfo((BuildTypes)0)), GC.getNumBuildInfos());

	pXML->SetVariableListTagPair(&m_piReligionSpreads, "ReligionSpreads", sizeof(GC.getReligionInfo((ReligionTypes)0)), GC.getNumReligionInfos());
	pXML->SetVariableListTagPair(&m_piCorporationSpreads, "CorporationSpreads", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());

	CvString* pszTemp = NULL;
	pXML->SetVariableListTagPair(&pszTemp, "TerrainPassableTechs", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	m_piTerrainPassableTech = new int[GC.getNumTerrainInfos()];
	for (int i = 0; i < GC.getNumTerrainInfos(); ++i)
	{
		m_piTerrainPassableTech[i] = pszTemp[i].IsEmpty() ? NO_TECH : pXML->FindInInfoClass(pszTemp[i]);
	}
	SAFE_DELETE_ARRAY(pszTemp);

	pXML->SetVariableListTagPair(&pszTemp, "FeaturePassableTechs", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	m_piFeaturePassableTech = new int[GC.getNumFeatureInfos()];
	for (int i = 0; i < GC.getNumFeatureInfos(); ++i)
	{
		m_piFeaturePassableTech[i] = pszTemp[i].IsEmpty() ? NO_TECH : pXML->FindInInfoClass(pszTemp[i]);
	}
	SAFE_DELETE_ARRAY(pszTemp);

	pXML->SetVariableListTagPair(&m_pbGreatPeoples, "GreatPeoples", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	pXML->SetVariableListTagPair(&m_pbBuildings, "Buildings", sizeof(GC.getBuildingInfo((BuildingTypes)0)), GC.getNumBuildingInfos());
	pXML->SetVariableListTagPair(&m_pbForceBuildings, "ForceBuildings", sizeof(GC.getBuildingInfo((BuildingTypes)0)), GC.getNumBuildingInfos());

	pXML->GetChildXmlValByName(szTextVal, "HolyCity");
	m_iHolyCity = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ReligionType");
	m_iReligionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StateReligion");
	m_iStateReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqCorporation");
	m_iPrereqCorporation = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqBuilding");
	m_iPrereqBuilding = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iPrereqAndTech = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechTypes"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_UNIT_AND_TECH_PREREQS()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_UNIT_AND_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_UNIT_AND_TECH_PREREQS()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (j=0;j<iNumSibs;j++)
					{
						m_piPrereqAndTechs[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_UNIT_AND_TECH_PREREQS(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "BonusType");
	m_iPrereqAndBonus = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonuses"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_UNIT_PREREQ_OR_BONUSES()),"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_UNIT_PREREQ_OR_BONUSES(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_UNIT_PREREQ_OR_BONUSES()) , "There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (j=0;j<iNumSibs;j++)
					{
						m_piPrereqOrBonuses[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_UNIT_PREREQ_OR_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());

	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iProductionCost, "iCost",-1);
	pXML->GetChildXmlValByName(&m_iHurryCostModifier, "iHurryCostModifier");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost",100);
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");
	pXML->GetChildXmlValByName(&m_iMinAreaSize, "iMinAreaSize",-1);
	pXML->GetChildXmlValByName(&m_iMoves, "iMoves");
	pXML->GetChildXmlValByName(&m_iAirRange, "iAirRange");
	pXML->GetChildXmlValByName(&m_iAirUnitCap, "iAirUnitCap");
	pXML->GetChildXmlValByName(&m_iDropRange, "iDropRange");
	pXML->GetChildXmlValByName(&m_iNukeRange, "iNukeRange",-1);
	pXML->GetChildXmlValByName(&m_iWorkRate, "iWorkRate");
	pXML->GetChildXmlValByName(&m_iBaseDiscover, "iBaseDiscover");
	pXML->GetChildXmlValByName(&m_iDiscoverMultiplier, "iDiscoverMultiplier");
	pXML->GetChildXmlValByName(&m_iBaseHurry, "iBaseHurry");
	pXML->GetChildXmlValByName(&m_iHurryMultiplier, "iHurryMultiplier");
	pXML->GetChildXmlValByName(&m_iBaseTrade, "iBaseTrade");
	pXML->GetChildXmlValByName(&m_iTradeMultiplier, "iTradeMultiplier");
	pXML->GetChildXmlValByName(&m_iGreatWorkCulture, "iGreatWorkCulture");
	pXML->GetChildXmlValByName(&m_iEspionagePoints, "iEspionagePoints");

	pXML->SetVariableListTagPair(&m_pbTerrainImpassable, "TerrainImpassables", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos(), false);
	pXML->SetVariableListTagPair(&m_pbFeatureImpassable, "FeatureImpassables", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos(), false);

	pXML->GetChildXmlValByName(&m_iCombat, "iCombat");
	pXML->GetChildXmlValByName(&m_iCombatLimit, "iCombatLimit",100);
	pXML->GetChildXmlValByName(&m_iAirCombat, "iAirCombat");
	pXML->GetChildXmlValByName(&m_iAirCombatLimit, "iAirCombatLimit");
	pXML->GetChildXmlValByName(&m_iXPValueAttack, "iXPValueAttack",8);
	pXML->GetChildXmlValByName(&m_iXPValueDefense, "iXPValueDefense",4);
	pXML->GetChildXmlValByName(&m_iFirstStrikes, "iFirstStrikes");
	pXML->GetChildXmlValByName(&m_iChanceFirstStrikes, "iChanceFirstStrikes");
	pXML->GetChildXmlValByName(&m_iInterceptionProbability, "iInterceptionProbability");
	pXML->GetChildXmlValByName(&m_iEvasionProbability, "iEvasionProbability");
	pXML->GetChildXmlValByName(&m_iWithdrawalProbability, "iWithdrawalProb");
	pXML->GetChildXmlValByName(&m_iCollateralDamage, "iCollateralDamage");
	pXML->GetChildXmlValByName(&m_iCollateralDamageLimit, "iCollateralDamageLimit");
	pXML->GetChildXmlValByName(&m_iCollateralDamageMaxUnits, "iCollateralDamageMaxUnits");
	pXML->GetChildXmlValByName(&m_iCityAttackModifier, "iCityAttack");
	pXML->GetChildXmlValByName(&m_iCityDefenseModifier, "iCityDefense");
	pXML->GetChildXmlValByName(&m_iAnimalCombatModifier, "iAnimalCombat");
	pXML->GetChildXmlValByName(&m_iHillsAttackModifier, "iHillsAttack");
	pXML->GetChildXmlValByName(&m_iHillsDefenseModifier, "iHillsDefense");

	pXML->SetVariableListTagPair(&m_pbTerrainNative, "TerrainNatives", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureNative, "FeatureNatives", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());

	pXML->SetVariableListTagPair(&m_piTerrainAttackModifier, "TerrainAttacks", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piTerrainDefenseModifier, "TerrainDefenses", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_piFeatureAttackModifier, "FeatureAttacks", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_piFeatureDefenseModifier, "FeatureDefenses", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());

	pXML->SetVariableListTagPair(&m_piUnitClassAttackModifier, "UnitClassAttackMods", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());
	pXML->SetVariableListTagPair(&m_piUnitClassDefenseModifier, "UnitClassDefenseMods", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());

	pXML->SetVariableListTagPair(&m_piUnitCombatModifier, "UnitCombatMods", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_piUnitCombatCollateralImmune, "UnitCombatCollateralImmunes", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_piDomainModifier, "DomainMods", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);

	pXML->SetVariableListTagPair(&m_piBonusProductionModifier, "BonusProductionModifiers", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());

	pXML->GetChildXmlValByName(&m_iBombRate, "iBombRate");
	pXML->GetChildXmlValByName(&m_iBombardRate, "iBombardRate");
	pXML->GetChildXmlValByName(&m_iBombardRange, "iBombardRange");

	pXML->GetChildXmlValByName(szTextVal, "SpecialCargo");
	m_iSpecialCargo = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DomainCargo");
	m_iDomainCargo = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iCargoSpace, "iCargo");
	pXML->GetChildXmlValByName(&m_iConscriptionValue, "iConscription");
	pXML->GetChildXmlValByName(&m_iCultureGarrisonValue, "iCultureGarrison");
	pXML->GetChildXmlValByName(&m_iExtraCost, "iExtraCost");
	pXML->GetChildXmlValByName(&m_iAssetValue, "iAsset");
	pXML->GetChildXmlValByName(&m_iPowerValue, "iPower");

	// Read the mesh groups elements
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UnitMeshGroups") )
	{
		pXML->GetChildXmlValByName( &m_iGroupSize, "iGroupSize");
		m_iGroupDefinitions = iIndexVal = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "UnitMeshGroup");
		m_piUnitGroupRequired = new int[ iIndexVal ];
		pXML->GetChildXmlValByName( &m_iUnitMeleeWaveSize, "iMeleeWaveSize" );
		pXML->GetChildXmlValByName( &m_iUnitRangedWaveSize, "iRangedWaveSize" );
		pXML->GetChildXmlValByName( &m_fUnitMaxSpeed, "fMaxSpeed", 1.75);
		pXML->GetChildXmlValByName( &m_fUnitPadTime, "fPadTime", 1);
		m_paszEarlyArtDefineTags = new CvString[ iIndexVal ];
		m_paszLateArtDefineTags = new CvString[ iIndexVal ];
		m_paszMiddleArtDefineTags = new CvString[ iIndexVal ];

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "UnitMeshGroup"))
		{
			for ( k = 0; k < iIndexVal; k++ )
			{
				pXML->GetChildXmlValByName( &m_piUnitGroupRequired[k], "iRequired");
				pXML->GetChildXmlValByName(szTextVal, "EarlyArtDefineTag");
				setEarlyArtDefineTag(k, szTextVal);
				pXML->GetChildXmlValByName(szTextVal, "LateArtDefineTag");
				setLateArtDefineTag(k, szTextVal);
				pXML->GetChildXmlValByName(szTextVal, "MiddleArtDefineTag");
				setMiddleArtDefineTag(k, szTextVal);
				gDLL->getXMLIFace()->NextSibling(pXML->GetXML());
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(m_szFormationType, "FormationType");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UniqueNames"))
	{
		pXML->SetStringList(&m_paszUnitNames, &m_iNumUnitNames);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->SetVariableListTagPair(&m_pbFreePromotions, "FreePromotions", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos());

	pXML->GetChildXmlValByName(szTextVal, "LeaderPromotion");
	m_iLeaderPromotion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iLeaderExperience, "iLeaderExperience");

//FfH Units: Added by Kael 08/04/2007
	pXML->GetChildXmlValByName(&m_bAbandon,"bAbandon");
	pXML->GetChildXmlValByName(&m_bAutoRaze,"bAutoRaze");
	pXML->GetChildXmlValByName(&m_bDisableUpgradeTo,"bDisableUpgradeTo");
	pXML->GetChildXmlValByName(&m_bExplodeInCombat,"bExplodeInCombat");
	pXML->GetChildXmlValByName(&m_bImmortal,"bImmortal");
	pXML->GetChildXmlValByName(&m_bImmuneToDefensiveStrike,"bImmuneToDefensiveStrike");
	pXML->GetChildXmlValByName(&m_bNeverObsolete,"bNeverObsolete");
//	pXML->GetChildXmlValByName(&m_bNoWarWeariness,"bNoWarWeariness");	No WarWeariness
	pXML->GetChildXmlValByName(&m_iCombatDefense,"iCombatDefense");
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeChance,"iDefensiveStrikeChance");
	pXML->GetChildXmlValByName(&m_iDefensiveStrikeDamage,"iDefensiveStrikeDamage");
	pXML->GetChildXmlValByName(&m_iDurationFromCombat,"iDurationFromCombat");
	pXML->GetChildXmlValByName(&m_iEnslavementChance,"iEnslavementChance");
	pXML->GetChildXmlValByName(&m_iFreePromotionPick,"iFreePromotionPick");
	pXML->GetChildXmlValByName(&m_iGoldFromCombat,"iGoldFromCombat");
	pXML->GetChildXmlValByName(&m_iMinLevel,"iMinLevel");
	pXML->GetChildXmlValByName(&m_iMiscastChance,"iMiscastChance");
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter,"iModifyGlobalCounter");
	pXML->GetChildXmlValByName(szTextVal, "DiploVoteType");
	m_iDiploVoteType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EquipmentPromotion");
	m_iEquipmentPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqBuildingClass");
	m_iPrereqBuildingClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqCivic");
	m_iPrereqCivic = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionFromCombat");
	m_iPromotionFromCombat = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iPrereqGlobalCounter,"iPrereqGlobalCounter");
	pXML->GetChildXmlValByName(m_szImage, "Image");
	pXML->GetChildXmlValByName(&m_iTier,"iTier");
	pXML->GetChildXmlValByName(&m_iUnitConvertFromCombatChance,"iUnitConvertFromCombatChance");
	pXML->GetChildXmlValByName(&m_iUnitCreateFromCombatChance,"iUnitCreateFromCombatChance");
	pXML->GetChildXmlValByName(szTextVal, "UpgradeCiv","NO_CIVILIZATION");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCiv","NO_CIVILIZATION");
	m_aszExtraXML1forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iWeaponTier,"iWeaponTier");
	pXML->GetChildXmlValByName(&m_iWithdrawlProbDefensive,"iWithdrawlProbDefensive");
	pXML->GetChildXmlValByName(m_szPyPostCombatLost, "PythonPostCombatLost");
	pXML->GetChildXmlValByName(m_szPyPostCombatWon, "PythonPostCombatWon");
	pXML->SetVariableListTagPair(&m_piDamageTypeCombat, "DamageTypeCombats", sizeof(GC.getDamageTypeInfo((DamageTypes)0)), GC.getNumDamageTypeInfos());
	pXML->SetVariableListTagPair(&m_piBonusAffinity, "BonusAffinities", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "ObsoleteTech");
	m_iObsoleteTech = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bAIblockExplore,"bAIblockExplore",false);
	pXML->GetChildXmlValByName(&m_bAIblockPermDefense,"bAIblockPermDefense",false);
	pXML->GetChildXmlValByName(&m_bAIblockPatrol,"bAIblockPatrol",false);

	pXML->GetChildXmlValByName(&m_bBarbarianSpawn,"bBarbarianSpawn",false);
	pXML->GetChildXmlValByName(&m_bWildmanaGuardian,"bWildmanaGuardian",false);
	pXML->GetChildXmlValByName(&m_bArcaneAura,"bArcaneAura",false);
	pXML->SetVariableListTagPair(&m_piBonusAptitude, "BonusAptitudes", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
    pXML->GetChildXmlValByName(&m_iArcaneRange,"iArcaneRange",1);
    pXML->GetChildXmlValByName(&m_iAppearanceProb,"iAppearanceProb",100);
    pXML->SetVariableListTagPair(&m_piAppearanceTechs, "AppearanceTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());	
    pXML->GetChildXmlValByName(&m_iFaithUpkeep,"iFaithUpkeep",0);
    pXML->GetChildXmlValByName(&m_iManaUpkeep,"iManaUpkeep",0);
	pXML->GetChildXmlValByName(szTextVal, "CombatAuraType","NONE");
	m_iCombatAuraType = pXML->FindInInfoClass(szTextVal);
//	pXML->GetChildXmlValByName(szTextVal, "ReducedCostByYieldOverwrite"); disable
//	m_iReducedCostByYieldOverwrite = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iExtraLives,"iExtraLives");
    pXML->GetChildXmlValByName(&m_iBonusNearUF,"iBonusNearUF");
    pXML->GetChildXmlValByName(&m_iPopulationCost,"iPopulationCost");
	pXML->GetChildXmlValByName(szTextVal, "GlobalYieldTypeCost");
	m_iGlobalYieldTypeCost = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iGlobalYieldCost,"iGlobalYieldCost");
    pXML->GetChildXmlValByName(&m_iMinWilderness,"iMinWilderness",0);
    pXML->GetChildXmlValByName(&m_iMaxWilderness,"iMaxWilderness",MAX_INT);
    pXML->GetChildXmlValByName(&m_bNoCitySupportNeeded,"bNoCitySupportNeeded");	
    pXML->GetChildXmlValByName(&m_bNoEquipment,"bNoEquipment");		
    pXML->GetChildXmlValByName(&m_bNoXP,"bNoXP");		
    pXML->GetChildXmlValByName(&m_bScaleWithTech,"bScaleWithTech");		
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Units can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "RequiredGameOption","NONE");
	m_iRequiredGameOption = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	pXML->GetChildXmlValByName(&m_bDefensiveStrikes,"bDefensiveStrikes");
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "iCorporationSupportNeeded","NONE");
	m_iCorporationSupportNeeded = pXML->FindInInfoClass(szTextVal);
	pXML->SetVariableListTagPair(&m_paiCorporationSupport, "CorporationSupportValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
	pXML->SetVariableListTagPair(&m_paiCorporationSupportMod, "CorporationSupportModifierValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CityCommerceChanges"))
	{
		pXML->SetCommerce(&m_piCityCommerceChanges);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCityCommerceChanges, NUM_COMMERCE_TYPES);
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** if we're using a module, assuming the meshgroup isn't set, we update first after            **/
/** the copyNonDefaults method                                                                  **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	updateArtDefineButton();
/**								----  End Original Code  ----									**/
	if (m_iGroupSize != 0)
	{
		updateArtDefineButton();
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}

//FfH Units: Added by Kael 08/04/2007
bool CvUnitInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "UnitConvertFromCombat");
	m_iUnitConvertFromCombat = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitCreateFromCombat");
	m_iUnitCreateFromCombat = pXML->FindInInfoClass(szTextVal);

	return true;
}

bool CvUnitInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iUpgradeCiv = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i].GetCString(), true) != -1)
		{
			m_iUpgradeCiv = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i].GetCString());
			break;
		}
	}

	iSize = m_aszExtraXML1forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML1forPass3[i].GetCString(), true) != -1)
		{
            m_iPrereqCiv = GC.getInfoTypeForString(m_aszExtraXML1forPass3[i].GetCString());
			break;
		}
	}
	m_aszExtraXML1forPass3.clear();
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	return true;
}

//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(UnitInfos)																	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitInfo::copyNonDefaults(CvUnitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if(isAnimal()							== false)			m_bAnimal							= pClassInfo->isAnimal();
	if(isFoodProduction()					== false)			m_bFoodProduction					= pClassInfo->isFoodProduction();
	if(isNoBadGoodies()						== false)			m_bNoBadGoodies						= pClassInfo->isNoBadGoodies();
	if(isOnlyDefensive()					== false)			m_bOnlyDefensive					= pClassInfo->isOnlyDefensive();
	if(isNoCapture()						== false)			m_bNoCapture						= pClassInfo->isNoCapture();
	if(getCaptureDifficulty()				== 0)				m_iCaptureDifficulty				= pClassInfo->getCaptureDifficulty();
	if(isQuickCombat()						== false)			m_bQuickCombat						= pClassInfo->isQuickCombat();
	if(isRivalTerritory()					== false)			m_bRivalTerritory					= pClassInfo->isRivalTerritory();
	if(isMilitaryHappiness()				== true)			m_bMilitaryHappiness				= pClassInfo->isMilitaryHappiness();
	if(isMilitarySupport()					== true)			m_bMilitarySupport					= pClassInfo->isMilitarySupport();
	if(isMilitaryProduction()				== true)			m_bMilitaryProduction				= pClassInfo->isMilitaryProduction();
	if(isNoPillage()						== false)			m_bNoPillage						= pClassInfo->isNoPillage();
	if(isSpy()								== false)			m_bSpy								= pClassInfo->isSpy();
	if(isCanUpgradeManaNodes()				== false)			m_bCanUpgradeManaNodes				= pClassInfo->isCanUpgradeManaNodes();
	if(isSabotage()							== false)			m_bSabotage							= pClassInfo->isSabotage();
	if(isDestroy()							== false)			m_bDestroy							= pClassInfo->isDestroy();
	if(isStealPlans()						== false)			m_bStealPlans						= pClassInfo->isStealPlans();
	if(isInvestigate()						== false)			m_bInvestigate						= pClassInfo->isInvestigate();
	if(isCounterSpy()						== false)			m_bCounterSpy						= pClassInfo->isCounterSpy();
	if(isFound()							== false)			m_bFound							= pClassInfo->isFound();
	if(isGoldenAge()						== false)			m_bGoldenAge						= pClassInfo->isGoldenAge();
	if(isInvisible()						== false)			m_bInvisible						= pClassInfo->isInvisible();
	if(isFirstStrikeImmune()				== false)			m_bFirstStrikeImmune				= pClassInfo->isFirstStrikeImmune();
	if(isNoDefensiveBonus()					== false)			m_bNoDefensiveBonus					= pClassInfo->isNoDefensiveBonus();
	if(isIgnoreBuildingDefense()			== false)			m_bIgnoreBuildingDefense			= pClassInfo->isIgnoreBuildingDefense();
	if(isCanMoveImpassable()				== false)			m_bCanMoveImpassable				= pClassInfo->isCanMoveImpassable();
	if(isCanMoveAllTerrain()				== false)			m_bCanMoveAllTerrain				= pClassInfo->isCanMoveAllTerrain();
	if(isFlatMovementCost()					== false)			m_bFlatMovementCost					= pClassInfo->isFlatMovementCost();
	if(isIgnoreTerrainCost()				== false)			m_bIgnoreTerrainCost				= pClassInfo->isIgnoreTerrainCost();
	if(isNukeImmune()						== false)			m_bNukeImmune						= pClassInfo->isNukeImmune();
	if(isPrereqBonuses()					== false)			m_bPrereqBonuses					= pClassInfo->isPrereqBonuses();
	if(isPrereqReligion()					== false)			m_bPrereqReligion					= pClassInfo->isPrereqReligion();
	if(isMechUnit()							== false)			m_bMechanized						= pClassInfo->isMechUnit();
	if(isRenderBelowWater()					== false)			m_bRenderBelowWater					= pClassInfo->isRenderBelowWater();
	if(isRenderAlways()						== false)			m_bRenderAlways						= pClassInfo->isRenderAlways();
	if(isSuicide()							== false)			m_bSuicide							= pClassInfo->isSuicide();
	if(isLineOfSight()						== false)			m_bLineOfSight						= pClassInfo->isLineOfSight();
	if(isHiddenNationality()				== false)			m_bHiddenNationality				= pClassInfo->isHiddenNationality();
	if(isAlwaysHostile()					== false)			m_bAlwaysHostile					= pClassInfo->isAlwaysHostile();
	if(isNoRevealMap()						== false)			m_bNoRevealMap						= pClassInfo->isNoRevealMap();
	if(isAbandon()							== false)			m_bAbandon							= pClassInfo->isAbandon();
	if(isAutoRaze()							== false)			m_bAutoRaze							= pClassInfo->isAutoRaze();
	if(isDisableUpgradeTo()					== false)			m_bDisableUpgradeTo					= pClassInfo->isDisableUpgradeTo();
	if(isExplodeInCombat()					== false)			m_bExplodeInCombat					= pClassInfo->isExplodeInCombat();
	if(isImmortal()							== false)			m_bImmortal							= pClassInfo->isImmortal();
	if(isImmuneToDefensiveStrike()			== false)			m_bImmuneToDefensiveStrike			= pClassInfo->isImmuneToDefensiveStrike();
	if(isNeverObsolete()					== false)			m_bNeverObsolete					= pClassInfo->isNeverObsolete();
	if(isNoWarWeariness()					== false)			m_bNoWarWeariness					= pClassInfo->isNoWarWeariness();
	if(getDefensiveStrikeChance()			== 0)				m_iDefensiveStrikeChance			= pClassInfo->getDefensiveStrikeChance();
	if(getDefensiveStrikeDamage()			== 0)				m_iDefensiveStrikeDamage			= pClassInfo->getDefensiveStrikeDamage();
	if(getDurationFromCombat()				== 0)				m_iDurationFromCombat				= pClassInfo->getDurationFromCombat();
	if(getEnslavementChance()				== 0)				m_iEnslavementChance				= pClassInfo->getEnslavementChance();
	if(getFreePromotionPick()				== 0)				m_iFreePromotionPick				= pClassInfo->getFreePromotionPick();
	if(getGoldFromCombat()					== 0)				m_iGoldFromCombat					= pClassInfo->getGoldFromCombat();
	if(getMinLevel()						== 0)				m_iMinLevel							= pClassInfo->getMinLevel();
	if(getMiscastChance()					== 0)				m_iMiscastChance					= pClassInfo->getMiscastChance();
	if(getModifyGlobalCounter()				== 0)				m_iModifyGlobalCounter				= pClassInfo->getModifyGlobalCounter();
	if(getPrereqGlobalCounter()				== 0)				m_iPrereqGlobalCounter				= pClassInfo->getPrereqGlobalCounter();
	if(getUnitConvertFromCombatChance()		== 0)				m_iUnitConvertFromCombatChance		= pClassInfo->getUnitConvertFromCombatChance();
	if(getUnitCreateFromCombatChance()		== 0)				m_iUnitCreateFromCombatChance		= pClassInfo->getUnitCreateFromCombatChance();
	if(getWithdrawlProbDefensive()			== 0)				m_iWithdrawlProbDefensive			= pClassInfo->getWithdrawlProbDefensive();
	if(getAIWeight()						== 0)				m_iAIWeight							= pClassInfo->getAIWeight();
	if(getHurryCostModifier()				== 0)				m_iHurryCostModifier				= pClassInfo->getHurryCostModifier();
	if(getAdvancedStartCostIncrease()		== 0)				m_iAdvancedStartCostIncrease		= pClassInfo->getAdvancedStartCostIncrease();
	if(getMoves()							== 0)				m_iMoves							= pClassInfo->getMoves();
	if(getAirRange()						== 0)				m_iAirRange							= pClassInfo->getAirRange();
	if(getAirUnitCap()						== 0)				m_iAirUnitCap						= pClassInfo->getAirUnitCap();
	if(getDropRange()						== 0)				m_iDropRange						= pClassInfo->getDropRange();
	if(getWorkRate()						== 0)				m_iWorkRate							= pClassInfo->getWorkRate();
	if(getBaseDiscover()					== 0)				m_iBaseDiscover						= pClassInfo->getBaseDiscover();
	if(getDiscoverMultiplier()				== 0)				m_iDiscoverMultiplier				= pClassInfo->getDiscoverMultiplier();
	if(getBaseHurry()						== 0)				m_iBaseHurry						= pClassInfo->getBaseHurry();
	if(getHurryMultiplier()					== 0)				m_iHurryMultiplier					= pClassInfo->getHurryMultiplier();
	if(getBaseTrade()						== 0)				m_iBaseTrade						= pClassInfo->getBaseTrade();
	if(getTradeMultiplier()					== 0)				m_iTradeMultiplier					= pClassInfo->getTradeMultiplier();
	if(getGreatWorkCulture()				== 0)				m_iGreatWorkCulture					= pClassInfo->getGreatWorkCulture();
	if(getEspionagePoints()					== 0)				m_iEspionagePoints					= pClassInfo->getEspionagePoints();
	if(getAirCombat()						== 0)				m_iAirCombat						= pClassInfo->getAirCombat();
	if(getAirCombatLimit()					== 0)				m_iAirCombatLimit					= pClassInfo->getAirCombatLimit();
	if(getFirstStrikes()					== 0)				m_iFirstStrikes						= pClassInfo->getFirstStrikes();
	if(getChanceFirstStrikes()				== 0)				m_iChanceFirstStrikes				= pClassInfo->getChanceFirstStrikes();
	if(getInterceptionProbability()			== 0)				m_iInterceptionProbability			= pClassInfo->getInterceptionProbability();
	if(getEvasionProbability()				== 0)				m_iEvasionProbability				= pClassInfo->getEvasionProbability();
	if(getWithdrawalProbability()			== 0)				m_iWithdrawalProbability			= pClassInfo->getWithdrawalProbability();
	if(getCollateralDamage()				== 0)				m_iCollateralDamage					= pClassInfo->getCollateralDamage();
	if(getCollateralDamageLimit()			== 0)				m_iCollateralDamageLimit			= pClassInfo->getCollateralDamageLimit();
	if(getCollateralDamageMaxUnits()		== 0)				m_iCollateralDamageMaxUnits			= pClassInfo->getCollateralDamageMaxUnits();
	if(getCityAttackModifier()				== 0)				m_iCityAttackModifier				= pClassInfo->getCityAttackModifier();
	if(getCityDefenseModifier()				== 0)				m_iCityDefenseModifier				= pClassInfo->getCityDefenseModifier();
	if(getAnimalCombatModifier()			== 0)				m_iAnimalCombatModifier				= pClassInfo->getAnimalCombatModifier();
	if(getHillsAttackModifier()				== 0)				m_iHillsAttackModifier				= pClassInfo->getHillsAttackModifier();
	if(getHillsDefenseModifier()			== 0)				m_iHillsDefenseModifier				= pClassInfo->getHillsDefenseModifier();
	if(getBombRate()						== 0)				m_iBombRate							= pClassInfo->getBombRate();
	if(getBombardRate()						== 0)				m_iBombardRate						= pClassInfo->getBombardRate();
	if(getBombardRange()    				== 0)				m_iBombardRange 					= pClassInfo->getBombardRange();
	if(getCargoSpace()						== 0)				m_iCargoSpace						= pClassInfo->getCargoSpace();
	if(getConscriptionValue()				== 0)				m_iConscriptionValue				= pClassInfo->getConscriptionValue();
	if(getCultureGarrisonValue()			== 0)				m_iCultureGarrisonValue				= pClassInfo->getCultureGarrisonValue();
	if(getExtraCost()						== 0)				m_iExtraCost						= pClassInfo->getExtraCost();
	if(getLeaderExperience()				== 0)				m_iLeaderExperience					= pClassInfo->getLeaderExperience();
	if(getNukeRange()						== -1)				m_iNukeRange						= pClassInfo->getNukeRange();
	if(getProductionCost()					== -1)				m_iProductionCost					= pClassInfo->getProductionCost();
	if(getMinAreaSize()						== -1)				m_iMinAreaSize						= pClassInfo->getMinAreaSize();
	if(getAdvancedStartCost()				== 100)				m_iAdvancedStartCost				= pClassInfo->getAdvancedStartCost();
	if(getCombatLimit()						== 100)				m_iCombatLimit						= pClassInfo->getCombatLimit();
	if(getXPValueAttack()					== 8)				m_iXPValueAttack					= pClassInfo->getXPValueAttack();
	if(getXPValueDefense()					== 4)				m_iXPValueDefense					= pClassInfo->getXPValueDefense();
	if(m_szFormationType == "FORMATION_TYPE_DEFAULT")			m_szFormationType					= pClassInfo->getFormationType();
	if(getImage()							== cDefault)		m_szImage							= pClassInfo->getImage();
	if(getPyPostCombatLost()				== cDefault)		m_szPyPostCombatLost				= pClassInfo->getPyPostCombatLost();
	if(getPyPostCombatWon()					== cDefault)		m_szPyPostCombatWon					= pClassInfo->getPyPostCombatWon();
	if(getPrereqAndTech()					== NO_TECH)			m_iPrereqAndTech					= pClassInfo->getPrereqAndTech();
	if(getPrereqAndBonus()					== NO_BONUS)		m_iPrereqAndBonus					= pClassInfo->getPrereqAndBonus();
	if(getPrereqCivic()						== NO_CIVIC)		m_iPrereqCivic						= pClassInfo->getPrereqCivic();
	if(getDomainCargo()						== NO_DOMAIN)		m_iDomainCargo						= pClassInfo->getDomainCargo();
	if(getAdvisorType()						== NO_ADVISOR)		m_iAdvisorType						= pClassInfo->getAdvisorType();
	if(getDomainType()						== DOMAIN_LAND)		m_iDomainType						= pClassInfo->getDomainType();
	if(getHolyCity()						== NO_RELIGION)		m_iHolyCity							= pClassInfo->getHolyCity();
	if(getReligionType()					== NO_RELIGION)		m_iReligionType						= pClassInfo->getReligionType();
	if(getStateReligion()					== NO_RELIGION)		m_iStateReligion					= pClassInfo->getStateReligion();
	if(getPrereqReligion()					== NO_RELIGION)		m_iPrereqReligion					= pClassInfo->getPrereqReligion();
	if(getPrereqBuilding()					== NO_BUILDING)		m_iPrereqBuilding					= pClassInfo->getPrereqBuilding();
	if(getLeaderPromotion()					== NO_PROMOTION)	m_iLeaderPromotion					= pClassInfo->getLeaderPromotion();
	if(getEquipmentPromotion()				== NO_PROMOTION)	m_iEquipmentPromotion				= pClassInfo->getEquipmentPromotion();
	if(getPromotionFromCombat()				== NO_PROMOTION)	m_iPromotionFromCombat				= pClassInfo->getPromotionFromCombat();
	if(getUnitClassType()					== NO_UNITCLASS)	m_iUnitClassType					= pClassInfo->getUnitClassType();
	if(getUnitCaptureClassType()			== NO_UNITCLASS)	m_iUnitCaptureClassType				= pClassInfo->getUnitCaptureClassType();
	if(getPrereqAlignment()					== NO_ALIGNMENT)	m_iPrereqAlignment					= pClassInfo->getPrereqAlignment();
	if(getUnitCombatType()					== NO_UNITCOMBAT)	m_iUnitCombatType					= pClassInfo->getUnitCombatType();
	if(getDiploVoteType()					== NO_VOTESOURCE)	m_iDiploVoteType					= pClassInfo->getDiploVoteType();
	if(getPrereqCorporation()				== NO_CORPORATION)	m_iPrereqCorporation				= pClassInfo->getPrereqCorporation();
	if(getSpecialCargo()					== NO_SPECIALUNIT)	m_iSpecialCargo						= pClassInfo->getSpecialCargo();
	if(getSpecialUnitType()					== NO_SPECIALUNIT)	m_iSpecialUnitType					= pClassInfo->getSpecialUnitType();
	if(getDefaultUnitAIType()				== UNITAI_UNKNOWN)	m_iDefaultUnitAIType				= pClassInfo->getDefaultUnitAIType();
	if(getPrereqBuildingClass()				== NO_BUILDINGCLASS)m_iPrereqBuildingClass				= pClassInfo->getPrereqBuildingClass();

	if(getCombat()							== 0)				m_iCombat							= pClassInfo->getCombat();
	if(getTier()							== 0)				m_iTier								= pClassInfo->getTier();
	if(getCombatDefense()					== 0)				m_iCombatDefense					= pClassInfo->getCombatDefense();
	if(getAssetValue()						== 0)				m_iAssetValue						= pClassInfo->getAssetValue();
	if(getPowerValue()						== 0)				m_iPowerValue						= pClassInfo->getPowerValue();
	if(getInvisibleType()					== 0)				m_iInvisibleType					= pClassInfo->getInvisibleType();
    if(getWeaponTier()                      == 0)               m_iWeaponTier                       = pClassInfo->getWeaponTier();
	//Now check if we had previously been using non-default values.  If then we weren't, but now we are, revert to the previous value set
	//Maybe we should adjust the previous value up/down based on how the default changed?  Could easily wind up with negative Power/Asset values then though
	//Not a horrible thing, but it would trigger an assert and be a nuisance.

	for ( int i = 0; i < GC.getNumUnitClassInfos(); i++)
	{
		if(getUpgradeUnitClass(i)			== false)			m_pbUpgradeUnitClass[i]				= pClassInfo->getUpgradeUnitClass(i);
		if(getTargetUnitClass(i)			== false)			m_pbTargetUnitClass[i]				= pClassInfo->getTargetUnitClass(i);
		if(getDefenderUnitClass(i)			== false)			m_pbDefenderUnitClass[i]			= pClassInfo->getDefenderUnitClass(i);
		if(getFlankingStrikeUnitClass(i)	== false)			m_piFlankingStrikeUnitClass[i]		= pClassInfo->getFlankingStrikeUnitClass(i);
		if(getUnitClassAttackModifier(i)	== false)			m_piUnitClassAttackModifier[i]		= pClassInfo->getUnitClassAttackModifier(i);
		if(getUnitClassDefenseModifier(i)	== false)			m_piUnitClassDefenseModifier[i]		= pClassInfo->getUnitClassDefenseModifier(i);
	}
	for ( int i = 0; i < GC.getNumUnitCombatInfos(); i++)
	{
        if(getTargetUnitCombat(i)			== false)			m_pbTargetUnitCombat[i]				= pClassInfo->getTargetUnitCombat(i);
		if(getDefenderUnitCombat(i)			== false)			m_pbDefenderUnitCombat[i]			= pClassInfo->getDefenderUnitCombat(i);
		if(getUnitCombatModifier(i)			== false)			m_piUnitCombatModifier[i]			= pClassInfo->getUnitCombatModifier(i);
		if(getUnitCombatCollateralImmune(i)	== false)			m_piUnitCombatCollateralImmune[i]	= pClassInfo->getUnitCombatCollateralImmune(i);
	}
	for ( int i = 0; i < NUM_UNITAI_TYPES; i++)
	{
        if(getUnitAIType(i)					== false)			m_pbUnitAIType[i]					= pClassInfo->getUnitAIType(i);
		if(getNotUnitAIType(i)				== false)			m_pbNotUnitAIType[i]				= pClassInfo->getNotUnitAIType(i);
	}
	for ( int i = 0; i < GC.getNumBuildInfos(); i++)
	{
        if(getBuilds(i)						== false)			m_pbBuilds[i]						= pClassInfo->getBuilds(i);
	}
	for ( int i = 0; i < GC.getNumBuildingInfos(); i++)
	{
		if(getBuildings(i)					== false)			m_pbBuildings[i]					= pClassInfo->getBuildings(i);
		if(getForceBuildings(i)				== false)			m_pbForceBuildings[i]				= pClassInfo->getForceBuildings(i);
	}
	for ( int i = 0; i < GC.getNumReligionInfos(); i++)
	{
		if(getReligionSpreads(i)			== false)			m_piReligionSpreads[i]				= pClassInfo->getReligionSpreads(i);
	}
	for ( int i = 0; i < GC.getNumCorporationInfos(); i++)
	{
		if(getCorporationSpreads(i)			== false)			m_piCorporationSpreads[i]			= pClassInfo->getCorporationSpreads(i);
	}
	for ( int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if(getProductionTraits(i)			== false)			m_piProductionTraits[i]				= pClassInfo->getProductionTraits(i);
	}
	for ( int i = 0; i < GC.getNumFlavorTypes(); i++)
	{
		if(getFlavorValue(i)				== false)			m_piFlavorValue[i]					= pClassInfo->getFlavorValue(i);
	}
	for ( int i = 0; i < GC.getNumSpecialistInfos(); i++)
	{
		if(getGreatPeoples(i)				== false)			m_pbGreatPeoples[i]					= pClassInfo->getGreatPeoples(i);
	}
	for ( int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
        if(getTerrainImpassable(i)			== false)			m_pbTerrainImpassable[i]			= pClassInfo->getTerrainImpassable(i);
		if(getTerrainNative(i)				== false)			m_pbTerrainNative[i]				= pClassInfo->getTerrainNative(i);
		if(getTerrainAttackModifier(i)		== 0)				m_piTerrainAttackModifier[i]		= pClassInfo->getTerrainAttackModifier(i);
		if(getTerrainDefenseModifier(i)		== 0)				m_piTerrainDefenseModifier[i]		= pClassInfo->getTerrainDefenseModifier(i);
		if(getTerrainPassableTech(i)		== NO_TECH)			m_piTerrainPassableTech[i]			= pClassInfo->getTerrainPassableTech(i);
	}
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if(getFeatureImpassable(i)			== false)			m_pbFeatureImpassable[i]			= pClassInfo->getFeatureImpassable(i);
		if(getFeatureNative(i)				== false)			m_pbFeatureNative[i]				= pClassInfo->getFeatureNative(i);
        if(getFeatureAttackModifier(i)		== 0)				m_piFeatureAttackModifier[i]		= pClassInfo->getFeatureAttackModifier(i);
		if(getFeatureDefenseModifier(i)		== 0)				m_piFeatureDefenseModifier[i]		= pClassInfo->getFeatureDefenseModifier(i);
		if(getFeaturePassableTech(i)		== NO_TECH)			m_piFeaturePassableTech[i]			= pClassInfo->getFeaturePassableTech(i);
	}
	for ( int i = 0; i < NUM_DOMAIN_TYPES; i++)
	{
        if(getDomainModifier(i)				== 0)				m_piDomainModifier[i]				= pClassInfo->getDomainModifier(i);
	}
	for ( int i = 0; i < GC.getNumBonusInfos(); i++)
	{
        if(getBonusProductionModifier(i)	== 0)				m_piBonusProductionModifier[i]		= pClassInfo->getBonusProductionModifier(i);
		if(getBonusAffinity(i)				== 0)				m_piBonusAffinity[i]				= pClassInfo->getBonusAffinity(i);
	}
	for ( int i = 0; i < GC.getNUM_UNIT_AND_TECH_PREREQS(); i++)
	{
		if(getPrereqAndTechs(i)				== NO_TECH)			m_piPrereqAndTechs[i]				= pClassInfo->getPrereqAndTechs(i);
	}
	for ( int i = 0; i < GC.getNUM_UNIT_PREREQ_OR_BONUSES(); i++)
	{
		if(getPrereqOrBonuses(i)			== NO_BONUS)		m_piPrereqOrBonuses[i]				= pClassInfo->getPrereqOrBonuses(i);
	}

	for(int i=0;i<GC.getNumDamageTypeInfos();i++)
	{
		if(getDamageTypeCombat(i)			== 0)				m_piDamageTypeCombat[i]				= pClassInfo->getDamageTypeCombat(i);
	}

    for(int i=0;i<GC.getNumPromotionInfos();i++)
    {
        if(getFreePromotions(i)             == false)           m_pbFreePromotions[i]               = pClassInfo->getFreePromotions(i);
    }

	for(int i=0; i < pClassInfo->getNumSeeInvisibleTypes(); i++)
	{
		int iSeeInvisibleType =																	pClassInfo->getSeeInvisibleType(i);
		if(iSeeInvisibleType != -1)
		{
			bool bLoad = true;
			for(int j=0;j<getNumSeeInvisibleTypes();j++)
			{
				if(getSeeInvisibleType(j) == iSeeInvisibleType)
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
															m_aiSeeInvisibleTypes.push_back(	iSeeInvisibleType);
			}
		}
	}

	// For the Meshgroups I assume the XML holding the largest GroupSize is the most completed(most fancy) and we want to keep that one
	if(getGroupSize() < pClassInfo->getGroupSize() )
	{
																m_iGroupSize						= pClassInfo->getGroupSize();
																m_iGroupDefinitions					= pClassInfo->getGroupDefinitions();
																m_iUnitMeleeWaveSize				= pClassInfo->getMeleeWaveSize();
																m_iUnitRangedWaveSize				= pClassInfo->getRangedWaveSize();
																m_fUnitMaxSpeed						= pClassInfo->getUnitMaxSpeed();
																m_fUnitPadTime						= pClassInfo->getUnitPadTime();

		//Delete old Arrays for initializing a new one
		SAFE_DELETE(m_piUnitGroupRequired)
		SAFE_DELETE(m_paszEarlyArtDefineTags)
		SAFE_DELETE(m_paszLateArtDefineTags)
		SAFE_DELETE(m_paszMiddleArtDefineTags)
		m_piUnitGroupRequired = new int[ m_iGroupDefinitions ];
		m_paszEarlyArtDefineTags = new CvString[ m_iGroupDefinitions ];
		m_paszLateArtDefineTags = new CvString[ m_iGroupDefinitions ];
		m_paszMiddleArtDefineTags = new CvString[ m_iGroupDefinitions ];
		for ( int i = 0; i < m_iGroupDefinitions; i++ )
		{
																m_piUnitGroupRequired[i]			= pClassInfo->getUnitGroupRequired(i);
																setEarlyArtDefineTag(i,				pClassInfo->getEarlyArtDefineTag(i, NO_UNIT_ARTSTYLE));
																setLateArtDefineTag(i,				pClassInfo->getLateArtDefineTag(i, NO_UNIT_ARTSTYLE));
																setMiddleArtDefineTag(i,			pClassInfo->getMiddleArtDefineTag(i, NO_UNIT_ARTSTYLE));
		}
	}
	if ( pClassInfo->getNumUnitNames() != 0 )
	{
		std::vector<CvString> NewNames;
		CvString LoadName;
		for(int i = 0; i < pClassInfo->getNumUnitNames(); ++i)
		{
			bool bLoad = true;
			for(int j = 0; i < getNumUnitNames(); ++i)
			{
				if(pClassInfo->getUnitNames(i) == cDefault || pClassInfo->getUnitNames(i) == getUnitNames(j))
				{
					bLoad = false;
					break;
				}
			}
			if(bLoad)
			{
				NewNames.push_back(pClassInfo->getUnitNames(i));
			}
		}
		for(int i = 0; i < getNumUnitNames(); ++i)
		{
			NewNames.push_back(getUnitNames(i));
		}
		m_iNumUnitNames = NewNames.size();
		SAFE_DELETE(m_paszUnitNames);
		m_paszUnitNames = new CvString[getNumUnitNames()];
		for(int i = 0; i < getNumUnitNames(); ++i)
		{
			m_paszUnitNames[i] = NewNames[i];
		}
		NewNames.clear();
	}
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/

    if (isAIblockPermDefense()== false)         m_bAIblockPermDefense = pClassInfo->isAIblockPermDefense();
    if (isAIblockPatrol()   == false)           m_bAIblockPatrol = pClassInfo->isAIblockPatrol();
    if (isAIblockExplore()   == false)           m_bAIblockExplore = pClassInfo->isAIblockExplore();

	if(isBarbarianSpawn()	== false)			m_bBarbarianSpawn	= pClassInfo->isBarbarianSpawn();
	if(isWildmanaGuardian()	== false)			m_bWildmanaGuardian	= pClassInfo->isWildmanaGuardian();
	if(isArcaneAura()		== false)			m_bArcaneAura		= pClassInfo->isArcaneAura();
	if(getObsoleteTech()	== NO_TECH)			m_iObsoleteTech		= pClassInfo->getObsoleteTech();

	if(getFaithUpkeep()	== 0)		        	m_iFaithUpkeep		= pClassInfo->getFaithUpkeep();
	if(getManaUpkeep()	== 0)       			m_iManaUpkeep	    = pClassInfo->getManaUpkeep();
	if(getCombatAuraType()	== NO_COMBATAURA)   m_iCombatAuraType   = pClassInfo->getCombatAuraType();
	if(getPopulationCost()	== 0)		        m_iPopulationCost	= pClassInfo->getPopulationCost();
	if(getGlobalYieldTypeCost()	== NO_YIELD)	m_iGlobalYieldTypeCost	= pClassInfo->getGlobalYieldTypeCost();
	if(getGlobalYieldCost()	== 0)		        m_iGlobalYieldCost	= pClassInfo->getGlobalYieldCost();
	if(getExtraLives()	== 0)		        m_iExtraLives	= pClassInfo->getExtraLives();
	if(getBonusNearUF()	== 0)		        m_iBonusNearUF	= pClassInfo->getBonusNearUF();
	if(getMaxWilderness()	== MAX_INT)		    m_iMaxWilderness	= pClassInfo->getMaxWilderness();
	if(getMinWilderness()	== 0)		        m_iMinWilderness	= pClassInfo->getMinWilderness();
	if(isNoCitySupportNeeded()	== false)		m_bNoCitySupportNeeded	= pClassInfo->isNoCitySupportNeeded();
	if(isNoEquipment()	== false)		m_bNoEquipment	= pClassInfo->isNoEquipment();	
	if(isNoXP()	== false)		m_bNoXP	= pClassInfo->isNoXP();	
	if(isScaleWithTech()	== false)		m_bScaleWithTech	= pClassInfo->isScaleWithTech();	
	if(getReducedCostByYieldOverwrite()	== NO_YIELD)	m_iReducedCostByYieldOverwrite	= pClassInfo->getReducedCostByYieldOverwrite();

	for (int j = 0; j < GC.getNumBonusInfos(); j++)
	{
		if (getBonusAptitude(j)				== 0)					m_piBonusAptitude[j]				= pClassInfo->getBonusAptitude(j);
	}

	if(getArcaneRange()						== 1)				m_iArcaneRange						= pClassInfo->getArcaneRange();
    if(getAppearanceProb()                  == 0)               m_iAppearanceProb                   = pClassInfo->getAppearanceProb();

	for ( int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if(getAppearanceTechs(i)			== false)			m_piAppearanceTechs[i]				= pClassInfo->getAppearanceTechs(i);
	}

	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		if(getCityCommerceChanges(i)		== 0)				m_piCityCommerceChanges[i]			= pClassInfo->getCityCommerceChanges(i);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Buildings can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	if (getRequiredGameOption()		== NO_GAMEOPTION)					m_iRequiredGameOption	= pClassInfo->getRequiredGameOption();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//>>>>Refined Defensive Strikes: Added by Denev 2009/11/10
	if (isDefensiveStrikes()		== false)					m_bDefensiveStrikes	= pClassInfo->isDefensiveStrikes();
//<<<<Refined Defensive Strikes: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    if(getCorporationSupportNeeded()== NO_CORPORATION)                 m_iCorporationSupportNeeded = pClassInfo->getCorporationSupportNeeded();

	for ( int j = 0; j < GC.getNumCorporationInfos(); j++)
	{
		if (getCorporationSupport((CorporationTypes)j)			== 0)				m_paiCorporationSupport[j]			= pClassInfo->getCorporationSupport((CorporationTypes)j);
		if (getCorporationSupportMultiplier((CorporationTypes)j)== 0)				m_paiCorporationSupportMod[j]		= pClassInfo->getCorporationSupportMultiplier((CorporationTypes)j);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	updateArtDefineButton();

	// Readpass2 stuff
	if (getUnitConvertFromCombat() == -1)						m_iUnitConvertFromCombat			= pClassInfo->getUnitConvertFromCombat();
	if (getUnitCreateFromCombat() == -1)						m_iUnitCreateFromCombat				= pClassInfo->getUnitCreateFromCombat();

	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getUpgradeCivVectorSize(); i++ )
	{
		m_aszExtraXMLforPass3.push_back(pClassInfo->getUpgradeCivVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getPrereqCivVectorSize(); i++ )
	{
		m_aszExtraXML1forPass3.push_back(pClassInfo->getPrereqCivVectorElement(i));
	}
}
void CvUnitInfo::copyNonDefaultsReadPass2(CvUnitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getUnitConvertFromCombat()	!= -1)	m_iUnitConvertFromCombat			= pClassInfo->getUnitConvertFromCombat();
	if (bOver || pClassInfo->getUnitCreateFromCombat()	!= -1)	m_iUnitCreateFromCombat				= pClassInfo->getUnitCreateFromCombat();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/



//======================================================================================================
//					CvUnitFormationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitFormationInfo()
//
//  \brief		Default Constructor
//
//------------------------------------------------------------------------------------------------------
CvUnitFormationInfo::CvUnitFormationInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitFormationInfo()
//
//  \brief		Destructor
//
//------------------------------------------------------------------------------------------------------
CvUnitFormationInfo::~CvUnitFormationInfo()
{
}

const TCHAR* CvUnitFormationInfo::getFormationType() const
{
	return m_szFormationType;
}

const std::vector<EntityEventTypes> & CvUnitFormationInfo::getEventTypes() const
{
	return m_vctEventTypes;
}

int CvUnitFormationInfo::getNumUnitEntries() const
{
	return m_vctUnitEntries.size();
}

const CvUnitEntry &CvUnitFormationInfo::getUnitEntry(int index) const
{
	return m_vctUnitEntries[index];
}

void CvUnitFormationInfo::addUnitEntry(const CvUnitEntry &unitEntry)
{
	m_vctUnitEntries.push_back(unitEntry);
}

int CvUnitFormationInfo::getNumGreatUnitEntries() const
{
	return m_vctGreatUnitEntries.size();
}

const CvUnitEntry &CvUnitFormationInfo::getGreatUnitEntry(int index) const
{
	return m_vctGreatUnitEntries[index];
}

int CvUnitFormationInfo::getNumSiegeUnitEntries() const
{
	return m_vctSiegeUnitEntries.size();
}

const CvUnitEntry &CvUnitFormationInfo::getSiegeUnitEntry(int index) const
{
	return m_vctSiegeUnitEntries[index];
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitFormationInfo()
//
//  \brief		Reads from XML
//
//------------------------------------------------------------------------------------------------------
bool CvUnitFormationInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	int iIndex;
	bool bNextSibling;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szFormationType, "FormationType");

	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "EventMaskList" ))
	{
		if ( gDLL->getXMLIFace()->SetToChild( pXML->GetXML() ) )
		{
			pXML->GetXmlVal( szTextVal );
			do
			{
				iIndex = pXML->FindInInfoClass(szTextVal);
				if ( iIndex != -1 )
					m_vctEventTypes.push_back( (EntityEventTypes)iIndex );
				bNextSibling = pXML->GetNextXmlVal( szTextVal );
			}
			while( bNextSibling );
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// Read the entries
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "UnitEntry" ) )
	{
		do
		{
			CvUnitEntry unitEntry;
			pXML->GetChildXmlValByName(szTextVal, "UnitEntryType");
			if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Position" ) )
			{
				pXML->GetChildXmlValByName( &unitEntry.m_position.x, "x");
				pXML->GetChildXmlValByName( &unitEntry.m_position.y, "y");
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
			pXML->GetChildXmlValByName( &unitEntry.m_fRadius, "PositionRadius");
			pXML->GetChildXmlValByName( &unitEntry.m_fFacingDirection, "Direction");
			pXML->GetChildXmlValByName( &unitEntry.m_fFacingVariance, "DirVariation");

			if(szTextVal.CompareNoCase("Unit") == 0)
				m_vctUnitEntries.push_back(unitEntry);
			else if(szTextVal.CompareNoCase("General") == 0)
				m_vctGreatUnitEntries.push_back(unitEntry);
			else if(szTextVal.CompareNoCase("Siege") == 0)
				m_vctSiegeUnitEntries.push_back(unitEntry);
			else
			{
				FAssertMsg(false, "[Jason] Unknown unit formation entry type.");
			}
		}
		while ( gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "UnitEntry"));
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	FAssertMsg(m_vctGreatUnitEntries.size() > 0, "[Jason] Formation missing great general entry.");
	FAssertMsg(m_vctSiegeUnitEntries.size() > 0, "[Jason] Formation missing siege tower entry.");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitFormationInfo::copyNonDefaults(CvUnitFormationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getFormationType()	== cDefault)	m_szFormationType					= pClassInfo->getFormationType();
	for ( int i = 0; i < pClassInfo->getNumEventTypes(); i++ )
	{
											m_vctEventTypes.push_back(			pClassInfo->getEventType(i));
	}
	for ( int i = 0; i < pClassInfo->getNumUnitEntries(); i++ )
	{
											m_vctUnitEntries.push_back(			pClassInfo->getUnitEntry(i));
	}
	for ( int i = 0; i < pClassInfo->getNumGreatUnitEntries(); i++ )
	{
											m_vctGreatUnitEntries.push_back(	pClassInfo->getGreatUnitEntry(i));
	}
	for ( int i = 0; i < pClassInfo->getNumSiegeUnitEntries(); i++ )
	{
											m_vctSiegeUnitEntries.push_back(	pClassInfo->getSiegeUnitEntry(i));
	}
}
int CvUnitFormationInfo::getNumEventTypes() const							{return m_vctEventTypes.size();}
const EntityEventTypes &CvUnitFormationInfo::getEventType(int index) const	{return m_vctEventTypes[index];}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvSpecialUnitInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpecialUnitInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialUnitInfo::CvSpecialUnitInfo() :
m_bValid(false),
m_bCityLoad(false),
m_pbCarrierUnitAITypes(NULL),
m_piProductionTraits(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpecialUnitInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialUnitInfo::~CvSpecialUnitInfo()
{
	SAFE_DELETE_ARRAY(m_pbCarrierUnitAITypes);
	SAFE_DELETE_ARRAY(m_piProductionTraits);
}

bool CvSpecialUnitInfo::isValid() const
{
	return m_bValid;
}

bool CvSpecialUnitInfo::isCityLoad() const
{
	return m_bCityLoad;
}

// Arrays

bool CvSpecialUnitInfo::isCarrierUnitAIType(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCarrierUnitAITypes ? m_pbCarrierUnitAITypes[i] : -1;
}

int CvSpecialUnitInfo::getProductionTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
}

bool CvSpecialUnitInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bValid, "bValid");
	pXML->GetChildXmlValByName(&m_bCityLoad, "bCityLoad");

	pXML->SetVariableListTagPair(&m_pbCarrierUnitAITypes, "CarrierUnitAITypes", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);

	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpecialUnitInfo::copyNonDefaults(CvSpecialUnitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isValid()						== false)		m_bValid					= pClassInfo->isValid();
	if (isCityLoad()					== false)		m_bCityLoad					= pClassInfo->isCityLoad();
	for ( int i = 0; i < NUM_UNITAI_TYPES; i++ )
	{
		if (m_pbCarrierUnitAITypes[i]	== false)		m_pbCarrierUnitAITypes[i]	= pClassInfo->isCarrierUnitAIType(i);
	}
	for ( int i = 0; i < GC.getNumTraitInfos(); i++ )
	{
		if ( m_piProductionTraits[i]	== 0)			m_piProductionTraits[i]		= pClassInfo->getProductionTraits(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCivicOptionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCivicOptionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCivicOptionInfo::CvCivicOptionInfo() :
m_pabTraitNoUpkeep(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCivicOptionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCivicOptionInfo::~CvCivicOptionInfo()
{
	SAFE_DELETE_ARRAY(m_pabTraitNoUpkeep);
}

bool CvCivicOptionInfo::getTraitNoUpkeep(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabTraitNoUpkeep ? m_pabTraitNoUpkeep[i] : false;
}

bool CvCivicOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->SetVariableListTagPair(&m_pabTraitNoUpkeep, "TraitNoUpkeeps", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCivicOptionInfo::copyNonDefaults(CvCivicOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	for ( int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if ( m_pabTraitNoUpkeep[i]	== false)		m_pabTraitNoUpkeep[i]	= pClassInfo->getTraitNoUpkeep(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCivicInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCivicInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCivicInfo::CvCivicInfo() :
m_iCivicOptionType(NO_CIVICOPTION),
m_iAnarchyLength(0),
m_iUpkeep(0),
m_iAIWeight(0),
m_iGreatPeopleRateModifier(0),
m_iGreatGeneralRateModifier(0),
m_iDomesticGreatGeneralRateModifier(0),
m_iStateReligionGreatPeopleRateModifier(0),
m_iDistanceMaintenanceModifier(0),
m_iNumCitiesMaintenanceModifier(0),
m_iCorporationMaintenanceModifier(0),
m_iExtraHealth(0),
m_iFreeExperience(0),
m_iWorkerSpeedModifier(0),
m_iImprovementUpgradeRateModifier(0),
m_iMilitaryProductionModifier(0),
m_iBaseFreeUnits(0),
m_iBaseFreeMilitaryUnits(0),
m_iFreeUnitsPopulationPercent(0),
m_iFreeMilitaryUnitsPopulationPercent(0),
m_iGoldPerUnit(0),
m_iGoldPerMilitaryUnit(0),
m_iHappyPerMilitaryUnit(0),
m_iLargestCityHappiness(0),
m_iWarWearinessModifier(0),
m_iFreeSpecialist(0),
m_iTradeRoutes(0),
m_iTechPrereq(NO_TECH),
m_iCivicPercentAnger(0),
m_iMaxConscript(0),
m_iStateReligionHappiness(0),
m_iNonStateReligionHappiness(0),
m_iStateReligionUnitProductionModifier(0),
m_iStateReligionBuildingProductionModifier(0),
m_iStateReligionFreeExperience(0),
m_iExpInBorderModifier(0),
m_bMilitaryFoodProduction(false),
m_bNoUnhealthyPopulation(false),
m_bBuildingOnlyHealthy(false),
m_bNoForeignTrade(false),
m_bNoCorporations(false),
m_bNoForeignCorporations(false),
m_bStateReligion(false),
m_bNoNonStateReligionSpread(false),
m_piYieldModifier(NULL),
m_piCapitalYieldModifier(NULL),
m_piTradeYieldModifier(NULL),
m_piCommerceModifier(NULL),
m_piCapitalCommerceModifier(NULL),
m_piSpecialistExtraCommerce(NULL),
m_paiBuildingHappinessChanges(NULL),
m_paiBuildingHealthChanges(NULL),
m_paiFeatureHappinessChanges(NULL),
m_pabHurry(NULL),
m_pabSpecialBuildingNotRequired(NULL),
m_pabSpecialistValid(NULL),
m_ppiImprovementYieldChanges(NULL),

//FfH Civics: Added by Kael 08/11/2007
m_bHidden(false),
m_bNoDiplomacyWithEnemies(false),
m_bPrereqWar(false),
m_iAttitudeShareMod(0),
m_iCoastalTradeRoutes(0),
m_iEnslavementChance(0),
m_iFoodConsumptionPerPopulation(0),
m_iBlockAlignment(NO_ALIGNMENT),
m_iPrereqAlignment(NO_ALIGNMENT),
m_iPrereqCivilization(NO_CIVILIZATION),
m_iPrereqReligion(NO_RELIGION),
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (new tags) Sephi			                                 					**/
/*************************************************************************************************/
m_iGreatPersonRatePerCulture(0),
m_iHealthRatePerCulture(0),
m_iNationalism(0),
m_iReducedEquipmentCost(0),
m_bPermanent(false),
m_bBanditLords(false),
m_bPreservation(false),
m_bLumberFromAF(false),
m_paiCommerceChangesPerCultureLevel(NULL),
m_iImpInfrastructureHalfCost(NO_IMPROVEMENT),
m_paiCorporationSupport(NULL),
m_paiCorporationSupportMod(NULL)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCivicInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCivicInfo::~CvCivicInfo()
{
	int iI;

	SAFE_DELETE_ARRAY(m_piYieldModifier);
	SAFE_DELETE_ARRAY(m_piCapitalYieldModifier);
	SAFE_DELETE_ARRAY(m_piTradeYieldModifier);
	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	SAFE_DELETE_ARRAY(m_piCapitalCommerceModifier);
	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	SAFE_DELETE_ARRAY(m_paiBuildingHappinessChanges);
	SAFE_DELETE_ARRAY(m_paiBuildingHealthChanges);
	SAFE_DELETE_ARRAY(m_paiFeatureHappinessChanges);
	SAFE_DELETE_ARRAY(m_pabHurry);
	SAFE_DELETE_ARRAY(m_pabSpecialBuildingNotRequired);
	SAFE_DELETE_ARRAY(m_pabSpecialistValid);
	if (m_ppiImprovementYieldChanges != NULL)
	{
		for (iI=0;iI<GC.getNumImprovementInfos();iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges);
	}
/*************************************************************************************************/
/**	ADDON (new tags) Sephi			                                 					**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	SAFE_DELETE_ARRAY(m_paiCommerceChangesPerCultureLevel);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

}

int CvCivicInfo::getCivicOptionType() const
{
	return m_iCivicOptionType;
}

int CvCivicInfo::getAnarchyLength() const
{
	return m_iAnarchyLength;
}

int CvCivicInfo::getUpkeep() const
{
	return m_iUpkeep;
}

int CvCivicInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvCivicInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvCivicInfo::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

int CvCivicInfo::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

int CvCivicInfo::getStateReligionGreatPeopleRateModifier() const
{
	return m_iStateReligionGreatPeopleRateModifier;
}

int CvCivicInfo::getDistanceMaintenanceModifier() const
{
	return m_iDistanceMaintenanceModifier;
}

int CvCivicInfo::getNumCitiesMaintenanceModifier() const
{
	return m_iNumCitiesMaintenanceModifier;
}

int CvCivicInfo::getCorporationMaintenanceModifier() const
{
	return m_iCorporationMaintenanceModifier;
}

int CvCivicInfo::getExtraHealth() const
{
	return m_iExtraHealth;
}

int CvCivicInfo::getFreeExperience() const
{
	return m_iFreeExperience;
}

int CvCivicInfo::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}

int CvCivicInfo::getImprovementUpgradeRateModifier() const
{
	return m_iImprovementUpgradeRateModifier;
}

int CvCivicInfo::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}

int CvCivicInfo::getBaseFreeUnits() const
{
	return m_iBaseFreeUnits;
}

int CvCivicInfo::getBaseFreeMilitaryUnits() const
{
	return m_iBaseFreeMilitaryUnits;
}

int CvCivicInfo::getFreeUnitsPopulationPercent() const
{
	return m_iFreeUnitsPopulationPercent;
}

int CvCivicInfo::getFreeMilitaryUnitsPopulationPercent() const
{
	return m_iFreeMilitaryUnitsPopulationPercent;
}

int CvCivicInfo::getGoldPerUnit() const
{
	return m_iGoldPerUnit;
}

int CvCivicInfo::getGoldPerMilitaryUnit() const
{
	return m_iGoldPerMilitaryUnit;
}

int CvCivicInfo::getHappyPerMilitaryUnit() const
{
	return m_iHappyPerMilitaryUnit;
}

int CvCivicInfo::getLargestCityHappiness() const
{
	return m_iLargestCityHappiness;
}

int CvCivicInfo::getWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

int CvCivicInfo::getFreeSpecialist() const
{
	return m_iFreeSpecialist;
}

int CvCivicInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvCivicInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvCivicInfo::getCivicPercentAnger() const
{
	return m_iCivicPercentAnger;
}

int CvCivicInfo::getMaxConscript() const
{
	return m_iMaxConscript;
}

int CvCivicInfo::getStateReligionHappiness() const
{
	return m_iStateReligionHappiness;
}

int CvCivicInfo::getNonStateReligionHappiness() const
{
	return m_iNonStateReligionHappiness;
}

int CvCivicInfo::getStateReligionUnitProductionModifier() const
{
	return m_iStateReligionUnitProductionModifier;
}

int CvCivicInfo::getStateReligionBuildingProductionModifier() const
{
	return m_iStateReligionBuildingProductionModifier;
}

int CvCivicInfo::getStateReligionFreeExperience() const
{
	return m_iStateReligionFreeExperience;
}

int CvCivicInfo::getExpInBorderModifier() const
{
	return m_iExpInBorderModifier;
}

bool CvCivicInfo::isMilitaryFoodProduction() const
{
	return m_bMilitaryFoodProduction;
}

bool CvCivicInfo::isNoUnhealthyPopulation() const
{
	return m_bNoUnhealthyPopulation;
}

bool CvCivicInfo::isBuildingOnlyHealthy() const
{
	return m_bBuildingOnlyHealthy;
}

bool CvCivicInfo::isNoForeignTrade() const
{
	return m_bNoForeignTrade;
}

bool CvCivicInfo::isNoCorporations() const
{
	return m_bNoCorporations;
}

bool CvCivicInfo::isNoForeignCorporations() const
{
	return m_bNoForeignCorporations;
}

bool CvCivicInfo::isStateReligion() const
{
	return m_bStateReligion;
}

bool CvCivicInfo::isNoNonStateReligionSpread() const
{
	return m_bNoNonStateReligionSpread;
}

const wchar* CvCivicInfo::getWeLoveTheKing()
{
	return m_szWeLoveTheKingKey;
}

void CvCivicInfo::setWeLoveTheKingKey(const TCHAR* szVal)
{
	m_szWeLoveTheKingKey = szVal;
}

//FfH Civics: Added by Kael 08/11/2007
bool CvCivicInfo::isHidden() const
{
	return m_bHidden;
}

bool CvCivicInfo::isNoDiplomacyWithEnemies() const
{
	return m_bNoDiplomacyWithEnemies;
}

bool CvCivicInfo::isPrereqWar() const
{
	return m_bPrereqWar;
}

int CvCivicInfo::getAttitudeShareMod() const
{
	return m_iAttitudeShareMod;
}

int CvCivicInfo::getCoastalTradeRoutes() const
{
	return m_iCoastalTradeRoutes;
}

int CvCivicInfo::getEnslavementChance() const
{
	return m_iEnslavementChance;
}

int CvCivicInfo::getFoodConsumptionPerPopulation() const
{
	return m_iFoodConsumptionPerPopulation;
}

int CvCivicInfo::getBlockAlignment() const
{
	return m_iBlockAlignment;
}

int CvCivicInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

int CvCivicInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

int CvCivicInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}
//FfH: End Add

/*************************************************************************************************/
/**	ADDON (new tags) Sephi			                                 					**/
/*************************************************************************************************/
int CvCivicInfo::getCommerceChangesPerCultureLevel(int iCommerce) const
{
	return m_paiCommerceChangesPerCultureLevel[iCommerce];
}

const TCHAR* CvCivicInfo::getPyPerTurn() const
{
	return m_szPyPerTurn;
}

int CvCivicInfo::getGreatPersonRatePerCulture() const
{
	return m_iGreatPersonRatePerCulture;
}

int CvCivicInfo::getHealthRatePerCulture() const
{
	return m_iHealthRatePerCulture;
}

int CvCivicInfo::getNationalism() const
{
	return m_iNationalism;
}

int CvCivicInfo::getReducedEquipmentCost() const
{
	return m_iReducedEquipmentCost;
}

bool CvCivicInfo::isPermanent() const
{
	return m_bPermanent;
}

bool CvCivicInfo::isBanditLords() const
{
	return m_bBanditLords;
}

bool CvCivicInfo::isPreservation() const
{
	return m_bPreservation;
}

bool CvCivicInfo::isLumberFromAF() const
{
	return m_bLumberFromAF;
}

int CvCivicInfo::getImpInfrastructureHalfCost() const
{
	return m_iImpInfrastructureHalfCost;
}

int CvCivicInfo::getCorporationSupport(int iCorporation) const
{
	return m_paiCorporationSupport[iCorporation];
}

int CvCivicInfo::getCorporationSupportMultiplier(int iCorporation) const
{
	return m_paiCorporationSupportMod[iCorporation];
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Arrays

int CvCivicInfo::getYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldModifier ? m_piYieldModifier[i] : -1;
}

int* CvCivicInfo::getYieldModifierArray() const
{
	return m_piYieldModifier;
}

int CvCivicInfo::getCapitalYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCapitalYieldModifier ? m_piCapitalYieldModifier[i] : -1;
}

int* CvCivicInfo::getCapitalYieldModifierArray() const
{
	return m_piCapitalYieldModifier;
}

int CvCivicInfo::getTradeYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTradeYieldModifier ? m_piTradeYieldModifier[i] : -1;
}

int* CvCivicInfo::getTradeYieldModifierArray() const
{
	return m_piTradeYieldModifier;
}

int CvCivicInfo::getCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceModifier ? m_piCommerceModifier[i] : -1;
}

int* CvCivicInfo::getCommerceModifierArray() const
{
	return m_piCommerceModifier;
}

int CvCivicInfo::getCapitalCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCapitalCommerceModifier ? m_piCapitalCommerceModifier[i] : -1;
}

int* CvCivicInfo::getCapitalCommerceModifierArray() const
{
	return m_piCapitalCommerceModifier;
}

int CvCivicInfo::getSpecialistExtraCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSpecialistExtraCommerce ? m_piSpecialistExtraCommerce[i] : -1;
}

int* CvCivicInfo::getSpecialistExtraCommerceArray() const
{
	return m_piSpecialistExtraCommerce;
}

int CvCivicInfo::getBuildingHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiBuildingHappinessChanges ? m_paiBuildingHappinessChanges[i] : -1;
}

int CvCivicInfo::getBuildingHealthChanges(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiBuildingHealthChanges ? m_paiBuildingHealthChanges[i] : -1;
}

int CvCivicInfo::getFeatureHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureHappinessChanges ? m_paiFeatureHappinessChanges[i] : -1;
}

bool CvCivicInfo::isHurry(int i) const
{
	FAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabHurry ? m_pabHurry[i] : false;
}

bool CvCivicInfo::isSpecialBuildingNotRequired(int i) const
{
	FAssertMsg(i < GC.getNumSpecialBuildingInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabSpecialBuildingNotRequired ? m_pabSpecialBuildingNotRequired[i] : false;
}

bool CvCivicInfo::isSpecialistValid(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabSpecialistValid ? m_pabSpecialistValid[i] : false;
}

int CvCivicInfo::getImprovementYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiImprovementYieldChanges[i][j];
}

void CvCivicInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iCivicOptionType);
	stream->Read(&m_iAnarchyLength);
	stream->Read(&m_iUpkeep);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iGreatPeopleRateModifier);
	stream->Read(&m_iGreatGeneralRateModifier);
	stream->Read(&m_iDomesticGreatGeneralRateModifier);
	stream->Read(&m_iStateReligionGreatPeopleRateModifier);
	stream->Read(&m_iDistanceMaintenanceModifier);
	stream->Read(&m_iNumCitiesMaintenanceModifier);
	stream->Read(&m_iCorporationMaintenanceModifier);
	stream->Read(&m_iExtraHealth);
	stream->Read(&m_iFreeExperience);
	stream->Read(&m_iWorkerSpeedModifier);
	stream->Read(&m_iImprovementUpgradeRateModifier);
	stream->Read(&m_iMilitaryProductionModifier);
	stream->Read(&m_iBaseFreeUnits);
	stream->Read(&m_iBaseFreeMilitaryUnits);
	stream->Read(&m_iFreeUnitsPopulationPercent);
	stream->Read(&m_iFreeMilitaryUnitsPopulationPercent);
	stream->Read(&m_iGoldPerUnit);
	stream->Read(&m_iGoldPerMilitaryUnit);
	stream->Read(&m_iHappyPerMilitaryUnit);
	stream->Read(&m_iLargestCityHappiness);
	stream->Read(&m_iWarWearinessModifier);
	stream->Read(&m_iFreeSpecialist);
	stream->Read(&m_iTradeRoutes);
	stream->Read(&m_iTechPrereq);
	stream->Read(&m_iCivicPercentAnger);
	stream->Read(&m_iMaxConscript);
	stream->Read(&m_iStateReligionHappiness);
	stream->Read(&m_iNonStateReligionHappiness);
	stream->Read(&m_iStateReligionUnitProductionModifier);
	stream->Read(&m_iStateReligionBuildingProductionModifier);
	stream->Read(&m_iStateReligionFreeExperience);
	stream->Read(&m_iExpInBorderModifier);

	stream->Read(&m_bMilitaryFoodProduction);
	stream->Read(&m_bNoUnhealthyPopulation);
	stream->Read(&m_bBuildingOnlyHealthy);
	stream->Read(&m_bNoForeignTrade);
	stream->Read(&m_bNoCorporations);
	stream->Read(&m_bNoForeignCorporations);
	stream->Read(&m_bStateReligion);
	stream->Read(&m_bNoNonStateReligionSpread);

//FfH Civics: Added by Kael 08/11/2007
	stream->Read(&m_bHidden);
	stream->Read(&m_bNoDiplomacyWithEnemies);
	stream->Read(&m_bPrereqWar);
	stream->Read(&m_iAttitudeShareMod);
	stream->Read(&m_iCoastalTradeRoutes);
	stream->Read(&m_iEnslavementChance);
	stream->Read(&m_iFoodConsumptionPerPopulation);
	stream->Read(&m_iBlockAlignment);
	stream->Read(&m_iPrereqAlignment);
	stream->Read(&m_iPrereqCivilization);
	stream->Read(&m_iPrereqReligion);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupport);

	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	// Arrays

	SAFE_DELETE_ARRAY(m_piYieldModifier);
	m_piYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldModifier);

	SAFE_DELETE_ARRAY(m_piCapitalYieldModifier);
	m_piCapitalYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piCapitalYieldModifier);

	SAFE_DELETE_ARRAY(m_piTradeYieldModifier);
	m_piTradeYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piTradeYieldModifier);

	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	m_piCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceModifier);

	SAFE_DELETE_ARRAY(m_piCapitalCommerceModifier);
	m_piCapitalCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCapitalCommerceModifier);

	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	m_piSpecialistExtraCommerce = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);

	SAFE_DELETE_ARRAY(m_paiBuildingHappinessChanges);
	m_paiBuildingHappinessChanges = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_paiBuildingHappinessChanges);

	SAFE_DELETE_ARRAY(m_paiBuildingHealthChanges);
	m_paiBuildingHealthChanges = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_paiBuildingHealthChanges);

	SAFE_DELETE_ARRAY(m_paiFeatureHappinessChanges);
	m_paiFeatureHappinessChanges = new int[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_paiFeatureHappinessChanges);

	SAFE_DELETE_ARRAY(m_pabHurry);
	m_pabHurry = new bool[GC.getNumHurryInfos()];
	stream->Read(GC.getNumHurryInfos(), m_pabHurry);

	SAFE_DELETE_ARRAY(m_pabSpecialBuildingNotRequired);
	m_pabSpecialBuildingNotRequired = new bool[GC.getNumSpecialBuildingInfos()];
	stream->Read(GC.getNumSpecialBuildingInfos(), m_pabSpecialBuildingNotRequired);

	SAFE_DELETE_ARRAY(m_pabSpecialistValid);
	m_pabSpecialistValid = new bool[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_pabSpecialistValid);

	int i;
	if (m_ppiImprovementYieldChanges != NULL)
	{
		for(i=0;i<GC.getNumImprovementInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[i]);
		}
		SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges);
	}
	m_ppiImprovementYieldChanges = new int*[GC.getNumImprovementInfos()];
	for(i=0;i<GC.getNumImprovementInfos();i++)
	{
		m_ppiImprovementYieldChanges[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppiImprovementYieldChanges[i]);
	}

	stream->ReadString(m_szWeLoveTheKingKey);
}

void CvCivicInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iCivicOptionType);
	stream->Write(m_iAnarchyLength);
	stream->Write(m_iUpkeep);
	stream->Write(m_iAIWeight);
	stream->Write(m_iGreatPeopleRateModifier);
	stream->Write(m_iGreatGeneralRateModifier);
	stream->Write(m_iDomesticGreatGeneralRateModifier);
	stream->Write(m_iStateReligionGreatPeopleRateModifier);
	stream->Write(m_iDistanceMaintenanceModifier);
	stream->Write(m_iNumCitiesMaintenanceModifier);
	stream->Write(m_iCorporationMaintenanceModifier);
	stream->Write(m_iExtraHealth);
	stream->Write(m_iFreeExperience);
	stream->Write(m_iWorkerSpeedModifier);
	stream->Write(m_iImprovementUpgradeRateModifier);
	stream->Write(m_iMilitaryProductionModifier);
	stream->Write(m_iBaseFreeUnits);
	stream->Write(m_iBaseFreeMilitaryUnits);
	stream->Write(m_iFreeUnitsPopulationPercent);
	stream->Write(m_iFreeMilitaryUnitsPopulationPercent);
	stream->Write(m_iGoldPerUnit);
	stream->Write(m_iGoldPerMilitaryUnit);
	stream->Write(m_iHappyPerMilitaryUnit);
	stream->Write(m_iLargestCityHappiness);
	stream->Write(m_iWarWearinessModifier);
	stream->Write(m_iFreeSpecialist);
	stream->Write(m_iTradeRoutes);
	stream->Write(m_iTechPrereq);
	stream->Write(m_iCivicPercentAnger);
	stream->Write(m_iMaxConscript);
	stream->Write(m_iStateReligionHappiness);
	stream->Write(m_iNonStateReligionHappiness);
	stream->Write(m_iStateReligionUnitProductionModifier);
	stream->Write(m_iStateReligionBuildingProductionModifier);
	stream->Write(m_iStateReligionFreeExperience);
	stream->Write(m_iExpInBorderModifier);

	stream->Write(m_bMilitaryFoodProduction);
	stream->Write(m_bNoUnhealthyPopulation);
	stream->Write(m_bBuildingOnlyHealthy);
	stream->Write(m_bNoForeignTrade);
	stream->Write(m_bNoCorporations);
	stream->Write(m_bNoForeignCorporations);
	stream->Write(m_bStateReligion);
	stream->Write(m_bNoNonStateReligionSpread);

//FfH Civics: Added by Kael 08/11/2007
	stream->Write(m_bHidden);
	stream->Write(m_bNoDiplomacyWithEnemies);
	stream->Write(m_bPrereqWar);
	stream->Write(m_iAttitudeShareMod);
	stream->Write(m_iCoastalTradeRoutes);
	stream->Write(m_iEnslavementChance);
	stream->Write(m_iFoodConsumptionPerPopulation);
	stream->Write(m_iBlockAlignment);
	stream->Write(m_iPrereqAlignment);
	stream->Write(m_iPrereqCivilization);
	stream->Write(m_iPrereqReligion);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupport);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	// Arrays

	stream->Write(NUM_YIELD_TYPES, m_piYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piCapitalYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piTradeYieldModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piCapitalCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);
	stream->Write(GC.getNumBuildingClassInfos(), m_paiBuildingHappinessChanges);
	stream->Write(GC.getNumBuildingClassInfos(), m_paiBuildingHealthChanges);
	stream->Write(GC.getNumFeatureInfos(), m_paiFeatureHappinessChanges);
	stream->Write(GC.getNumHurryInfos(), m_pabHurry);
	stream->Write(GC.getNumSpecialBuildingInfos(), m_pabSpecialBuildingNotRequired);
	stream->Write(GC.getNumSpecialistInfos(), m_pabSpecialistValid);

	int i;
	for(i=0;i<GC.getNumImprovementInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppiImprovementYieldChanges[i]);
	}

	stream->WriteString(m_szWeLoveTheKingKey);
}

bool CvCivicInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j;
	int iNumSibs=0;				// the number of siblings the current xml node has
	int iIndex;

	pXML->GetChildXmlValByName(szTextVal, "CivicOptionType");
	m_iCivicOptionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iAnarchyLength, "iAnarchyLength");

	pXML->GetChildXmlValByName(szTextVal, "Upkeep");
	m_iUpkeep = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iGreatGeneralRateModifier, "iGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iDomesticGreatGeneralRateModifier, "iDomesticGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iStateReligionGreatPeopleRateModifier, "iStateReligionGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iDistanceMaintenanceModifier, "iDistanceMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iNumCitiesMaintenanceModifier, "iNumCitiesMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iCorporationMaintenanceModifier, "iCorporationMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iExtraHealth, "iExtraHealth");
	pXML->GetChildXmlValByName(&m_iFreeExperience, "iFreeExperience");
	pXML->GetChildXmlValByName(&m_iWorkerSpeedModifier, "iWorkerSpeedModifier");
	pXML->GetChildXmlValByName(&m_iImprovementUpgradeRateModifier, "iImprovementUpgradeRateModifier");
	pXML->GetChildXmlValByName(&m_iMilitaryProductionModifier, "iMilitaryProductionModifier");
	pXML->GetChildXmlValByName(&m_iBaseFreeUnits, "iBaseFreeUnits");
	pXML->GetChildXmlValByName(&m_iBaseFreeMilitaryUnits, "iBaseFreeMilitaryUnits");
	pXML->GetChildXmlValByName(&m_iFreeUnitsPopulationPercent, "iFreeUnitsPopulationPercent");
	pXML->GetChildXmlValByName(&m_iFreeMilitaryUnitsPopulationPercent, "iFreeMilitaryUnitsPopulationPercent");
	pXML->GetChildXmlValByName(&m_iGoldPerUnit, "iGoldPerUnit");
	pXML->GetChildXmlValByName(&m_iGoldPerMilitaryUnit, "iGoldPerMilitaryUnit");
	pXML->GetChildXmlValByName(&m_iHappyPerMilitaryUnit, "iHappyPerMilitaryUnit");
	pXML->GetChildXmlValByName(&m_bMilitaryFoodProduction, "bMilitaryFoodProduction");
	pXML->GetChildXmlValByName(&m_iMaxConscript, "iMaxConscript");
	pXML->GetChildXmlValByName(&m_bNoUnhealthyPopulation, "bNoUnhealthyPopulation");
	pXML->GetChildXmlValByName(&m_bBuildingOnlyHealthy, "bBuildingOnlyHealthy");
	pXML->GetChildXmlValByName(&m_iLargestCityHappiness, "iLargestCityHappiness");
//	pXML->GetChildXmlValByName(&m_iWarWearinessModifier, "iWarWearinessModifier"); no WarWeariness
	pXML->GetChildXmlValByName(&m_iFreeSpecialist, "iFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_bNoForeignTrade, "bNoForeignTrade");
	pXML->GetChildXmlValByName(&m_bNoCorporations, "bNoCorporations");
	pXML->GetChildXmlValByName(&m_bNoForeignCorporations, "bNoForeignCorporations");
	pXML->GetChildXmlValByName(&m_iCivicPercentAnger, "iCivicPercentAnger");
	pXML->GetChildXmlValByName(&m_bStateReligion, "bStateReligion");
	pXML->GetChildXmlValByName(&m_bNoNonStateReligionSpread, "bNoNonStateReligionSpread");
	pXML->GetChildXmlValByName(&m_iStateReligionHappiness, "iStateReligionHappiness");
	pXML->GetChildXmlValByName(&m_iNonStateReligionHappiness, "iNonStateReligionHappiness");
	pXML->GetChildXmlValByName(&m_iStateReligionUnitProductionModifier, "iStateReligionUnitProductionModifier");
	pXML->GetChildXmlValByName(&m_iStateReligionBuildingProductionModifier, "iStateReligionBuildingProductionModifier");
	pXML->GetChildXmlValByName(&m_iStateReligionFreeExperience, "iStateReligionFreeExperience");
	pXML->GetChildXmlValByName(&m_iExpInBorderModifier, "iExpInBorderModifier");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
	{
		pXML->SetYields(&m_piYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CapitalYieldModifiers"))
	{
		pXML->SetYields(&m_piCapitalYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCapitalYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TradeYieldModifiers"))
	{
		pXML->SetYields(&m_piTradeYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piTradeYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CapitalCommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCapitalCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCapitalCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistExtraCommerces"))
	{
		pXML->SetCommerce(&m_piSpecialistExtraCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piSpecialistExtraCommerce, NUM_COMMERCE_TYPES);
	}

	pXML->SetVariableListTagPair(&m_pabHurry, "Hurrys", sizeof(GC.getHurryInfo((HurryTypes)0)), GC.getNumHurryInfos());
	pXML->SetVariableListTagPair(&m_pabSpecialBuildingNotRequired, "SpecialBuildingNotRequireds", sizeof(GC.getSpecialBuildingInfo((SpecialBuildingTypes)0)), GC.getNumSpecialBuildingInfos());
	pXML->SetVariableListTagPair(&m_pabSpecialistValid, "SpecialistValids", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	pXML->SetVariableListTagPair(&m_paiBuildingHappinessChanges, "BuildingHappinessChanges", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_paiBuildingHealthChanges, "BuildingHealthChanges", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_paiFeatureHappinessChanges, "FeatureHappinessChanges", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());

	// initialize the boolean list to the correct size and all the booleans to false
	FAssertMsg((GC.getNumImprovementInfos() > 0) && (NUM_YIELD_TYPES) > 0,"either the number of improvement infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiImprovementYieldChanges, GC.getNumImprovementInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiImprovementYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiImprovementYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "WeLoveTheKing");
	setWeLoveTheKingKey(szTextVal);

//FfH Civics: Added by Kael 08/11/2007
	pXML->GetChildXmlValByName(&m_bHidden, "bHidden");
	pXML->GetChildXmlValByName(&m_bNoDiplomacyWithEnemies, "bNoDiplomacyWithEnemies");
	pXML->GetChildXmlValByName(&m_bPrereqWar, "bPrereqWar");
	pXML->GetChildXmlValByName(&m_iAttitudeShareMod, "iAttitudeShareMod");
	pXML->GetChildXmlValByName(&m_iCoastalTradeRoutes, "iCoastalTradeRoutes");
	pXML->GetChildXmlValByName(&m_iEnslavementChance, "iEnslavementChance");
	pXML->GetChildXmlValByName(&m_iFoodConsumptionPerPopulation, "iFoodConsumptionPerPopulation");
	pXML->GetChildXmlValByName(szTextVal, "BlockAlignment");
	m_iBlockAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
//	pXML->GetChildXmlValByName(szTextVal, "ImpInfrastructureHalfCost");	//TEMPFIX DISABLE; MIGHT REMOVE LATER
//	m_iImpInfrastructureHalfCost = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iNationalism, "iNationalism");
	pXML->GetChildXmlValByName(&m_iReducedEquipmentCost, "iReducedEquipmentCost");
	pXML->GetChildXmlValByName(&m_bPermanent, "bPermanent");
	pXML->GetChildXmlValByName(&m_bBanditLords, "bBanditLords");
	pXML->GetChildXmlValByName(&m_bPreservation, "bPreservation");
	pXML->GetChildXmlValByName(&m_bLumberFromAF, "bLumberFromAF");
	pXML->GetChildXmlValByName(&m_iGreatPersonRatePerCulture, "iGreatPersonRatePerCulture");
	pXML->GetChildXmlValByName(&m_iHealthRatePerCulture, "iHealthRatePerCulture");
	pXML->SetVariableListTagPair(&m_paiCommerceChangesPerCultureLevel, "CommerceChangesPerCultureLevel", sizeof(GC.getCommerceInfo((CommerceTypes)0)), GC.getNUM_COMMERCE_TYPES());
	pXML->GetChildXmlValByName(m_szPyPerTurn, "PyPerTurn");

	pXML->SetVariableListTagPair(&m_paiCorporationSupport, "CorporationSupportValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
	pXML->SetVariableListTagPair(&m_paiCorporationSupportMod, "CorporationSupportModifierValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	return true;
}

//FfH Civics: Added by Kael 08/11/2007
bool CvCivicInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(CivicInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCivicInfo::copyNonDefaults(CvCivicInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isNoForeignTrade()								== false)			m_bNoForeignTrade							= pClassInfo->isNoForeignTrade();
	if (isNoCorporations()								== false)			m_bNoCorporations							= pClassInfo->isNoCorporations();
	if (isNoForeignCorporations()						== false)			m_bNoForeignCorporations					= pClassInfo->isNoForeignCorporations();
	if (isMilitaryFoodProduction()						== false)			m_bMilitaryFoodProduction					= pClassInfo->isMilitaryFoodProduction();
	if (isNoUnhealthyPopulation()						== false)			m_bNoUnhealthyPopulation					= pClassInfo->isNoUnhealthyPopulation();
	if (isBuildingOnlyHealthy()							== false)			m_bBuildingOnlyHealthy						= pClassInfo->isBuildingOnlyHealthy();
	if (isStateReligion()								== false)			m_bStateReligion							= pClassInfo->isStateReligion();
	if (isNoNonStateReligionSpread()					== false)			m_bNoNonStateReligionSpread					= pClassInfo->isNoNonStateReligionSpread();
	if (getAnarchyLength()								== 0)				m_iAnarchyLength							= pClassInfo->getAnarchyLength();
	if (getAIWeight()									== 0)				m_iAIWeight									= pClassInfo->getAIWeight();
	if (getGreatPeopleRateModifier()					== 0)				m_iGreatPeopleRateModifier					= pClassInfo->getGreatPeopleRateModifier();
	if (getGreatGeneralRateModifier()					== 0)				m_iGreatGeneralRateModifier					= pClassInfo->getGreatGeneralRateModifier();
	if (getDomesticGreatGeneralRateModifier()			== 0)				m_iDomesticGreatGeneralRateModifier			= pClassInfo->getDomesticGreatGeneralRateModifier();
	if (getStateReligionGreatPeopleRateModifier()		== 0)				m_iStateReligionGreatPeopleRateModifier		= pClassInfo->getStateReligionGreatPeopleRateModifier();
	if (getDistanceMaintenanceModifier()				== 0)				m_iDistanceMaintenanceModifier				= pClassInfo->getDistanceMaintenanceModifier();
	if (getNumCitiesMaintenanceModifier()				== 0)				m_iNumCitiesMaintenanceModifier				= pClassInfo->getNumCitiesMaintenanceModifier();
	if (getCorporationMaintenanceModifier()				== 0)				m_iCorporationMaintenanceModifier			= pClassInfo->getCorporationMaintenanceModifier();
	if (getExtraHealth()								== 0)				m_iExtraHealth								= pClassInfo->getExtraHealth();
	if (getFreeExperience()								== 0)				m_iFreeExperience							= pClassInfo->getFreeExperience();
	if (getWorkerSpeedModifier()						== 0)				m_iWorkerSpeedModifier						= pClassInfo->getWorkerSpeedModifier();
	if (getImprovementUpgradeRateModifier()				== 0)				m_iImprovementUpgradeRateModifier			= pClassInfo->getImprovementUpgradeRateModifier();
	if (getMilitaryProductionModifier()					== 0)				m_iMilitaryProductionModifier				= pClassInfo->getMilitaryProductionModifier();
	if (getBaseFreeUnits()								== 0)				m_iBaseFreeUnits							= pClassInfo->getBaseFreeUnits();
	if (getBaseFreeMilitaryUnits()						== 0)				m_iBaseFreeMilitaryUnits					= pClassInfo->getBaseFreeMilitaryUnits();
	if (getFreeUnitsPopulationPercent()					== 0)				m_iFreeUnitsPopulationPercent				= pClassInfo->getFreeUnitsPopulationPercent();
	if (getFreeMilitaryUnitsPopulationPercent()			== 0)				m_iFreeMilitaryUnitsPopulationPercent		= pClassInfo->getFreeMilitaryUnitsPopulationPercent();
	if (getGoldPerUnit()								== 0)				m_iGoldPerUnit								= pClassInfo->getGoldPerUnit();
	if (getGoldPerMilitaryUnit()						== 0)				m_iGoldPerMilitaryUnit						= pClassInfo->getGoldPerMilitaryUnit();
	if (getHappyPerMilitaryUnit()						== 0)				m_iHappyPerMilitaryUnit						= pClassInfo->getHappyPerMilitaryUnit();
	if (getMaxConscript()								== 0)				m_iMaxConscript								= pClassInfo->getMaxConscript();
	if (getLargestCityHappiness()						== 0)				m_iLargestCityHappiness						= pClassInfo->getLargestCityHappiness();
	if (getWarWearinessModifier()						== 0)				m_iWarWearinessModifier						= pClassInfo->getWarWearinessModifier();
	if (getFreeSpecialist()								== 0)				m_iFreeSpecialist							= pClassInfo->getFreeSpecialist();
	if (getCivicPercentAnger()							== 0)				m_iCivicPercentAnger						= pClassInfo->getCivicPercentAnger();
	if (getTradeRoutes()								== 0)				m_iTradeRoutes								= pClassInfo->getTradeRoutes();
	if (getStateReligionHappiness()						== 0)				m_iStateReligionHappiness					= pClassInfo->getStateReligionHappiness();
	if (getNonStateReligionHappiness()					== 0)				m_iNonStateReligionHappiness				= pClassInfo->getNonStateReligionHappiness();
	if (getStateReligionUnitProductionModifier()		== 0)				m_iStateReligionUnitProductionModifier		= pClassInfo->getStateReligionUnitProductionModifier();
	if (getStateReligionBuildingProductionModifier()	== 0)				m_iStateReligionBuildingProductionModifier	= pClassInfo->getStateReligionBuildingProductionModifier();
	if (getStateReligionFreeExperience()				== 0)				m_iStateReligionFreeExperience				= pClassInfo->getStateReligionFreeExperience();
	if (getExpInBorderModifier()						== 0)				m_iExpInBorderModifier						= pClassInfo->getExpInBorderModifier();
	if (getTechPrereq()									== NO_TECH)			m_iTechPrereq								= pClassInfo->getTechPrereq();
	if (getUpkeep()										== NO_UPKEEP)		m_iUpkeep									= pClassInfo->getUpkeep();
	if (getCivicOptionType()							== NO_CIVICOPTION)	m_iCivicOptionType							= pClassInfo->getCivicOptionType();
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_piYieldModifier[i]						== 0)				m_piYieldModifier[i]						= pClassInfo->getYieldModifier(i);
		if (m_piCapitalYieldModifier[i]					== 0)				m_piCapitalYieldModifier[i]					= pClassInfo->getCapitalYieldModifier(i);
		if (m_piTradeYieldModifier[i]					== 0)				m_piTradeYieldModifier[i]					= pClassInfo->getTradeYieldModifier(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if (m_piCommerceModifier[i]						== 0)				m_piCommerceModifier[i]						= pClassInfo->getCommerceModifier(i);
		if (m_piCapitalCommerceModifier[i]				== 0)				m_piCapitalCommerceModifier[i]				= pClassInfo->getCapitalCommerceModifier(i);
		if (m_piSpecialistExtraCommerce[i]				== 0)				m_piSpecialistExtraCommerce[i]				= pClassInfo->getSpecialistExtraCommerce(i);
	}
	for ( int i = 0; i < GC.getNumHurryInfos(); i++ )
	{
		if (m_pabHurry[i]								== false)			m_pabHurry[i]								= pClassInfo->isHurry(i);
	}
	for ( int i = 0; i < GC.getNumSpecialBuildingInfos(); i++ )
	{
		if (m_pabSpecialBuildingNotRequired[i]			== false)			m_pabSpecialBuildingNotRequired[i]			= pClassInfo->isSpecialBuildingNotRequired(i);
	}
	for ( int i = 0; i < GC.getNumSpecialistInfos(); i++ )
	{
		if (m_pabSpecialistValid[i]						== false)			m_pabSpecialistValid[i]						= pClassInfo->isSpecialistValid(i);
	}

	for ( int i = 0; i < GC.getNumBuildingClassInfos(); i++ )
	{
		if (m_paiBuildingHappinessChanges[i]			== 0)				m_paiBuildingHappinessChanges[i]			= pClassInfo->getBuildingHappinessChanges(i);
		if (m_paiBuildingHealthChanges[i]				== 0)				m_paiBuildingHealthChanges[i]				= pClassInfo->getBuildingHealthChanges(i);
	}
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++ )
	{
		if (m_paiFeatureHappinessChanges[i]				== 0)				m_paiFeatureHappinessChanges[i]				= pClassInfo->getFeatureHappinessChanges(i);
	}
	for ( int i = 0; i < GC.getNumImprovementInfos(); i++ )
	{
		for ( int j = 0; j < NUM_YIELD_TYPES; j++ )
		{
			if (m_ppiImprovementYieldChanges[i][j]		== 0)				m_ppiImprovementYieldChanges[i][j]			= pClassInfo->getImprovementYieldChanges(i,j);
		}
	}
	if (isHidden()										== false)			m_bHidden									= pClassInfo->isHidden();
	if (isNoDiplomacyWithEnemies()						== false)			m_bNoDiplomacyWithEnemies					= pClassInfo->isNoDiplomacyWithEnemies();
	if (isPrereqWar()									== false)			m_bPrereqWar								= pClassInfo->isPrereqWar();
	if (getAttitudeShareMod()							== 0)				m_iAttitudeShareMod							= pClassInfo->getAttitudeShareMod();
	if (getCoastalTradeRoutes()							== 0)				m_iCoastalTradeRoutes						= pClassInfo->getCoastalTradeRoutes();
	if (getEnslavementChance()							== 0)				m_iEnslavementChance						= pClassInfo->getEnslavementChance();
	if (getFoodConsumptionPerPopulation()				== 0)				m_iFoodConsumptionPerPopulation				= pClassInfo->getFoodConsumptionPerPopulation();
	if (getBlockAlignment()								== NO_ALIGNMENT)	m_iBlockAlignment							= pClassInfo->getBlockAlignment();
	if (getPrereqAlignment()							== NO_ALIGNMENT)	m_iPrereqAlignment							= pClassInfo->getPrereqAlignment();
	if (getPrereqReligion()								== NO_RELIGION)		m_iPrereqReligion							= pClassInfo->getPrereqReligion();
/*************************************************************************************************/
/**	ADDON (new tags) Sephi			                                 					**/
/*************************************************************************************************/
	if (getGreatPersonRatePerCulture()		== 0)	m_iGreatPersonRatePerCulture	= pClassInfo->getGreatPersonRatePerCulture();
	if (getHealthRatePerCulture()			== 0)	m_iHealthRatePerCulture			= pClassInfo->getHealthRatePerCulture();
	if (getNationalism()					== 0)	m_iNationalism					= pClassInfo->getNationalism();
	if (getReducedEquipmentCost()			== 0)	m_iReducedEquipmentCost			= pClassInfo->getReducedEquipmentCost();
	if (isPermanent()						== false)	m_bPermanent				= pClassInfo->isPermanent();
	if (isBanditLords()						== false)	m_bBanditLords				= pClassInfo->isBanditLords();
	if (isPreservation()					== false)	m_bPreservation				= pClassInfo->isPreservation();
	if (isLumberFromAF()					== false)	m_bLumberFromAF				= pClassInfo->isLumberFromAF();
	if (getPyPerTurn()						== cDefault)			m_szPyPerTurn						= pClassInfo->getPyPerTurn();
	if (getImpInfrastructureHalfCost()		== NO_IMPROVEMENT)	m_iImpInfrastructureHalfCost				= pClassInfo->getImpInfrastructureHalfCost();

	for ( int j = 0; j < GC.getNUM_COMMERCE_TYPES(); j++)
	{
		if (getCommerceChangesPerCultureLevel(j)			== 0)				m_paiCommerceChangesPerCultureLevel[j]			= pClassInfo->getCommerceChangesPerCultureLevel(j);
	}

	for ( int j = 0; j < GC.getNumCorporationInfos(); j++)
	{
		if (getCorporationSupport((CorporationTypes)j)			== 0)				m_paiCorporationSupport[j]			= pClassInfo->getCorporationSupport((CorporationTypes)j);
		if (getCorporationSupportMultiplier((CorporationTypes)j)== 0)				m_paiCorporationSupportMod[j]		= pClassInfo->getCorporationSupportMultiplier((CorporationTypes)j);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	// Readpass3 stuff
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvDiplomacyInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvDiplomacyInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyInfo::CvDiplomacyInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvDiplomacyInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvDiplomacyInfo::~CvDiplomacyInfo()
{
	uninit();
}

// note - Response member vars allocated by CvXmlLoadUtility
void CvDiplomacyInfo::uninit()
{
	for (std::vector<CvDiplomacyResponse*>::iterator it = m_pResponses.begin(); it != m_pResponses.end(); ++it)
	{
		SAFE_DELETE(*it);
	}
	m_pResponses.clear();
}

const CvDiplomacyResponse& CvDiplomacyInfo::getResponse(int iNum) const
{
	return *(m_pResponses[iNum]);
}

int CvDiplomacyInfo::getNumResponses() const
{
	return m_pResponses.size();
}

bool CvDiplomacyInfo::getCivilizationTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getCivilizationTypes(j);
}

bool CvDiplomacyInfo::getLeaderHeadTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getLeaderHeadTypes(j);
}

bool CvDiplomacyInfo::getAttitudeTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getAttitudeTypes(j);
}

bool CvDiplomacyInfo::getDiplomacyPowerTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getDiplomacyPowerTypes(j);
}

int CvDiplomacyInfo::getNumDiplomacyText(int i) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pResponses[i]->getNumDiplomacyText();
}

const TCHAR* CvDiplomacyInfo::getDiplomacyText(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < getNumDiplomacyText(i), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i]->getDiplomacyText(j);
}

void CvDiplomacyInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	int iNumResponses;
	stream->Read(&iNumResponses);

	// Arrays

	uninit();
	for (int uiIndex = 0; uiIndex < iNumResponses; ++uiIndex)
	{
		CvDiplomacyResponse* pResponse = new CvDiplomacyResponse;
		pResponse->read(stream);
		m_pResponses.push_back(pResponse);
	}
}

void CvDiplomacyInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	int iNumResponses = m_pResponses.size();
	stream->Write(iNumResponses);

	// Arrays

	for (int uiIndex = 0; uiIndex < iNumResponses; ++uiIndex)
	{
		m_pResponses[uiIndex]->write(stream);
	}
}

bool CvDiplomacyInfo::read(CvXMLLoadUtility* pXML)
{
	int i;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	uninit();
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Responses") )
	{
		int iNewResponses = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "Response");

		gDLL->getXMLIFace()->SetToChild(pXML->GetXML());

		for (i = 0; i < iNewResponses; i++)
		{
			CvDiplomacyResponse* pNewResponse = new CvDiplomacyResponse;
			pNewResponse->read(pXML);
			m_pResponses.push_back(pNewResponse);

			if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
			{
				break;
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	Haven't looked this over yet, but none of it should have been altered, so I hope it works	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvDiplomacyInfo::copyNonDefaults(CvXMLLoadUtility* pXML)
{
	// We have 6 possibilities in civ what this might be
	// 1) Text
	// 2) Leadertype + Text
	// 3) Attitude + Text
	// 4) Power + Text
	// 5) Leadertype + Attitude + Text
	// 6) Leadertype + Power + Text
	// Civilizations aren't used thus far...No idea why firaxis added this to the XML
	int iCase = 0; //no Case

	// Read the New Responses
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Responses") )
	{
		int iNewResponses = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "Response");

		gDLL->getXMLIFace()->SetToChild(pXML->GetXML());

		for (int i = 0; i < iNewResponses; i++)
		{
			CvDiplomacyResponse* pNewResponse = new CvDiplomacyResponse;
			pNewResponse->read(pXML);
			int iResponses = m_pResponses.size();

			// Check if the new
			bool bLeaderHeadTypes = false;
			for ( int j = 0; j < GC.getNumLeaderHeadInfos(); j++ )
			{
				if (pNewResponse->getLeaderHeadTypes(j))
				{
					bLeaderHeadTypes = true;
					break;
				}
			}
			bool bAttitudeTypes = false;
			for ( int j = 0; j < NUM_ATTITUDE_TYPES; j++ )
			{
				if (pNewResponse->getAttitudeTypes(j))
				{
					bAttitudeTypes = true;
					break;
				}
			}
			bool bPowerTypes = false;
			for ( int j = 0; j < NUM_DIPLOMACYPOWER_TYPES; j++ )
			{
				if (pNewResponse->getDiplomacyPowerTypes(j))
				{
					bPowerTypes = true;
					break;
				}
			}

			// Check which case we have
			if ( !(bLeaderHeadTypes || bAttitudeTypes || bPowerTypes) ) iCase = 1;
			else if ( bLeaderHeadTypes && !( bAttitudeTypes || bPowerTypes) ) iCase = 2;
			else if ( bAttitudeTypes && !( bLeaderHeadTypes || bPowerTypes) ) iCase = 3;
			else if ( bPowerTypes && !( bLeaderHeadTypes || bAttitudeTypes) ) iCase = 4;
			else if ( bLeaderHeadTypes && bAttitudeTypes && !bPowerTypes ) iCase = 5;
			else if ( bLeaderHeadTypes && bPowerTypes && !bAttitudeTypes ) iCase = 6;
			else FAssertMsg(false, "A new case with an added Diplomacy XML but already exists?" );

			// Find ResponseIndex(if already exists)
			bool bIsIndex =  false;
			int iIndex = 0;
			bIsIndex = FindResponseIndex(pNewResponse, iCase, &iIndex);

			if (bIsIndex)
			{
				// Check the Previous Values of this class and copy them to the Diplomacies Response
				pNewResponse->UpdateDiplomacies(this, iIndex);

				//Delete old vector info(only for this response)
				//DeleteResponseOnly(m_pResponses, getResponse(iIndex));
				m_pResponses.erase(m_pResponses.begin() + iIndex);
			}

			//apply new vector info
			m_pResponses.push_back(pNewResponse);

			if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
			{
				break;
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
}
bool CvDiplomacyInfo::FindResponseIndex(CvDiplomacyResponse* pNewResponse, int iCase, int* iIndex)
{
	// We have 6 possibilities in civ what this might be
	// 1) Text
	// 2) Leadertype + Text
	// 3) Attitude + Text
	// 4) Power + Text
	// 5) Leadertype + Attitude + Text
	// 6) Leadertype + Power + Text

	if ( getNumResponses() == 1 )
	{
		iIndex = 0;
		return true;
	}

	// Text
	if ( iCase == 1 )
	{
		bool bOnlyText = true;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) ) bOnlyText = false;
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bOnlyText = false;
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bOnlyText = false;
			}
			if ( bOnlyText )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Leaderheads + Text
	if ( iCase == 2 )
	{
		bool bOnlyLeaderheads = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) && pNewResponse->getLeaderHeadTypes(iElement) ) bOnlyLeaderheads = true;
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bOnlyLeaderheads = false;
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bOnlyLeaderheads = false;
			}
			if ( bOnlyLeaderheads )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Attitude + Text
	if ( iCase == 3 )
	{
		bool bOnlyAttitudeTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) && pNewResponse->getAttitudeTypes(iElement)) bOnlyAttitudeTypes = true;
			}
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) ) bOnlyAttitudeTypes = false;
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bOnlyAttitudeTypes = false;
			}
			if ( bOnlyAttitudeTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Power + Text
	if ( iCase == 4 )
	{
		bool bOnlyDiplomacyPowerTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) && pNewResponse->getDiplomacyPowerTypes(iElement) ) bOnlyDiplomacyPowerTypes = true;
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bOnlyDiplomacyPowerTypes = false;
			}
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) ) bOnlyDiplomacyPowerTypes = false;
			}

			if ( bOnlyDiplomacyPowerTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Leadertype + Attitude + Text
	if ( iCase == 5 )
	{
		bool bLeaderAttitudeTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) && pNewResponse->getLeaderHeadTypes(iElement) )
				{
					for ( int iiElement = 0; iiElement < NUM_ATTITUDE_TYPES; ++iiElement )
					{
						if ( getAttitudeTypes(i, iiElement) && pNewResponse->getAttitudeTypes(iiElement) ) bLeaderAttitudeTypes = true;
					}
				}
			}
			for ( int iElement = 0; iElement < NUM_DIPLOMACYPOWER_TYPES; ++iElement )
			{
				if ( getDiplomacyPowerTypes(i, iElement) ) bLeaderAttitudeTypes = false;
			}

			if ( bLeaderAttitudeTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	// Leadertype + Power + Text
	if ( iCase == 6 )
	{
		bool bLeaderDiplomacyPowerTypes = false;

		for ( int i = 0; i < getNumResponses(); ++i )
		{
			for ( int iElement = 0; iElement < GC.getNumLeaderHeadInfos(); ++iElement )
			{
				if ( getLeaderHeadTypes(i, iElement) && pNewResponse->getLeaderHeadTypes(iElement) )
				{
					for ( int iiElement = 0; iiElement < NUM_DIPLOMACYPOWER_TYPES; ++iiElement )
					{
						if ( getDiplomacyPowerTypes(i, iiElement) && pNewResponse->getDiplomacyPowerTypes(iiElement) ) bLeaderDiplomacyPowerTypes = true;
					}
				}
			}
			for ( int iElement = 0; iElement < NUM_ATTITUDE_TYPES; ++iElement )
			{
				if ( getAttitudeTypes(i, iElement) ) bLeaderDiplomacyPowerTypes = false;
			}

			if ( bLeaderDiplomacyPowerTypes )
			{
				*iIndex = i;
				return true;
			}
		}
	}

	return false;  //This means there was no index, hence it's a new one and needs to be added to the vector
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvUnitClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvUnitClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvUnitClassInfo::CvUnitClassInfo() :
m_iMaxGlobalInstances(0),
m_iMaxTeamInstances(0),
m_iMaxPlayerInstances(0),
m_iInstanceCostModifier(0),
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
m_iReducedCostByYield(NO_YIELD),
m_bBattleCaptain(false),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
m_iDefaultUnitIndex(NO_UNIT)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvUnitClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvUnitClassInfo::~CvUnitClassInfo()
{
}

int CvUnitClassInfo::getMaxGlobalInstances() const
{
	return m_iMaxGlobalInstances;
}

int CvUnitClassInfo::getMaxTeamInstances() const
{
	return m_iMaxTeamInstances;
}

int CvUnitClassInfo::getMaxPlayerInstances() const
{
	return m_iMaxPlayerInstances;
}

int CvUnitClassInfo::getInstanceCostModifier() const
{
	return m_iInstanceCostModifier;
}

int CvUnitClassInfo::getDefaultUnitIndex() const
{
	return m_iDefaultUnitIndex;
}

void CvUnitClassInfo::setDefaultUnitIndex(int i)
{
	m_iDefaultUnitIndex = i;
}
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
int CvUnitClassInfo::getReducedCostByYield() const
{
	return m_iReducedCostByYield;
}

bool CvUnitClassInfo::isBattleCaptain() const
{
	return m_bBattleCaptain;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
int CvUnitClassInfo::getDefaultUnitIndexVector()
{
	return m_aszExtraXMLforPass3.size();
}
CvString CvUnitClassInfo::getDefaultUnitIndexVectorElement(int i)
{
	return m_aszExtraXMLforPass3[i];
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

bool CvUnitClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iMaxGlobalInstances, "iMaxGlobalInstances");
	pXML->GetChildXmlValByName(&m_iMaxTeamInstances, "iMaxTeamInstances");
	pXML->GetChildXmlValByName(&m_iMaxPlayerInstances, "iMaxPlayerInstances");
	pXML->GetChildXmlValByName(&m_iInstanceCostModifier, "iInstanceCostModifier");
	CvString szTextVal;
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
//	pXML->GetChildXmlValByName(szTextVal, "ReducedCostByYield");	disable
//	m_iReducedCostByYield = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_bBattleCaptain, "bBattleCaptain");
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "DefaultUnit");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	return true;
}

bool CvUnitClassInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**																								**/
/**	Earlier work with the m_asz list has reverse listed it, the last value to be read is listed	**/
/**	first.  So by checking all values for the first non-NULL case, we keep the spirit of WoC	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
/*
	m_iDefaultUnitIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iDefaultUnitIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(UnitClassInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitClassInfo::copyNonDefaults(CvUnitClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getMaxGlobalInstances()		== 0)		m_iMaxGlobalInstances					= pClassInfo->getMaxGlobalInstances();
	if (getMaxTeamInstances()		== 0)		m_iMaxTeamInstances						= pClassInfo->getMaxTeamInstances();
	if (getMaxPlayerInstances()		== 0)		m_iMaxPlayerInstances					= pClassInfo->getMaxPlayerInstances();
	if (getInstanceCostModifier()	== 0)		m_iInstanceCostModifier					= pClassInfo->getInstanceCostModifier();
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
	if (getReducedCostByYield()		== NO_YIELD)		m_iReducedCostByYield					= pClassInfo->getReducedCostByYield();
	if (isBattleCaptain()			== false)			m_bBattleCaptain						= pClassInfo->isBattleCaptain();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	for ( int i = 0; i < pClassInfo->getDefaultUnitIndexVector(); i++ )
	{
											m_aszExtraXMLforPass3.push_back(		pClassInfo->getDefaultUnitIndexVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvBuildingInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBuildingInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingInfo::CvBuildingInfo() :
m_iBuildingClassType(NO_BUILDINGCLASS),
m_iVictoryPrereq(NO_VICTORY),
m_iFreeStartEra(NO_ERA),
m_iMaxStartEra(NO_ERA),
m_iObsoleteTech(NO_TECH),
m_iPrereqAndTech(NO_TECH),
m_iNoBonus(NO_BONUS),
m_iPowerBonus(NO_BONUS),
m_iFreeBonus(NO_BONUS),
m_iNumFreeBonuses(0),
m_iFreeBuildingClass(NO_BUILDINGCLASS),
m_iFreePromotion(NO_PROMOTION),
m_iCivicOption(NO_CIVICOPTION),
m_iAIWeight(0),
m_iProductionCost(0),
m_iHurryCostModifier(0),
m_iHurryAngerModifier(0),
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iMinAreaSize(0),
m_iNumCitiesPrereq(0),
m_iNumTeamsPrereq(0),
m_iUnitLevelPrereq(0),
m_iMinLatitude(0),
m_iMaxLatitude(90),
m_iGreatPeopleRateModifier(0),
m_iGreatGeneralRateModifier(0),
m_iDomesticGreatGeneralRateModifier(0),
m_iGlobalGreatPeopleRateModifier(0),
m_iAnarchyModifier(0),
m_iGoldenAgeModifier(0),
m_iGlobalHurryModifier(0),
m_iFreeExperience(0),
m_iGlobalFreeExperience(0),
m_iFoodKept(0),
m_iAirlift(0),
m_iAirModifier(0),
m_iAirUnitCapacity(0),
m_iNukeModifier(0),
m_iNukeExplosionRand(0),
m_iFreeSpecialist(0),
m_iAreaFreeSpecialist(0),
m_iGlobalFreeSpecialist(0),
m_iHappiness(0),
m_iAreaHappiness(0),
m_iGlobalHappiness(0),
m_iStateReligionHappiness(0),
m_iWorkerSpeedModifier(0),
m_iMilitaryProductionModifier(0),
m_iSpaceProductionModifier(0),
m_iGlobalSpaceProductionModifier(0),
m_iTradeRoutes(0),
m_iCoastalTradeRoutes(0),
m_iGlobalTradeRoutes(0),
m_iTradeRouteModifier(0),
m_iForeignTradeRouteModifier(0),
m_iAssetValue(0),
m_iPowerValue(0),
m_iSpecialBuildingType(NO_SPECIALBUILDING),
m_iAdvisorType(NO_ADVISOR),
m_iHolyCity(NO_RELIGION),
m_iReligionType(NO_RELIGION),
m_iStateReligion(NO_RELIGION),
m_iPrereqReligion(NO_RELIGION),
m_iPrereqCorporation(NO_CORPORATION),
m_iFoundsCorporation(NO_CORPORATION),
m_iGlobalReligionCommerce(0),
m_iGlobalCorporationCommerce(0),
m_iPrereqAndBonus(NO_BONUS),
m_iGreatPeopleUnitClass(NO_UNITCLASS),
m_iGreatPeopleRateChange(0),
m_iConquestProbability(0),
m_iMaintenanceModifier(0),
m_iWarWearinessModifier(0),
m_iGlobalWarWearinessModifier(0),
m_iEnemyWarWearinessModifier(0),
m_iHealRateChange(0),
m_iHealth(0),
m_iAreaHealth(0),
m_iGlobalHealth(0),
m_iGlobalPopulationChange(0),
m_iFreeTechs(0),
m_iDefenseModifier(0),
m_iBombardDefenseModifier(0),
m_iAllCityDefenseModifier(0),
m_iEspionageDefenseModifier(0),
m_iMissionType(NO_MISSION),
m_iVoteSourceType(NO_VOTESOURCE),
m_fVisibilityPriority(0.0f),
m_bTeamShare(false),
m_bWater(false),
m_bRiver(false),
m_bPower(false),
m_bDirtyPower(false),
m_bAreaCleanPower(false),
m_bAreaBorderObstacle(false),
m_bForceTeamVoteEligible(false),
m_bCapital(false),
m_bGovernmentCenter(false),
m_bGoldenAge(false),
m_bMapCentering(false),
m_bNoUnhappiness(false),
m_bNoUnhealthyPopulation(false),
m_bBuildingOnlyHealthy(false),
m_bNeverCapture(false),
m_bNukeImmune(false),
m_bPrereqReligion(false),
m_bCenterInCity(false),
m_bStateReligion(false),
m_bAllowsNukes(false),
m_piPrereqAndTechs(NULL),
m_piPrereqOrBonuses(NULL),
m_piProductionTraits(NULL),
m_piHappinessTraits(NULL),
m_piSeaPlotYieldChange(NULL),
m_piRiverPlotYieldChange(NULL),
m_piGlobalSeaPlotYieldChange(NULL),
m_piYieldChange(NULL),
m_piYieldModifier(NULL),
m_piPowerYieldModifier(NULL),
m_piAreaYieldModifier(NULL),
m_piGlobalYieldModifier(NULL),
m_piCommerceChange(NULL),
m_piObsoleteSafeCommerceChange(NULL),
m_piCommerceChangeDoubleTime(NULL),
m_piCommerceModifier(NULL),
m_piGlobalCommerceModifier(NULL),
m_piSpecialistExtraCommerce(NULL),
m_piStateReligionCommerce(NULL),
m_piCommerceHappiness(NULL),
m_piReligionChange(NULL),
m_piSpecialistCount(NULL),
m_piFreeSpecialistCount(NULL),
m_piBonusHealthChanges(NULL),
m_piBonusHappinessChanges(NULL),
m_piBonusProductionModifier(NULL),
m_piUnitCombatFreeExperience(NULL),
m_piDomainFreeExperience(NULL),
m_piDomainProductionModifier(NULL),
m_piBuildingHappinessChanges(NULL),
m_piPrereqNumOfBuildingClass(NULL),
m_piFlavorValue(NULL),
m_piImprovementFreeSpecialist(NULL),
m_pbCommerceFlexible(NULL),
m_pbCommerceChangeOriginalOwner(NULL),
m_pbBuildingClassNeededInCity(NULL),
m_ppaiSpecialistYieldChange(NULL),
m_ppaiBonusYieldModifier(NULL),

//FfH Buildings: Added by Kael 08/04/2007
m_bApplyFreePromotionOnMove(false),
m_bEquipment(false),
m_bHideUnits(false),
m_bNoCivicAnger(false),
m_bRequiresCaster(false),
m_bSeeInvisible(false),
m_bUnhappyProduction(false),
m_iCrime(0),
m_iFreePromotionPick(0),
m_iFreeBonus2(NO_BONUS),
m_iFreeBonus3(NO_BONUS),
m_iGlobalResistEnemyModify(0),
m_iGlobalResistModify(0),
m_iModifyGlobalCounter(0),
m_iPlotRadius(0),
m_iPrereqCiv(NO_CIVILIZATION),
m_iPrereqTrait(NO_TRAIT),
m_iRemovePromotion(NO_PROMOTION),
m_iResistMagic(0),
m_ppaiSpecialistCommerceChange(NULL),
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
m_iMistDensity(0),
m_iManaFromImprovement(0),
m_iManaFromImprovementType(0),
m_iTaxesModifier(0),
m_iBuildingMaintenance(0),
m_iGPPThresholdReductionPercent(0),
m_iMaxManaChange(0),
m_iReducedCostByYieldOverwrite(NO_YIELD),
m_iPopulationCost(0),
m_iGlobalYieldTypeCost(0),
m_iGlobalYieldCost(0),
m_iUnitSupportChange(0),
m_iLastTurnPossibleBuild(0),
m_iCommercePercentTypeForced(NO_COMMERCE),
m_iPopulationLimitChange(0),
m_bAdjacentPeak(false),
m_bAdjacentUF(false),
m_bDistrict(false),
m_bReqGlobalYieldIncome(false),
m_bEnchantment(false),
m_iPrereqBuildingClass(NO_BUILDINGCLASS),
m_iPrereqBuildingClassInAllCities(NO_BUILDINGCLASS),
m_iPrereqImprovement(NO_IMPROVEMENT),
m_paiCommercePerPopulation(NULL),
m_paiCommercePerCultureLevel(NULL),
m_paiYieldPerCultureLevel(NULL),
m_iAISpecialization1(NO_CITYSPECIALIZATION),
m_iAISpecialization2(NO_CITYSPECIALIZATION),
m_iBonusYieldType(NO_YIELD),
m_iBonusCommerceType(NO_COMMERCE),
m_iInitialValue(0),
m_iPerBonusValue(0),
m_pabBonusLinked(NULL),
m_pabBonusConsumed(NULL),
m_pabBonusNearbyNeeded(NULL),
m_pabBuildingClassBlocked(NULL),
m_iPrereqCivic(NO_CIVIC),
m_ppiImprovementYieldChanges(NULL),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/*************************************************************************************************/
m_bVictoryBuilding(false),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Buildings can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
m_iRequiredGameOption(NO_GAMEOPTION),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Gameoption (Passive XP Training) Sephi                                           				    **/
/*************************************************************************************************/
m_paiTrainXPCap(NULL),
m_paiTrainXPRate(NULL),
m_paiGlobalTrainXPCap(NULL),
m_paiGlobalTrainXPRate(NULL),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
m_iCorporationSupportNeeded(NO_CORPORATION),
 m_paiCorporationSupport(NULL),
 m_paiCorporationSupportMod(NULL)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBuildingInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingInfo::~CvBuildingInfo()
{
	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	SAFE_DELETE_ARRAY(m_piProductionTraits);
	SAFE_DELETE_ARRAY(m_piHappinessTraits);
	SAFE_DELETE_ARRAY(m_piSeaPlotYieldChange);
	SAFE_DELETE_ARRAY(m_piRiverPlotYieldChange);
	SAFE_DELETE_ARRAY(m_piGlobalSeaPlotYieldChange);
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piYieldModifier);
	SAFE_DELETE_ARRAY(m_piPowerYieldModifier);
	SAFE_DELETE_ARRAY(m_piAreaYieldModifier);
	SAFE_DELETE_ARRAY(m_piGlobalYieldModifier);
	SAFE_DELETE_ARRAY(m_piCommerceChange);
	SAFE_DELETE_ARRAY(m_piObsoleteSafeCommerceChange);
	SAFE_DELETE_ARRAY(m_piCommerceChangeDoubleTime);
	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	SAFE_DELETE_ARRAY(m_piGlobalCommerceModifier);
	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	SAFE_DELETE_ARRAY(m_piStateReligionCommerce);
	SAFE_DELETE_ARRAY(m_piCommerceHappiness);
	SAFE_DELETE_ARRAY(m_piReligionChange);
	SAFE_DELETE_ARRAY(m_piSpecialistCount);
	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	SAFE_DELETE_ARRAY(m_piBonusHealthChanges);
	SAFE_DELETE_ARRAY(m_piBonusHappinessChanges);
	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	SAFE_DELETE_ARRAY(m_piUnitCombatFreeExperience);
	SAFE_DELETE_ARRAY(m_piDomainFreeExperience);
	SAFE_DELETE_ARRAY(m_piDomainProductionModifier);
	SAFE_DELETE_ARRAY(m_piBuildingHappinessChanges);
	SAFE_DELETE_ARRAY(m_piPrereqNumOfBuildingClass);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piImprovementFreeSpecialist);
	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);
	SAFE_DELETE_ARRAY(m_pbCommerceChangeOriginalOwner);
	SAFE_DELETE_ARRAY(m_pbBuildingClassNeededInCity);

	if (m_ppaiSpecialistYieldChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange);
	}

	if (m_ppaiBonusYieldModifier != NULL)
	{
		for(int i=0;i<GC.getNumBonusInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier);
	}

//FfH: Added by Kael 11/06/2007
	if (m_ppaiSpecialistCommerceChange != NULL)
	{
		for(int i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange);
	}
//FfH: End Add

	if (m_ppiImprovementYieldChanges != NULL)
	{
		for (int iI = 0; iI<GC.getNumImprovementInfos(); iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges);
	}
/*************************************************************************************************/
/**	New Gameoption (Passive XP Training) Sephi                                           				    **/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiTrainXPCap);
	SAFE_DELETE_ARRAY(m_paiTrainXPRate);
	SAFE_DELETE_ARRAY(m_paiGlobalTrainXPCap);
	SAFE_DELETE_ARRAY(m_paiGlobalTrainXPRate);
	SAFE_DELETE_ARRAY(m_paiCommercePerPopulation);
	SAFE_DELETE_ARRAY(m_paiCommercePerCultureLevel);
	SAFE_DELETE_ARRAY(m_paiYieldPerCultureLevel);
	SAFE_DELETE_ARRAY(m_pabBonusLinked);
	SAFE_DELETE_ARRAY(m_pabBonusConsumed);
	SAFE_DELETE_ARRAY(m_pabBonusNearbyNeeded);
	SAFE_DELETE_ARRAY(m_pabBuildingClassBlocked);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

}

int CvBuildingInfo::getBuildingClassType() const
{
	return m_iBuildingClassType;
}

int CvBuildingInfo::getVictoryPrereq() const
{
	return m_iVictoryPrereq;
}

int CvBuildingInfo::getFreeStartEra() const
{
	return m_iFreeStartEra;
}

int CvBuildingInfo::getMaxStartEra() const
{
	return m_iMaxStartEra;
}

int CvBuildingInfo::getObsoleteTech() const
{
	return m_iObsoleteTech;
}

int CvBuildingInfo::getPrereqAndTech() const
{
	return m_iPrereqAndTech;
}

int CvBuildingInfo::getNoBonus() const
{
	return m_iNoBonus;
}

int CvBuildingInfo::getPowerBonus() const
{
	return m_iPowerBonus;
}

int CvBuildingInfo::getFreeBonus() const
{
	return m_iFreeBonus;
}

int CvBuildingInfo::getNumFreeBonuses() const
{
	return m_iNumFreeBonuses;
}

int CvBuildingInfo::getFreeBuildingClass() const
{
	return m_iFreeBuildingClass;
}

void CvBuildingInfo::setNumFreeBuildingClass(int i)
{
	m_iFreeBuildingClass = i;
}

int CvBuildingInfo::getFreePromotion() const
{
	return m_iFreePromotion;
}

int CvBuildingInfo::getCivicOption() const
{
	return m_iCivicOption;
}

int CvBuildingInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvBuildingInfo::getProductionCost() const
{
	return m_iProductionCost;
}

int CvBuildingInfo::getHurryCostModifier() const
{
	return m_iHurryCostModifier;
}

int CvBuildingInfo::getHurryAngerModifier() const
{
	return m_iHurryAngerModifier;
}

int CvBuildingInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvBuildingInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvBuildingInfo::getMinAreaSize() const
{
	return m_iMinAreaSize;
}

int CvBuildingInfo::getNumCitiesPrereq() const
{
	return m_iNumCitiesPrereq;
}

int CvBuildingInfo::getNumTeamsPrereq() const
{
	return m_iNumTeamsPrereq;
}

int CvBuildingInfo::getUnitLevelPrereq() const
{
	return m_iUnitLevelPrereq;
}

int CvBuildingInfo::getMinLatitude() const
{
	return m_iMinLatitude;
}

int CvBuildingInfo::getMaxLatitude() const
{
	return m_iMaxLatitude;
}

int CvBuildingInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvBuildingInfo::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

int CvBuildingInfo::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

int CvBuildingInfo::getGlobalGreatPeopleRateModifier() const
{
	return m_iGlobalGreatPeopleRateModifier;
}

int CvBuildingInfo::getAnarchyModifier() const
{
	return m_iAnarchyModifier;
}

int CvBuildingInfo::getGoldenAgeModifier() const
{
	return m_iGoldenAgeModifier;
}

int CvBuildingInfo::getGlobalHurryModifier() const
{
	return m_iGlobalHurryModifier;
}

int CvBuildingInfo::getFreeExperience() const
{
	return m_iFreeExperience;
}

int CvBuildingInfo::getGlobalFreeExperience() const
{
	return m_iGlobalFreeExperience;
}

int CvBuildingInfo::getFoodKept() const
{
	return m_iFoodKept;
}

int CvBuildingInfo::getAirlift() const
{
	return m_iAirlift;
}

int CvBuildingInfo::getAirModifier() const
{
	return m_iAirModifier;
}

int CvBuildingInfo::getAirUnitCapacity() const
{
	return m_iAirUnitCapacity;
}

int CvBuildingInfo::getNukeModifier() const
{
	return m_iNukeModifier;
}

int CvBuildingInfo::getNukeExplosionRand() const
{
	return m_iNukeExplosionRand;
}

int CvBuildingInfo::getFreeSpecialist() const
{
	return m_iFreeSpecialist;
}

int CvBuildingInfo::getAreaFreeSpecialist() const
{
	return m_iAreaFreeSpecialist;
}

int CvBuildingInfo::getGlobalFreeSpecialist() const
{
	return m_iGlobalFreeSpecialist;
}

int CvBuildingInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvBuildingInfo::getAreaHappiness() const
{
	return m_iAreaHappiness;
}

int CvBuildingInfo::getGlobalHappiness() const
{
	return m_iGlobalHappiness;
}

int CvBuildingInfo::getStateReligionHappiness() const
{
	return m_iStateReligionHappiness;
}

int CvBuildingInfo::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}

int CvBuildingInfo::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}

int CvBuildingInfo::getSpaceProductionModifier() const
{
	return m_iSpaceProductionModifier;
}

int CvBuildingInfo::getGlobalSpaceProductionModifier() const
{
	return m_iGlobalSpaceProductionModifier;
}

int CvBuildingInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvBuildingInfo::getCoastalTradeRoutes() const
{
	return m_iCoastalTradeRoutes;
}

int CvBuildingInfo::getGlobalTradeRoutes() const
{
	return m_iGlobalTradeRoutes;
}

int CvBuildingInfo::getTradeRouteModifier() const
{
	return m_iTradeRouteModifier;
}

int CvBuildingInfo::getForeignTradeRouteModifier() const
{
	return m_iForeignTradeRouteModifier;
}

int CvBuildingInfo::getAssetValue() const
{
	return m_iAssetValue;
}

int CvBuildingInfo::getPowerValue() const
{
	return m_iPowerValue;
}

int CvBuildingInfo::getSpecialBuildingType() const
{
	return m_iSpecialBuildingType;
}

int CvBuildingInfo::getAdvisorType() const
{
	return m_iAdvisorType;
}

int CvBuildingInfo::getHolyCity() const
{
	return m_iHolyCity;
}

int CvBuildingInfo::getReligionType() const
{
	return m_iReligionType;
}

int CvBuildingInfo::getStateReligion() const
{
	return m_iStateReligion;
}

int CvBuildingInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}

int CvBuildingInfo::getPrereqCorporation() const
{
	return m_iPrereqCorporation;
}

int CvBuildingInfo::getFoundsCorporation() const
{
	return m_iFoundsCorporation;
}

int CvBuildingInfo::getGlobalReligionCommerce() const
{
	return m_iGlobalReligionCommerce;
}

int CvBuildingInfo::getGlobalCorporationCommerce() const
{
	return m_iGlobalCorporationCommerce;
}

int CvBuildingInfo::getPrereqAndBonus() const
{
	return m_iPrereqAndBonus;
}

int CvBuildingInfo::getGreatPeopleUnitClass() const
{
	return m_iGreatPeopleUnitClass;
}

int CvBuildingInfo::getGreatPeopleRateChange() const
{
	return m_iGreatPeopleRateChange;
}

int CvBuildingInfo::getConquestProbability() const
{
	return m_iConquestProbability;
}

int CvBuildingInfo::getMaintenanceModifier() const
{
	return m_iMaintenanceModifier;
}

int CvBuildingInfo::getWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

int CvBuildingInfo::getGlobalWarWearinessModifier() const
{
	return m_iGlobalWarWearinessModifier;
}

int CvBuildingInfo::getEnemyWarWearinessModifier() const
{
	return m_iEnemyWarWearinessModifier;
}

int CvBuildingInfo::getHealRateChange() const
{
	return m_iHealRateChange;
}

int CvBuildingInfo::getHealth() const
{
	return m_iHealth;
}

int CvBuildingInfo::getAreaHealth() const
{
	return m_iAreaHealth;
}

int CvBuildingInfo::getGlobalHealth() const
{
	return m_iGlobalHealth;
}

int CvBuildingInfo::getGlobalPopulationChange() const
{
	return m_iGlobalPopulationChange;
}

int CvBuildingInfo::getFreeTechs() const
{
	return m_iFreeTechs;
}

int CvBuildingInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

int CvBuildingInfo::getBombardDefenseModifier() const
{
	return m_iBombardDefenseModifier;
}

int CvBuildingInfo::getAllCityDefenseModifier() const
{
	return m_iAllCityDefenseModifier;
}

int CvBuildingInfo::getEspionageDefenseModifier() const
{
	return m_iEspionageDefenseModifier;
}

int CvBuildingInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvBuildingInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

int CvBuildingInfo::getVoteSourceType() const
{
	return m_iVoteSourceType;
}

float CvBuildingInfo::getVisibilityPriority() const
{
	return m_fVisibilityPriority;
}

bool CvBuildingInfo::isTeamShare() const
{
	return m_bTeamShare;
}

bool CvBuildingInfo::isWater() const
{
	return m_bWater;
}

bool CvBuildingInfo::isRiver() const
{
	return m_bRiver;
}

bool CvBuildingInfo::isPower() const
{
	return m_bPower;
}

bool CvBuildingInfo::isDirtyPower() const
{
	return m_bDirtyPower;
}

bool CvBuildingInfo::isAreaCleanPower() const
{
	return m_bAreaCleanPower;
}

bool CvBuildingInfo::isAreaBorderObstacle() const
{
	return m_bAreaBorderObstacle;
}

bool CvBuildingInfo::isForceTeamVoteEligible() const
{
	return m_bForceTeamVoteEligible;
}

bool CvBuildingInfo::isCapital() const
{
	return m_bCapital;
}

bool CvBuildingInfo::isGovernmentCenter() const
{
	return m_bGovernmentCenter;
}

bool CvBuildingInfo::isGoldenAge() const
{
	return m_bGoldenAge;
}

bool CvBuildingInfo::isMapCentering() const
{
	return m_bMapCentering;
}

bool CvBuildingInfo::isNoUnhappiness() const
{
	return m_bNoUnhappiness;
}

bool CvBuildingInfo::isNoUnhealthyPopulation() const
{
	return m_bNoUnhealthyPopulation;
}

bool CvBuildingInfo::isBuildingOnlyHealthy() const
{
	return m_bBuildingOnlyHealthy;
}

bool CvBuildingInfo::isNeverCapture() const
{
	return m_bNeverCapture;
}

bool CvBuildingInfo::isNukeImmune() const
{
	return m_bNukeImmune;
}

bool CvBuildingInfo::isPrereqReligion() const
{
	return m_bPrereqReligion;
}

bool CvBuildingInfo::isCenterInCity() const
{
	return m_bCenterInCity;
}

bool CvBuildingInfo::isStateReligion() const
{
	return m_bStateReligion;
}

bool CvBuildingInfo::isAllowsNukes() const
{
	return m_bAllowsNukes;
}

const TCHAR* CvBuildingInfo::getConstructSound() const
{
	return m_szConstructSound;
}

void CvBuildingInfo::setConstructSound(const TCHAR* szVal)
{
	m_szConstructSound = szVal;
}

const TCHAR* CvBuildingInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvBuildingInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

const TCHAR* CvBuildingInfo::getMovieDefineTag() const
{
	return m_szMovieDefineTag;
}

void CvBuildingInfo::setMovieDefineTag(const TCHAR* szVal)
{
	m_szMovieDefineTag = szVal;
}

//FfH Buildings: Added by Kael 08/04/2007
bool CvBuildingInfo::isApplyFreePromotionOnMove() const
{
	return m_bApplyFreePromotionOnMove;
}

bool CvBuildingInfo::isEquipment() const
{
	return m_bEquipment;
}

bool CvBuildingInfo::isHideUnits() const
{
	return m_bHideUnits;
}

bool CvBuildingInfo::isNoCivicAnger() const
{
	return m_bNoCivicAnger;
}

bool CvBuildingInfo::isSeeInvisible() const
{
	return m_bSeeInvisible;
}

bool CvBuildingInfo::isUnhappyProduction() const
{
	return m_bUnhappyProduction;
}

int CvBuildingInfo::getCrime() const
{
	return m_iCrime;
}

int CvBuildingInfo::getFreePromotionPick() const
{
	return m_iFreePromotionPick;
}

int CvBuildingInfo::getFreeBonus2() const
{
	return m_iFreeBonus2;
}

int CvBuildingInfo::getFreeBonus3() const
{
	return m_iFreeBonus3;
}

int CvBuildingInfo::getGlobalResistEnemyModify() const
{
	return m_iGlobalResistEnemyModify;
}

int CvBuildingInfo::getGlobalResistModify() const
{
	return m_iGlobalResistModify;
}

int CvBuildingInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvBuildingInfo::getPlotRadius() const
{
	return m_iPlotRadius;
}

int CvBuildingInfo::getPrereqCiv() const
{
	return m_iPrereqCiv;
}
int CvBuildingInfo::getPrereqCivVectorSize()						{return m_aszExtraXMLforPass3.size();}
CvString CvBuildingInfo::getPrereqCivVectorElement(int i)			{return m_aszExtraXMLforPass3[i];}
int CvBuildingInfo::getPrereqCivicVectorSize()						{return m_aszExtraXML1forPass3.size();}
CvString CvBuildingInfo::getPrereqCivicVectorElement(int i)			{return m_aszExtraXML1forPass3[i];}

int CvBuildingInfo::getPrereqTrait() const
{
	return m_iPrereqTrait;
}

int CvBuildingInfo::getRemovePromotion() const
{
	return m_iRemovePromotion;
}

int CvBuildingInfo::getResistMagic() const
{
	return m_iResistMagic;
}

int CvBuildingInfo::getSpecialistCommerceChange(int i, int j) const
{
	return m_ppaiSpecialistCommerceChange ? m_ppaiSpecialistCommerceChange[i][j] : -1;
}

int* CvBuildingInfo::getSpecialistCommerceChangeArray(int i) const
{
	return m_ppaiSpecialistCommerceChange[i];
}
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
int CvBuildingInfo::getMistDensity() const
{
	return m_iMistDensity;
}

int CvBuildingInfo::getManaFromImprovement() const
{
	return m_iManaFromImprovement;
}

int CvBuildingInfo::getManaFromImprovementType() const
{
	return m_iManaFromImprovementType;
}

int CvBuildingInfo::getTaxesModifier() const
{
	return m_iTaxesModifier;
}

int CvBuildingInfo::getBuildingMaintenance() const
{
	return m_iBuildingMaintenance;
}

int CvBuildingInfo::getGPPThresholdReductionPercent() const
{
	return m_iGPPThresholdReductionPercent;
}

int CvBuildingInfo::getMaxManaChange() const
{
	return m_iMaxManaChange;
}

int CvBuildingInfo::getReducedCostByYieldOverwrite() const
{
	return m_iReducedCostByYieldOverwrite;
}

int CvBuildingInfo::getReducedCostByYield() const
{
	if(getReducedCostByYieldOverwrite()==NO_BUILDING)
	{
		return GC.getBuildingClassInfo((BuildingClassTypes)getBuildingClassType()).getReducedCostByYield();
	}

	return getReducedCostByYieldOverwrite();
}

int CvBuildingInfo::getPopulationCost() const
{
	return m_iPopulationCost;
}

int CvBuildingInfo::getPopulationLimitChange() const
{
	return m_iPopulationLimitChange;
}

int CvBuildingInfo::getGlobalYieldTypeCost() const { return m_iGlobalYieldTypeCost; }
int CvBuildingInfo::getGlobalYieldCost() const { return m_iGlobalYieldCost; }

int CvBuildingInfo::getUnitSupportChange() const
{
	return m_iUnitSupportChange;
}

int CvBuildingInfo::getLastTurnPossibleBuild() const
{
	return m_iLastTurnPossibleBuild;
}

int CvBuildingInfo::getCommercePercentTypeForced() const
{
	return m_iCommercePercentTypeForced;
}

bool CvBuildingInfo::isAdjacentPeak() const
{
	return m_bAdjacentPeak;
}

bool CvBuildingInfo::isAdjacentUF() const
{
	return m_bAdjacentUF;
}

bool CvBuildingInfo::isDistrict() const
{
	return m_bDistrict;
}

bool CvBuildingInfo::isReqGlobalYieldIncome() const
{
	return m_bReqGlobalYieldIncome;
}

bool CvBuildingInfo::isEnchantment() const
{
	return m_bEnchantment;
}

int CvBuildingInfo::getPrereqBuildingClass() const
{
	return m_iPrereqBuildingClass;
}

int CvBuildingInfo::getPrereqBuildingClassInAllCities() const
{
	return m_iPrereqBuildingClassInAllCities;
}

int CvBuildingInfo::getPrereqImprovement() const
{
	return m_iPrereqImprovement;
}

int CvBuildingInfo::getCommercePerPopulation(int iCommerce) const
{
	return m_paiCommercePerPopulation[iCommerce];
}

int CvBuildingInfo::getCommercePerCultureLevel(int iCommerce) const
{
	return m_paiCommercePerCultureLevel[iCommerce];
}

int CvBuildingInfo::getYieldPerCultureLevel(int iYield) const
{
	return m_paiYieldPerCultureLevel[iYield];
}

int CvBuildingInfo::getAISpecialization1() const
{
	return m_iAISpecialization1;
}

int CvBuildingInfo::getAISpecialization2() const
{
	return m_iAISpecialization2;
}

int CvBuildingInfo::getBonusYieldType() const
{
	return m_iBonusYieldType;
}

int CvBuildingInfo::getBonusCommerceType() const
{
	return m_iBonusCommerceType;
}

int CvBuildingInfo::getInitialValue() const
{
	return m_iInitialValue;
}

int CvBuildingInfo::getPerBonusValue() const
{
	return m_iPerBonusValue;
}

bool CvBuildingInfo::isBonusLinked(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabBonusLinked[i];
}

bool CvBuildingInfo::isBonusConsumed(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabBonusConsumed[i];
}

bool CvBuildingInfo::isBonusNearbyNeeded(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabBonusNearbyNeeded[i];
}

bool CvBuildingInfo::isBuildingClassBlocked(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabBuildingClassBlocked[i];
}

int CvBuildingInfo::getPrereqCivic() const
{
	return	m_iPrereqCivic;
}

int CvBuildingInfo::getImprovementYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiImprovementYieldChanges[i][j];
}

int* CvBuildingInfo::getImprovementYieldChangesArray(int i)
{
	return m_ppiImprovementYieldChanges[i];
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
int CvBuildingInfo::isVictoryBuilding() const
{
	return m_bVictoryBuilding;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	ADDON (Buildings can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
int CvBuildingInfo::getTrainXPRate(int iI) const
{
	return m_paiTrainXPRate[iI];
}
int CvBuildingInfo::getTrainXPCap(int iI) const
{
	return m_paiTrainXPCap[iI];
}
int CvBuildingInfo::getGlobalTrainXPRate(int iI) const
{
	return m_paiGlobalTrainXPRate[iI];
}
int CvBuildingInfo::getGlobalTrainXPCap(int iI) const
{
	return m_paiGlobalTrainXPCap[iI];
}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	ADDON (Buildings can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
int CvBuildingInfo::getRequiredGameOption() const
{
	return m_iRequiredGameOption;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvBuildingInfo::getCorporationSupportNeeded() const
{
	return m_iCorporationSupportNeeded;
}

int CvBuildingInfo::getCorporationSupport(int iCorporation) const
{
	return m_paiCorporationSupport[iCorporation];
}

int CvBuildingInfo::getCorporationSupportMultiplier(int iCorporation) const
{
	return m_paiCorporationSupportMod[iCorporation];
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

// Arrays

int CvBuildingInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int* CvBuildingInfo::getYieldChangeArray() const
{
	return m_piYieldChange;
}

int CvBuildingInfo::getYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldModifier ? m_piYieldModifier[i] : -1;
}

int* CvBuildingInfo::getYieldModifierArray() const
{
	return m_piYieldModifier;
}

int CvBuildingInfo::getPowerYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPowerYieldModifier ? m_piPowerYieldModifier[i] : -1;
}

int* CvBuildingInfo::getPowerYieldModifierArray() const
{
	return m_piPowerYieldModifier;
}

int CvBuildingInfo::getAreaYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAreaYieldModifier ? m_piAreaYieldModifier[i] : -1;
}

int* CvBuildingInfo::getAreaYieldModifierArray() const
{
	return m_piAreaYieldModifier;
}

int CvBuildingInfo::getGlobalYieldModifier(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGlobalYieldModifier ? m_piGlobalYieldModifier[i] : -1;
}

int* CvBuildingInfo::getGlobalYieldModifierArray() const
{
	return m_piGlobalYieldModifier;
}

int CvBuildingInfo::getSeaPlotYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSeaPlotYieldChange ? m_piSeaPlotYieldChange[i] : -1;
}

int* CvBuildingInfo::getSeaPlotYieldChangeArray() const
{
	return m_piSeaPlotYieldChange;
}

int CvBuildingInfo::getRiverPlotYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverPlotYieldChange ? m_piRiverPlotYieldChange[i] : -1;
}

int* CvBuildingInfo::getRiverPlotYieldChangeArray() const
{
	return m_piRiverPlotYieldChange;
}

int CvBuildingInfo::getGlobalSeaPlotYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGlobalSeaPlotYieldChange ? m_piGlobalSeaPlotYieldChange[i] : -1;
}

int* CvBuildingInfo::getGlobalSeaPlotYieldChangeArray() const
{
	return m_piGlobalSeaPlotYieldChange;
}

int CvBuildingInfo::getCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceChange ? m_piCommerceChange[i] : -1;
}

int* CvBuildingInfo::getCommerceChangeArray() const
{
	return m_piCommerceChange;
}

int CvBuildingInfo::getObsoleteSafeCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piObsoleteSafeCommerceChange ? m_piObsoleteSafeCommerceChange[i] : -1;
}

int* CvBuildingInfo::getObsoleteSafeCommerceChangeArray() const
{
	return m_piObsoleteSafeCommerceChange;
}

int CvBuildingInfo::getCommerceChangeDoubleTime(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceChangeDoubleTime ? m_piCommerceChangeDoubleTime[i] : -1;
}

int CvBuildingInfo::getCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceModifier ? m_piCommerceModifier[i] : -1;
}

int* CvBuildingInfo::getCommerceModifierArray() const
{
	return m_piCommerceModifier;
}

int CvBuildingInfo::getGlobalCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGlobalCommerceModifier ? m_piGlobalCommerceModifier[i] : -1;
}

int* CvBuildingInfo::getGlobalCommerceModifierArray() const
{
	return m_piGlobalCommerceModifier;
}

int CvBuildingInfo::getSpecialistExtraCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSpecialistExtraCommerce ? m_piSpecialistExtraCommerce[i] : -1;
}

int* CvBuildingInfo::getSpecialistExtraCommerceArray() const
{
	return m_piSpecialistExtraCommerce;
}

int CvBuildingInfo::getStateReligionCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piStateReligionCommerce ? m_piStateReligionCommerce[i] : -1;
}

int* CvBuildingInfo::getStateReligionCommerceArray() const
{
	return m_piStateReligionCommerce;
}

int CvBuildingInfo::getCommerceHappiness(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceHappiness ? m_piCommerceHappiness[i] : -1;
}

int CvBuildingInfo::getReligionChange(int i) const
{
	FAssertMsg(i < GC.getNumReligionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piReligionChange ? m_piReligionChange[i] : -1;
}

int CvBuildingInfo::getSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piSpecialistCount ? m_piSpecialistCount[i] : -1;
}

int CvBuildingInfo::getFreeSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFreeSpecialistCount ? m_piFreeSpecialistCount[i] : -1;
}

int CvBuildingInfo::getBonusHealthChanges(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusHealthChanges ? m_piBonusHealthChanges[i] : -1;
}

int CvBuildingInfo::getBonusHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusHappinessChanges ? m_piBonusHappinessChanges[i] : -1;
}

int CvBuildingInfo::getBonusProductionModifier(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusProductionModifier ? m_piBonusProductionModifier[i] : -1;
}

int CvBuildingInfo::getUnitCombatFreeExperience(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatFreeExperience ? m_piUnitCombatFreeExperience[i] : -1;
}

int CvBuildingInfo::getDomainFreeExperience(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDomainFreeExperience ? m_piDomainFreeExperience[i] : -1;
}

int CvBuildingInfo::getDomainProductionModifier(int i) const
{
	FAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDomainProductionModifier ? m_piDomainProductionModifier[i] : -1;
}

int CvBuildingInfo::getPrereqAndTechs(int i) const
{
	FAssertMsg(i < GC.getNUM_BUILDING_AND_TECH_PREREQS(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;
}

int CvBuildingInfo::getPrereqOrBonuses(int i) const
{
	FAssertMsg(i < GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqOrBonuses ? m_piPrereqOrBonuses[i] : -1;
}

int CvBuildingInfo::getProductionTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
}

int CvBuildingInfo::getHappinessTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHappinessTraits ? m_piHappinessTraits[i] : -1;
}

int CvBuildingInfo::getBuildingHappinessChanges(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBuildingHappinessChanges ? m_piBuildingHappinessChanges[i] : -1;
}

int CvBuildingInfo::getPrereqNumOfBuildingClass(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqNumOfBuildingClass ? m_piPrereqNumOfBuildingClass[i] : -1;
}

int CvBuildingInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvBuildingInfo::getImprovementFreeSpecialist(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piImprovementFreeSpecialist ? m_piImprovementFreeSpecialist[i] : -1;
}

bool CvBuildingInfo::isCommerceFlexible(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCommerceFlexible ? m_pbCommerceFlexible[i] : false;
}

bool CvBuildingInfo::isCommerceChangeOriginalOwner(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCommerceChangeOriginalOwner ? m_pbCommerceChangeOriginalOwner[i] : false;
}

bool CvBuildingInfo::isBuildingClassNeededInCity(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbBuildingClassNeededInCity ? m_pbBuildingClassNeededInCity[i] : false;
}

int CvBuildingInfo::getSpecialistYieldChange(int i, int j) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppaiSpecialistYieldChange ? m_ppaiSpecialistYieldChange[i][j] : -1;
}

int* CvBuildingInfo::getSpecialistYieldChangeArray(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppaiSpecialistYieldChange[i];
}

int CvBuildingInfo::getBonusYieldModifier(int i, int j) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppaiBonusYieldModifier ? m_ppaiBonusYieldModifier[i][j] : -1;
}

int* CvBuildingInfo::getBonusYieldModifierArray(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_ppaiBonusYieldModifier[i];
}

const TCHAR* CvBuildingInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	Could do this during the CopyNonDefaults comparison, but may prove handy elsewhere later	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoBuilding * pBuildingArtInfo;
	pBuildingArtInfo = getArtInfo();
	if (pBuildingArtInfo != NULL)
	{
		return pBuildingArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

const CvArtInfoBuilding* CvBuildingInfo::getArtInfo() const
{
	return ARTFILEMGR.getBuildingArtInfo(getArtDefineTag());
}

const CvArtInfoMovie* CvBuildingInfo::getMovieInfo() const
{
	const TCHAR* pcTag = getMovieDefineTag();
	if (NULL != pcTag && 0 != _tcscmp(pcTag, "NONE"))
	{
		return ARTFILEMGR.getMovieArtInfo(pcTag);
	}
	else
	{
		return NULL;
	}
}

const TCHAR* CvBuildingInfo::getMovie() const
{
	const CvArtInfoMovie* pArt;
	pArt = getMovieInfo();
	if (pArt != NULL)
	{
		return pArt->getPath();
	}
	else
	{
		return NULL;
	}
}


//
// serialization
//
void CvBuildingInfo::read(FDataStreamBase* stream)
{
	CvHotkeyInfo::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iBuildingClassType);
	stream->Read(&m_iVictoryPrereq);
	stream->Read(&m_iFreeStartEra);
	stream->Read(&m_iMaxStartEra);
	stream->Read(&m_iObsoleteTech);
	stream->Read(&m_iPrereqAndTech);
	stream->Read(&m_iNoBonus);
	stream->Read(&m_iPowerBonus);
	stream->Read(&m_iFreeBonus);
	stream->Read(&m_iNumFreeBonuses);
	stream->Read(&m_iFreeBuildingClass);
	stream->Read(&m_iFreePromotion);
	stream->Read(&m_iCivicOption);
	stream->Read(&m_iAIWeight);
	stream->Read(&m_iProductionCost);
	stream->Read(&m_iHurryCostModifier);
	stream->Read(&m_iHurryAngerModifier);
	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);
	stream->Read(&m_iMinAreaSize);
	stream->Read(&m_iNumCitiesPrereq);
	stream->Read(&m_iNumTeamsPrereq);
	stream->Read(&m_iUnitLevelPrereq);
	stream->Read(&m_iMinLatitude);
	stream->Read(&m_iMaxLatitude);
	stream->Read(&m_iGreatPeopleRateModifier);
	stream->Read(&m_iGreatGeneralRateModifier);
	stream->Read(&m_iDomesticGreatGeneralRateModifier);
	stream->Read(&m_iGlobalGreatPeopleRateModifier);
	stream->Read(&m_iAnarchyModifier);
	stream->Read(&m_iGoldenAgeModifier);
	stream->Read(&m_iGlobalHurryModifier);
	stream->Read(&m_iFreeExperience);
	stream->Read(&m_iGlobalFreeExperience);
	stream->Read(&m_iFoodKept);
	stream->Read(&m_iAirlift);
	stream->Read(&m_iAirModifier);
	stream->Read(&m_iAirUnitCapacity);
	stream->Read(&m_iNukeModifier);
	stream->Read(&m_iNukeExplosionRand);
	stream->Read(&m_iFreeSpecialist);
	stream->Read(&m_iAreaFreeSpecialist);
	stream->Read(&m_iGlobalFreeSpecialist);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iAreaHappiness);
	stream->Read(&m_iGlobalHappiness);
	stream->Read(&m_iStateReligionHappiness);
	stream->Read(&m_iWorkerSpeedModifier);
	stream->Read(&m_iMilitaryProductionModifier);
	stream->Read(&m_iSpaceProductionModifier);
	stream->Read(&m_iGlobalSpaceProductionModifier);
	stream->Read(&m_iTradeRoutes);
	stream->Read(&m_iCoastalTradeRoutes);
	stream->Read(&m_iGlobalTradeRoutes);
	stream->Read(&m_iTradeRouteModifier);
	stream->Read(&m_iForeignTradeRouteModifier);
	stream->Read(&m_iAssetValue);
	stream->Read(&m_iPowerValue);
	stream->Read(&m_iSpecialBuildingType);
	stream->Read(&m_iAdvisorType);
	stream->Read(&m_iHolyCity);
	stream->Read(&m_iReligionType);
	stream->Read(&m_iStateReligion);
	stream->Read(&m_iPrereqReligion);
	stream->Read(&m_iPrereqCorporation);
	stream->Read(&m_iFoundsCorporation);
	stream->Read(&m_iGlobalReligionCommerce);
	stream->Read(&m_iGlobalCorporationCommerce);
	stream->Read(&m_iPrereqAndBonus);
	stream->Read(&m_iGreatPeopleUnitClass);
	stream->Read(&m_iGreatPeopleRateChange);
	stream->Read(&m_iConquestProbability);
	stream->Read(&m_iMaintenanceModifier);
	stream->Read(&m_iWarWearinessModifier);
	stream->Read(&m_iGlobalWarWearinessModifier);
	stream->Read(&m_iEnemyWarWearinessModifier);
	stream->Read(&m_iHealRateChange);
	stream->Read(&m_iHealth);
	stream->Read(&m_iAreaHealth);
	stream->Read(&m_iGlobalHealth);
	stream->Read(&m_iGlobalPopulationChange);
	stream->Read(&m_iFreeTechs);
	stream->Read(&m_iDefenseModifier);
	stream->Read(&m_iBombardDefenseModifier);
	stream->Read(&m_iAllCityDefenseModifier);
	stream->Read(&m_iEspionageDefenseModifier);
	stream->Read(&m_iMissionType);
	stream->Read(&m_iVoteSourceType);

	stream->Read(&m_fVisibilityPriority);

	stream->Read(&m_bTeamShare);
	stream->Read(&m_bWater);
	stream->Read(&m_bRiver);
	stream->Read(&m_bPower);
	stream->Read(&m_bDirtyPower);
	stream->Read(&m_bAreaCleanPower);
	stream->Read(&m_bAreaBorderObstacle);
	stream->Read(&m_bForceTeamVoteEligible);
	stream->Read(&m_bCapital);
	stream->Read(&m_bGovernmentCenter);
	stream->Read(&m_bGoldenAge);
	stream->Read(&m_bMapCentering);
	stream->Read(&m_bNoUnhappiness);
	stream->Read(&m_bNoUnhealthyPopulation);
	stream->Read(&m_bBuildingOnlyHealthy);
	stream->Read(&m_bNeverCapture);
	stream->Read(&m_bNukeImmune);
	stream->Read(&m_bPrereqReligion);
	stream->Read(&m_bCenterInCity);
	stream->Read(&m_bStateReligion);
	stream->Read(&m_bAllowsNukes);

	stream->ReadString(m_szConstructSound);
	stream->ReadString(m_szArtDefineTag);
	stream->ReadString(m_szMovieDefineTag);

//FfH Buildings: Added by Kael 08/04/2007
	stream->Read(&m_bApplyFreePromotionOnMove);
	stream->Read(&m_bEquipment);
	stream->Read(&m_bHideUnits);
	stream->Read(&m_bNoCivicAnger);
	stream->Read(&m_bRequiresCaster);
	stream->Read(&m_bSeeInvisible);
	stream->Read(&m_bUnhappyProduction);
	stream->Read(&m_iCrime);
	stream->Read(&m_iFreePromotionPick);
	stream->Read(&m_iFreeBonus2);
	stream->Read(&m_iFreeBonus3);
	stream->Read(&m_iGlobalResistEnemyModify);
	stream->Read(&m_iGlobalResistModify);
	stream->Read(&m_iModifyGlobalCounter);
	stream->Read(&m_iPlotRadius);
	stream->Read(&m_iPrereqCiv);
	stream->Read(&m_iPrereqTrait);
	stream->Read(&m_iRemovePromotion);
	stream->Read(&m_iResistMagic);
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
	stream->Read(&m_bVictoryBuilding);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Buildings can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	stream->Read(&m_iRequiredGameOption);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Gameoption (Passive XP Training) Sephi                                           				    **/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiTrainXPCap);
	m_paiTrainXPCap = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_paiTrainXPCap);

	SAFE_DELETE_ARRAY(m_paiTrainXPRate);
	m_paiTrainXPRate = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_paiTrainXPRate);

	SAFE_DELETE_ARRAY(m_paiGlobalTrainXPCap);
	m_paiGlobalTrainXPCap = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_paiGlobalTrainXPCap);

	SAFE_DELETE_ARRAY(m_paiGlobalTrainXPRate);
	m_paiGlobalTrainXPRate = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_paiGlobalTrainXPRate);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Read(&m_iCorporationSupportNeeded);
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupport);

	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
	stream->Read(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);
	m_piPrereqAndTechs = new int[GC.getNUM_BUILDING_AND_TECH_PREREQS()];
	stream->Read(GC.getNUM_BUILDING_AND_TECH_PREREQS(), m_piPrereqAndTechs);

	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
	m_piPrereqOrBonuses = new int[GC.getNUM_BUILDING_PREREQ_OR_BONUSES()];
	stream->Read(GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);

	SAFE_DELETE_ARRAY(m_piProductionTraits);
	m_piProductionTraits = new int[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_piProductionTraits);

	SAFE_DELETE_ARRAY(m_piHappinessTraits);
	m_piHappinessTraits = new int[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_piHappinessTraits);

	SAFE_DELETE_ARRAY(m_piSeaPlotYieldChange);
	m_piSeaPlotYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piSeaPlotYieldChange);

	SAFE_DELETE_ARRAY(m_piRiverPlotYieldChange);
	m_piRiverPlotYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piRiverPlotYieldChange);

	SAFE_DELETE_ARRAY(m_piGlobalSeaPlotYieldChange);
	m_piGlobalSeaPlotYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piGlobalSeaPlotYieldChange);

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);

	SAFE_DELETE_ARRAY(m_piYieldModifier);
	m_piYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldModifier);

	SAFE_DELETE_ARRAY(m_piPowerYieldModifier);
	m_piPowerYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piPowerYieldModifier);

	SAFE_DELETE_ARRAY(m_piAreaYieldModifier);
	m_piAreaYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piAreaYieldModifier);

	SAFE_DELETE_ARRAY(m_piGlobalYieldModifier);
	m_piGlobalYieldModifier = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piGlobalYieldModifier);

	SAFE_DELETE_ARRAY(m_piCommerceChange);
	m_piCommerceChange = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceChange);

	SAFE_DELETE_ARRAY(m_piObsoleteSafeCommerceChange);
	m_piObsoleteSafeCommerceChange = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piObsoleteSafeCommerceChange);

	SAFE_DELETE_ARRAY(m_piCommerceChangeDoubleTime);
	m_piCommerceChangeDoubleTime = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceChangeDoubleTime);

	SAFE_DELETE_ARRAY(m_piCommerceModifier);
	m_piCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceModifier);

	SAFE_DELETE_ARRAY(m_piGlobalCommerceModifier);
	m_piGlobalCommerceModifier = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piGlobalCommerceModifier);

	SAFE_DELETE_ARRAY(m_piSpecialistExtraCommerce);
	m_piSpecialistExtraCommerce = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);

	SAFE_DELETE_ARRAY(m_piStateReligionCommerce);
	m_piStateReligionCommerce = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piStateReligionCommerce);

	SAFE_DELETE_ARRAY(m_piCommerceHappiness);
	m_piCommerceHappiness = new int[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_piCommerceHappiness);

	SAFE_DELETE_ARRAY(m_piReligionChange);
	m_piReligionChange = new int[GC.getNumReligionInfos()];
	stream->Read(GC.getNumReligionInfos(), m_piReligionChange);

	SAFE_DELETE_ARRAY(m_piSpecialistCount);
	m_piSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piSpecialistCount);

	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	m_piFreeSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);

	SAFE_DELETE_ARRAY(m_piBonusHealthChanges);
	m_piBonusHealthChanges = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusHealthChanges);

	SAFE_DELETE_ARRAY(m_piBonusHappinessChanges);
	m_piBonusHappinessChanges = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusHappinessChanges);

	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	m_piBonusProductionModifier = new int[GC.getNumBonusInfos()];
	stream->Read(GC.getNumBonusInfos(), m_piBonusProductionModifier);

	SAFE_DELETE_ARRAY(m_piUnitCombatFreeExperience);
	m_piUnitCombatFreeExperience = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatFreeExperience);

	SAFE_DELETE_ARRAY(m_piDomainFreeExperience);
	m_piDomainFreeExperience = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainFreeExperience);

	SAFE_DELETE_ARRAY(m_piDomainProductionModifier);
	m_piDomainProductionModifier = new int[NUM_DOMAIN_TYPES];
	stream->Read(NUM_DOMAIN_TYPES, m_piDomainProductionModifier);

	SAFE_DELETE_ARRAY(m_piBuildingHappinessChanges);
	m_piBuildingHappinessChanges = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piBuildingHappinessChanges);

	SAFE_DELETE_ARRAY(m_piPrereqNumOfBuildingClass);
	m_piPrereqNumOfBuildingClass = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piPrereqNumOfBuildingClass);

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piImprovementFreeSpecialist);
	m_piImprovementFreeSpecialist = new int[GC.getNumImprovementInfos()];
	stream->Read(GC.getNumImprovementInfos(), m_piImprovementFreeSpecialist);

	SAFE_DELETE_ARRAY(m_pbCommerceFlexible);
	m_pbCommerceFlexible = new bool[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);

	SAFE_DELETE_ARRAY(m_pbCommerceChangeOriginalOwner);
	m_pbCommerceChangeOriginalOwner = new bool[NUM_COMMERCE_TYPES];
	stream->Read(NUM_COMMERCE_TYPES, m_pbCommerceChangeOriginalOwner);

	SAFE_DELETE_ARRAY(m_pbBuildingClassNeededInCity);
	m_pbBuildingClassNeededInCity = new bool[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_pbBuildingClassNeededInCity);

	int i;
	if (m_ppaiSpecialistYieldChange != NULL)
	{
		for(i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange);
	}

	m_ppaiSpecialistYieldChange = new int*[GC.getNumSpecialistInfos()];
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		m_ppaiSpecialistYieldChange[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppaiSpecialistYieldChange[i]);
	}

//FfH: Added by Kael 11/06/2007
	if (m_ppaiSpecialistCommerceChange != NULL)
	{
		for(i=0;i<GC.getNumSpecialistInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange);
	}
	m_ppaiSpecialistCommerceChange = new int*[GC.getNumSpecialistInfos()];
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		m_ppaiSpecialistCommerceChange[i]  = new int[NUM_COMMERCE_TYPES];
		stream->Read(NUM_COMMERCE_TYPES, m_ppaiSpecialistCommerceChange[i]);
	}
//FfH: End Add

	if (m_ppaiBonusYieldModifier != NULL)
	{
		for(i=0;i<GC.getNumBonusInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier[i]);
		}
		SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier);
	}

	m_ppaiBonusYieldModifier = new int*[GC.getNumBonusInfos()];
	for(i=0;i<GC.getNumBonusInfos();i++)
	{
		m_ppaiBonusYieldModifier[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppaiBonusYieldModifier[i]);
	}
}

//
// serialization
//
void CvBuildingInfo::write(FDataStreamBase* stream)
{
	CvHotkeyInfo::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iBuildingClassType);
	stream->Write(m_iVictoryPrereq);
	stream->Write(m_iFreeStartEra);
	stream->Write(m_iMaxStartEra);
	stream->Write(m_iObsoleteTech);
	stream->Write(m_iPrereqAndTech);
	stream->Write(m_iNoBonus);
	stream->Write(m_iPowerBonus);
	stream->Write(m_iFreeBonus);
	stream->Write(m_iNumFreeBonuses);
	stream->Write(m_iFreeBuildingClass);
	stream->Write(m_iFreePromotion);
	stream->Write(m_iCivicOption);
	stream->Write(m_iAIWeight);
	stream->Write(m_iProductionCost);
	stream->Write(m_iHurryCostModifier);
	stream->Write(m_iHurryAngerModifier);
	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);
	stream->Write(m_iMinAreaSize);
	stream->Write(m_iNumCitiesPrereq);
	stream->Write(m_iNumTeamsPrereq);
	stream->Write(m_iUnitLevelPrereq);
	stream->Write(m_iMinLatitude);
	stream->Write(m_iMaxLatitude);
	stream->Write(m_iGreatPeopleRateModifier);
	stream->Write(m_iGreatGeneralRateModifier);
	stream->Write(m_iDomesticGreatGeneralRateModifier);
	stream->Write(m_iGlobalGreatPeopleRateModifier);
	stream->Write(m_iAnarchyModifier);
	stream->Write(m_iGoldenAgeModifier);
	stream->Write(m_iGlobalHurryModifier);
	stream->Write(m_iFreeExperience);
	stream->Write(m_iGlobalFreeExperience);
	stream->Write(m_iFoodKept);
	stream->Write(m_iAirlift);
	stream->Write(m_iAirModifier);
	stream->Write(m_iAirUnitCapacity);
	stream->Write(m_iNukeModifier);
	stream->Write(m_iNukeExplosionRand);
	stream->Write(m_iFreeSpecialist);
	stream->Write(m_iAreaFreeSpecialist);
	stream->Write(m_iGlobalFreeSpecialist);
	stream->Write(m_iHappiness);
	stream->Write(m_iAreaHappiness);
	stream->Write(m_iGlobalHappiness);
	stream->Write(m_iStateReligionHappiness);
	stream->Write(m_iWorkerSpeedModifier);
	stream->Write(m_iMilitaryProductionModifier);
	stream->Write(m_iSpaceProductionModifier);
	stream->Write(m_iGlobalSpaceProductionModifier);
	stream->Write(m_iTradeRoutes);
	stream->Write(m_iCoastalTradeRoutes);
	stream->Write(m_iGlobalTradeRoutes);
	stream->Write(m_iTradeRouteModifier);
	stream->Write(m_iForeignTradeRouteModifier);
	stream->Write(m_iAssetValue);
	stream->Write(m_iPowerValue);
	stream->Write(m_iSpecialBuildingType);
	stream->Write(m_iAdvisorType);
	stream->Write(m_iHolyCity);
	stream->Write(m_iReligionType);
	stream->Write(m_iStateReligion);
	stream->Write(m_iPrereqReligion);
	stream->Write(m_iPrereqCorporation);
	stream->Write(m_iFoundsCorporation);
	stream->Write(m_iGlobalReligionCommerce);
	stream->Write(m_iGlobalCorporationCommerce);
	stream->Write(m_iPrereqAndBonus);
	stream->Write(m_iGreatPeopleUnitClass);
	stream->Write(m_iGreatPeopleRateChange);
	stream->Write(m_iConquestProbability);
	stream->Write(m_iMaintenanceModifier);
	stream->Write(m_iWarWearinessModifier);
	stream->Write(m_iGlobalWarWearinessModifier);
	stream->Write(m_iEnemyWarWearinessModifier);
	stream->Write(m_iHealRateChange);
	stream->Write(m_iHealth);
	stream->Write(m_iAreaHealth);
	stream->Write(m_iGlobalHealth);
	stream->Write(m_iGlobalPopulationChange);
	stream->Write(m_iFreeTechs);
	stream->Write(m_iDefenseModifier);
	stream->Write(m_iBombardDefenseModifier);
	stream->Write(m_iAllCityDefenseModifier);
	stream->Write(m_iEspionageDefenseModifier);
	stream->Write(m_iMissionType);
	stream->Write(m_iVoteSourceType);

	stream->Write(m_fVisibilityPriority);

	stream->Write(m_bTeamShare);
	stream->Write(m_bWater);
	stream->Write(m_bRiver);
	stream->Write(m_bPower);
	stream->Write(m_bDirtyPower);
	stream->Write(m_bAreaCleanPower);
	stream->Write(m_bAreaBorderObstacle);
	stream->Write(m_bForceTeamVoteEligible);
	stream->Write(m_bCapital);
	stream->Write(m_bGovernmentCenter);
	stream->Write(m_bGoldenAge);
	stream->Write(m_bMapCentering);
	stream->Write(m_bNoUnhappiness);
	stream->Write(m_bNoUnhealthyPopulation);
	stream->Write(m_bBuildingOnlyHealthy);
	stream->Write(m_bNeverCapture);
	stream->Write(m_bNukeImmune);
	stream->Write(m_bPrereqReligion);
	stream->Write(m_bCenterInCity);
	stream->Write(m_bStateReligion);
	stream->Write(m_bAllowsNukes);

	stream->WriteString(m_szConstructSound);
	stream->WriteString(m_szArtDefineTag);
	stream->WriteString(m_szMovieDefineTag);

//FfH Buildings: Added by Kael 08/04/2007
	stream->Write(m_bApplyFreePromotionOnMove);
	stream->Write(m_bEquipment);
	stream->Write(m_bHideUnits);
	stream->Write(m_bNoCivicAnger);
	stream->Write(m_bRequiresCaster);
	stream->Write(m_bSeeInvisible);
	stream->Write(m_bUnhappyProduction);
	stream->Write(m_iCrime);
	stream->Write(m_iFreePromotionPick);
	stream->Write(m_iFreeBonus2);
	stream->Write(m_iFreeBonus3);
	stream->Write(m_iGlobalResistEnemyModify);
	stream->Write(m_iGlobalResistModify);
	stream->Write(m_iModifyGlobalCounter);
	stream->Write(m_iPlotRadius);
	stream->Write(m_iPrereqCiv);
	stream->Write(m_iPrereqTrait);
	stream->Write(m_iRemovePromotion);
	stream->Write(m_iResistMagic);
//FfH: End Add
/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
	stream->Write(m_bVictoryBuilding);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Buildings can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	stream->Write(m_iRequiredGameOption);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Gameoption (Passive XP Training) Sephi                                           				    **/
/*************************************************************************************************/
	stream->Write(GC.getNumUnitCombatInfos(), m_paiTrainXPCap);
	stream->Write(GC.getNumUnitCombatInfos(), m_paiTrainXPRate);
	stream->Write(GC.getNumUnitCombatInfos(), m_paiGlobalTrainXPCap);
	stream->Write(GC.getNumUnitCombatInfos(), m_paiGlobalTrainXPRate);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	stream->Write(m_iCorporationSupportNeeded);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupport);
	stream->Write(GC.getNumCorporationInfos(), m_paiCorporationSupportMod);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	stream->Write(GC.getNUM_BUILDING_AND_TECH_PREREQS(), m_piPrereqAndTechs);
	stream->Write(GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), m_piPrereqOrBonuses);
	stream->Write(GC.getNumTraitInfos(), m_piProductionTraits);
	stream->Write(GC.getNumTraitInfos(), m_piHappinessTraits);
	stream->Write(NUM_YIELD_TYPES, m_piSeaPlotYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piRiverPlotYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piGlobalSeaPlotYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piPowerYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piAreaYieldModifier);
	stream->Write(NUM_YIELD_TYPES, m_piGlobalYieldModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceChange);
	stream->Write(NUM_COMMERCE_TYPES, m_piObsoleteSafeCommerceChange);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceChangeDoubleTime);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piGlobalCommerceModifier);
	stream->Write(NUM_COMMERCE_TYPES, m_piSpecialistExtraCommerce);
	stream->Write(NUM_COMMERCE_TYPES, m_piStateReligionCommerce);
	stream->Write(NUM_COMMERCE_TYPES, m_piCommerceHappiness);
	stream->Write(GC.getNumReligionInfos(), m_piReligionChange);
	stream->Write(GC.getNumSpecialistInfos(), m_piSpecialistCount);
	stream->Write(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);
	stream->Write(GC.getNumBonusInfos(), m_piBonusHealthChanges);
	stream->Write(GC.getNumBonusInfos(), m_piBonusHappinessChanges);
	stream->Write(GC.getNumBonusInfos(), m_piBonusProductionModifier);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatFreeExperience);
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainFreeExperience);
	stream->Write(NUM_DOMAIN_TYPES, m_piDomainProductionModifier);
	stream->Write(GC.getNumBuildingClassInfos(), m_piBuildingHappinessChanges);
	stream->Write(GC.getNumBuildingClassInfos(), m_piPrereqNumOfBuildingClass);
	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(GC.getNumImprovementInfos(), m_piImprovementFreeSpecialist);

	stream->Write(NUM_COMMERCE_TYPES, m_pbCommerceFlexible);
	stream->Write(NUM_COMMERCE_TYPES, m_pbCommerceChangeOriginalOwner);
	stream->Write(GC.getNumBuildingClassInfos(), m_pbBuildingClassNeededInCity);

	int i;
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppaiSpecialistYieldChange[i]);
	}

//FfH: Added by Kael 11/06/2007
	for(i=0;i<GC.getNumSpecialistInfos();i++)
	{
		stream->Write(NUM_COMMERCE_TYPES, m_ppaiSpecialistCommerceChange[i]);
	}
//FfH: End Add

	for(i=0;i<GC.getNumBonusInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppaiBonusYieldModifier[i]);
	}
}

//
// read from XML
//
bool CvBuildingInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	int j=0;						//loop counter
	int k=0;						//loop counter
	int iNumSibs=0;				// the number of siblings the current xml node has
	int iNumChildren;				// the number of children the current node has
	int iIndex;

	pXML->GetChildXmlValByName(szTextVal, "BuildingClass");
	m_iBuildingClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SpecialBuildingType");
	m_iSpecialBuildingType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Advisor");
	m_iAdvisorType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**			Default value needed for proper comparison later on in CopyNonDefaults				**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "MovieDefineTag");
	setMovieDefineTag(szTextVal);
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(szTextVal, "MovieDefineTag", "NONE");
	setMovieDefineTag(szTextVal);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "HolyCity");
	m_iHolyCity = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ReligionType");
	m_iReligionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StateReligion");
	m_iStateReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqCorporation");
	m_iPrereqCorporation = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FoundsCorporation");
	m_iFoundsCorporation = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GlobalReligionCommerce");
	m_iGlobalReligionCommerce = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GlobalCorporationCommerce");
	m_iGlobalCorporationCommerce = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "VictoryPrereq");
	m_iVictoryPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeStartEra");
	m_iFreeStartEra = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MaxStartEra");
	m_iMaxStartEra = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ObsoleteTech");
	m_iObsoleteTech = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iPrereqAndTech = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechTypes"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_BUILDING_AND_TECH_PREREQS(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_BUILDING_AND_TECH_PREREQS()),"For loop iterator is greater than array size");
					for (j=0;j<iNumSibs;j++)
					{
						m_piPrereqAndTechs[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqAndTechs, GC.getNUM_BUILDING_AND_TECH_PREREQS(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "Bonus");
	m_iPrereqAndBonus = pXML->FindInInfoClass(szTextVal);

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonuses"))
	{
		// the next xml val in the buildinginfo tag set is the bonuses tag set
		// Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// get the total number of children the current xml node has
			iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), -1);

			if (0 < iNumChildren)
			{
				// if the call to the function that sets the current xml node to it's first non-comment
				// child and sets the parameter with the new node's value succeeds
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumChildren <= GC.getNUM_BUILDING_PREREQ_OR_BONUSES()),"For loop iterator is greater than array size");
					// loop through all the siblings
					for (j=0;j<iNumChildren;j++)
					{
						// call the find in list function to return either -1 if no value is found
						// or the index in the list the match is found at
						m_piPrereqOrBonuses[j] = pXML->FindInInfoClass(szTextVal);

						// if the call to the function that sets the current xml node to it's first non-comment
						// sibling and sets the parameter with the new node's value does not succeed
						// we will break out of this for loop
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					// set the current xml node to it's parent node
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_BUILDING_PREREQ_OR_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	pXML->SetVariableListTagPair(&m_piHappinessTraits, "HappinessTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	pXML->GetChildXmlValByName(szTextVal, "NoBonus");
	m_iNoBonus = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PowerBonus");
	m_iPowerBonus = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeBonus");
	m_iFreeBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iNumFreeBonuses, "iNumFreeBonuses");

	pXML->GetChildXmlValByName(szTextVal, "FreeBuilding");
	m_iFreeBuildingClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreePromotion");
	m_iFreePromotion = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "CivicOption");
	m_iCivicOption = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GreatPeopleUnitClass");
	m_iGreatPeopleUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DiploVoteType");
	m_iVoteSourceType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iGreatPeopleRateChange, "iGreatPeopleRateChange");
	pXML->GetChildXmlValByName(&m_bTeamShare, "bTeamShare",true);   //default value added Sephi
	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(&m_bRiver, "bRiver");
	pXML->GetChildXmlValByName(&m_bPower, "bPower");
	pXML->GetChildXmlValByName(&m_bDirtyPower, "bDirtyPower");
	pXML->GetChildXmlValByName(&m_bAreaCleanPower, "bAreaCleanPower");
	pXML->GetChildXmlValByName(&m_bAreaBorderObstacle, "bBorderObstacle");
	pXML->GetChildXmlValByName(&m_bForceTeamVoteEligible, "bForceTeamVoteEligible");
	pXML->GetChildXmlValByName(&m_bCapital, "bCapital");
	pXML->GetChildXmlValByName(&m_bGovernmentCenter, "bGovernmentCenter");
	pXML->GetChildXmlValByName(&m_bGoldenAge, "bGoldenAge");
	pXML->GetChildXmlValByName(&m_bAllowsNukes, "bAllowsNukes");
	pXML->GetChildXmlValByName(&m_bMapCentering, "bMapCentering");
	pXML->GetChildXmlValByName(&m_bNoUnhappiness, "bNoUnhappiness");
	pXML->GetChildXmlValByName(&m_bNoUnhealthyPopulation, "bNoUnhealthyPopulation");
	pXML->GetChildXmlValByName(&m_bBuildingOnlyHealthy, "bBuildingOnlyHealthy");
	pXML->GetChildXmlValByName(&m_bNeverCapture, "bNeverCapture");
	pXML->GetChildXmlValByName(&m_bNukeImmune, "bNukeImmune");
	pXML->GetChildXmlValByName(&m_bPrereqReligion, "bPrereqReligion");
	pXML->GetChildXmlValByName(&m_bCenterInCity, "bCenterInCity");
	pXML->GetChildXmlValByName(&m_bStateReligion, "bStateReligion");
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight");
	pXML->GetChildXmlValByName(&m_iProductionCost, "iCost");
	pXML->GetChildXmlValByName(&m_iHurryCostModifier, "iHurryCostModifier");
	pXML->GetChildXmlValByName(&m_iHurryAngerModifier, "iHurryAngerModifier");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost", 100);
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");
	pXML->GetChildXmlValByName(&m_iMinAreaSize, "iMinAreaSize", -1);
	pXML->GetChildXmlValByName(&m_iConquestProbability, "iConquestProb");
	pXML->GetChildXmlValByName(&m_iNumCitiesPrereq, "iCitiesPrereq");
	pXML->GetChildXmlValByName(&m_iNumTeamsPrereq, "iTeamsPrereq");
	pXML->GetChildXmlValByName(&m_iUnitLevelPrereq, "iLevelPrereq");
	pXML->GetChildXmlValByName(&m_iMinLatitude, "iMinLatitude");
	pXML->GetChildXmlValByName(&m_iMaxLatitude, "iMaxLatitude", 90);
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iGreatGeneralRateModifier, "iGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iDomesticGreatGeneralRateModifier, "iDomesticGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iGlobalGreatPeopleRateModifier, "iGlobalGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iAnarchyModifier, "iAnarchyModifier");
	pXML->GetChildXmlValByName(&m_iGoldenAgeModifier, "iGoldenAgeModifier");
	pXML->GetChildXmlValByName(&m_iGlobalHurryModifier, "iGlobalHurryModifier");
	pXML->GetChildXmlValByName(&m_iFreeExperience, "iExperience");
	pXML->GetChildXmlValByName(&m_iGlobalFreeExperience, "iGlobalExperience");
	pXML->GetChildXmlValByName(&m_iFoodKept, "iFoodKept");
	pXML->GetChildXmlValByName(&m_iAirlift, "iAirlift");
	pXML->GetChildXmlValByName(&m_iAirModifier, "iAirModifier");
	pXML->GetChildXmlValByName(&m_iAirUnitCapacity, "iAirUnitCapacity");
	pXML->GetChildXmlValByName(&m_iNukeModifier, "iNukeModifier");
	pXML->GetChildXmlValByName(&m_iNukeExplosionRand, "iNukeExplosionRand");
	pXML->GetChildXmlValByName(&m_iFreeSpecialist, "iFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iAreaFreeSpecialist, "iAreaFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iGlobalFreeSpecialist, "iGlobalFreeSpecialist");
	pXML->GetChildXmlValByName(&m_iMaintenanceModifier, "iMaintenanceModifier");
//	pXML->GetChildXmlValByName(&m_iWarWearinessModifier, "iWarWearinessModifier"); No WarWeariness
//	pXML->GetChildXmlValByName(&m_iGlobalWarWearinessModifier, "iGlobalWarWearinessModifier");
//	pXML->GetChildXmlValByName(&m_iEnemyWarWearinessModifier, "iEnemyWarWearinessModifier");
	pXML->GetChildXmlValByName(&m_iHealRateChange, "iHealRateChange");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iAreaHealth, "iAreaHealth");
	pXML->GetChildXmlValByName(&m_iGlobalHealth, "iGlobalHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iAreaHappiness, "iAreaHappiness");
	pXML->GetChildXmlValByName(&m_iGlobalHappiness, "iGlobalHappiness");
	pXML->GetChildXmlValByName(&m_iStateReligionHappiness, "iStateReligionHappiness");
	pXML->GetChildXmlValByName(&m_iWorkerSpeedModifier, "iWorkerSpeedModifier");
	pXML->GetChildXmlValByName(&m_iMilitaryProductionModifier, "iMilitaryProductionModifier");
	pXML->GetChildXmlValByName(&m_iSpaceProductionModifier, "iSpaceProductionModifier");
	pXML->GetChildXmlValByName(&m_iGlobalSpaceProductionModifier, "iGlobalSpaceProductionModifier");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_iCoastalTradeRoutes, "iCoastalTradeRoutes");
	pXML->GetChildXmlValByName(&m_iGlobalTradeRoutes, "iGlobalTradeRoutes");
	pXML->GetChildXmlValByName(&m_iTradeRouteModifier, "iTradeRouteModifier");
	pXML->GetChildXmlValByName(&m_iForeignTradeRouteModifier, "iForeignTradeRouteModifier");
	pXML->GetChildXmlValByName(&m_iGlobalPopulationChange, "iGlobalPopulationChange");
	pXML->GetChildXmlValByName(&m_iFreeTechs, "iFreeTechs");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefense");
	pXML->GetChildXmlValByName(&m_iBombardDefenseModifier, "iBombardDefense");
	pXML->GetChildXmlValByName(&m_iAllCityDefenseModifier, "iAllCityDefense");
	pXML->GetChildXmlValByName(&m_iEspionageDefenseModifier, "iEspionageDefense");
	pXML->GetChildXmlValByName(&m_iAssetValue, "iAsset");
	pXML->GetChildXmlValByName(&m_iPowerValue, "iPower");
	pXML->GetChildXmlValByName(&m_fVisibilityPriority, "fVisibilityPriority");

//FfH: Buildings: Added by Kael 08/04/2007
	pXML->GetChildXmlValByName(&m_bApplyFreePromotionOnMove, "bApplyFreePromotionOnMove");
	pXML->GetChildXmlValByName(&m_bEquipment, "bEquipment");
	pXML->GetChildXmlValByName(&m_bHideUnits, "bHideUnits");
	pXML->GetChildXmlValByName(&m_bNoCivicAnger, "bNoCivicAnger");
	pXML->GetChildXmlValByName(&m_bRequiresCaster, "bRequiresCaster");
	pXML->GetChildXmlValByName(&m_bSeeInvisible, "bSeeInvisible");
	pXML->GetChildXmlValByName(&m_bUnhappyProduction, "bUnhappyProduction");
	pXML->GetChildXmlValByName(&m_iCrime, "iCrime");
	pXML->GetChildXmlValByName(&m_iFreePromotionPick, "iFreePromotionPick");
	pXML->GetChildXmlValByName(szTextVal, "FreeBonus2");
	m_iFreeBonus2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FreeBonus3");
	m_iFreeBonus3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iGlobalResistEnemyModify, "iGlobalResistEnemyModify");
	pXML->GetChildXmlValByName(&m_iGlobalResistModify, "iGlobalResistModify");
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter, "iModifyGlobalCounter");
	pXML->GetChildXmlValByName(&m_iPlotRadius, "iPlotRadius");
	pXML->GetChildXmlValByName(szTextVal, "PrereqCiv");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqTrait");
	m_iPrereqTrait = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RemovePromotion");
	m_iRemovePromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iResistMagic, "iResistMagic");
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iMistDensity, "iMistDensity");
	pXML->GetChildXmlValByName(&m_iManaFromImprovement, "iManaFromImprovement");
	pXML->GetChildXmlValByName(szTextVal, "ManaFromImprovementType");
	m_iManaFromImprovementType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iTaxesModifier, "iTaxesModifier");
	pXML->GetChildXmlValByName(&m_iBuildingMaintenance, "iBuildingMaintenance");
	pXML->GetChildXmlValByName(&m_iGPPThresholdReductionPercent, "iGPPThresholdReductionPercent");
	pXML->GetChildXmlValByName(&m_iMaxManaChange, "iMaxManaChange");
//	pXML->GetChildXmlValByName(szTextVal, "ReducedCostByYieldOverwrite"); disable
//	m_iReducedCostByYieldOverwrite = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iPopulationCost, "iPopulationCost");
	pXML->GetChildXmlValByName(szTextVal, "GlobalYieldTypeCost");
	m_iGlobalYieldTypeCost = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iGlobalYieldCost, "iGlobalYieldCost");
	pXML->GetChildXmlValByName(&m_iUnitSupportChange, "iUnitSupportChange");	
	pXML->GetChildXmlValByName(&m_iLastTurnPossibleBuild, "iLastTurnPossibleBuild");	
	pXML->GetChildXmlValByName(szTextVal, "CommercePercentTypeForced");
	m_iCommercePercentTypeForced = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iPopulationLimitChange, "iPopulationLimitChange");
	pXML->GetChildXmlValByName(&m_bAdjacentPeak, "bAdjacentPeak");
	pXML->GetChildXmlValByName(&m_bAdjacentUF, "bAdjacentUF");
	pXML->GetChildXmlValByName(&m_bDistrict, "bDistrict");
	pXML->GetChildXmlValByName(&m_bEnchantment, "bEnchantment");
	pXML->GetChildXmlValByName(szTextVal, "BuildingClassPrereq");
	m_iPrereqBuildingClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqBuildingClassInAllCities");
	m_iPrereqBuildingClassInAllCities = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqImprovement");
	m_iPrereqImprovement = pXML->FindInInfoClass(szTextVal);
	pXML->SetVariableListTagPair(&m_paiCommercePerPopulation, "CommercePerPopulationChanges", sizeof(GC.getCommerceInfo((CommerceTypes)0)), GC.getNUM_COMMERCE_TYPES());
	pXML->SetVariableListTagPair(&m_paiCommercePerCultureLevel, "CommercePerCultureLevelChanges", sizeof(GC.getCommerceInfo((CommerceTypes)0)), GC.getNUM_COMMERCE_TYPES());
	pXML->SetVariableListTagPair(&m_paiYieldPerCultureLevel, "YieldPerCultureLevelChanges", sizeof(GC.getYieldInfo((YieldTypes)0)), GC.getNUM_YIELD_TYPES());
	pXML->GetChildXmlValByName(szTextVal, "BonusCommerceType");
	m_iBonusCommerceType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BonusYieldType");
	m_iBonusYieldType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AISpecialization1");
	m_iAISpecialization1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AISpecialization2");
	m_iAISpecialization2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iInitialValue, "iInitialValue");
	pXML->GetChildXmlValByName(&m_iPerBonusValue, "iPerBonusValue");
	pXML->SetVariableListTagPair(&m_pabBonusLinked, "BonusesLinked", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_pabBonusConsumed, "BonusesConsumed", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_pabBonusNearbyNeeded, "BonusesNearbyNeeded", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_pabBuildingClassBlocked, "BuildingClassesBlocked", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivic");
	m_aszExtraXML1forPass3.push_back(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bVictoryBuilding, "bVictoryBuilding",false);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Buildings can be unlocked by Gameoptions) Sephi                     					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "RequiredGameOption","NONE");
	m_iRequiredGameOption = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	New Gameoption (Passive XP Training) Sephi                                           				    **/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_paiTrainXPCap, "TrainXPCaps", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_paiTrainXPRate, "TrainXPRates", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_paiGlobalTrainXPCap, "GlobalTrainXPCaps", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
	pXML->SetVariableListTagPair(&m_paiGlobalTrainXPRate, "GlobalTrainXPRates", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "iCorporationSupportNeeded","NONE");
	m_iCorporationSupportNeeded = pXML->FindInInfoClass(szTextVal);
	pXML->SetVariableListTagPair(&m_paiCorporationSupport, "CorporationSupportValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
	pXML->SetVariableListTagPair(&m_paiCorporationSupportMod, "CorporationSupportModifierValues", sizeof(GC.getCorporationInfo((CorporationTypes)0)), GC.getNumCorporationInfos());
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SeaPlotYieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piSeaPlotYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piSeaPlotYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverPlotYieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piRiverPlotYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverPlotYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalSeaPlotYieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piGlobalSeaPlotYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piGlobalSeaPlotYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldModifier, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PowerYieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piPowerYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piPowerYieldModifier, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AreaYieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piAreaYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piAreaYieldModifier, NUM_YIELD_TYPES);
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalYieldModifiers"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piGlobalYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piGlobalYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChanges"))
	{
		pXML->SetCommerce(&m_piCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceChange, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ObsoleteSafeCommerceChanges"))
	{
		pXML->SetCommerce(&m_piObsoleteSafeCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piObsoleteSafeCommerceChange, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChangeDoubleTimes"))
	{
		pXML->SetCommerce(&m_piCommerceChangeDoubleTime);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceChangeDoubleTime, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalCommerceModifiers"))
	{
		pXML->SetCommerce(&m_piGlobalCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piGlobalCommerceModifier, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistExtraCommerces"))
	{
		pXML->SetCommerce(&m_piSpecialistExtraCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piSpecialistExtraCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"StateReligionCommerces"))
	{
		pXML->SetCommerce(&m_piStateReligionCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piStateReligionCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceHappinesses"))
	{
		pXML->SetCommerce(&m_piCommerceHappiness);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceHappiness, NUM_COMMERCE_TYPES);
	}

	pXML->SetVariableListTagPair(&m_piReligionChange, "ReligionChanges", sizeof(GC.getReligionInfo((ReligionTypes)0)), GC.getNumReligionInfos());

	pXML->SetVariableListTagPair(&m_piSpecialistCount, "SpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());
	pXML->SetVariableListTagPair(&m_piFreeSpecialistCount, "FreeSpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceFlexibles"))
	{
		pXML->SetCommerce(&m_pbCommerceFlexible);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_pbCommerceFlexible, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChangeOriginalOwners"))
	{
		pXML->SetCommerce(&m_pbCommerceChangeOriginalOwner);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_pbCommerceChangeOriginalOwner, NUM_COMMERCE_TYPES);
	}

	pXML->GetChildXmlValByName(szTextVal, "ConstructSound");
	setConstructSound(szTextVal);

	pXML->SetVariableListTagPair(&m_piBonusHealthChanges, "BonusHealthChanges", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piBonusHappinessChanges, "BonusHappinessChanges", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piBonusProductionModifier, "BonusProductionModifiers", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());

	pXML->SetVariableListTagPair(&m_piUnitCombatFreeExperience, "UnitCombatFreeExperiences", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());

	pXML->SetVariableListTagPair(&m_piDomainFreeExperience, "DomainFreeExperiences", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);
	pXML->SetVariableListTagPair(&m_piDomainProductionModifier, "DomainProductionModifiers", sizeof(GC.getDomainInfo((DomainTypes)0)), NUM_DOMAIN_TYPES);

	pXML->SetVariableListTagPair(&m_piPrereqNumOfBuildingClass, "PrereqBuildingClasses", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());
	pXML->SetVariableListTagPair(&m_pbBuildingClassNeededInCity, "BuildingClassNeededs", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

	pXML->Init2DIntList(&m_ppaiSpecialistYieldChange, GC.getNumSpecialistInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistYieldChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistYieldChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_ppaiSpecialistYieldChange[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
					{
						// call the function that sets the yield change variable
						pXML->SetYields(&m_ppaiSpecialistYieldChange[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_ppaiSpecialistYieldChange[k], NUM_YIELD_TYPES);
					}
				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->Init2DIntList(&m_ppaiBonusYieldModifier, GC.getNumBonusInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusYieldModifiers"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusYieldModifier"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "BonusType");
				k = pXML->FindInInfoClass(szTextVal);
				if (k > -1)
				{
					// delete the array since it will be reallocated
					SAFE_DELETE_ARRAY(m_ppaiBonusYieldModifier[k]);
					if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
					{
						// call the function that sets the yield change variable
						pXML->SetYields(&m_ppaiBonusYieldModifier[k]);
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}
					else
					{
						pXML->InitList(&m_ppaiBonusYieldModifier[k], NUM_YIELD_TYPES);
					}

				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			// set the current xml node to it's parent node
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());
	pXML->SetVariableListTagPair(&m_piImprovementFreeSpecialist, "ImprovementFreeSpecialists", sizeof(GC.getImprovementInfo((ImprovementTypes)0)), GC.getNumImprovementInfos());

	pXML->SetVariableListTagPair(&m_piBuildingHappinessChanges, "BuildingHappinessChanges", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

//FfH: Added by Kael 11/06/2007
	pXML->Init2DIntList(&m_ppaiSpecialistCommerceChange, GC.getNumSpecialistInfos(), NUM_COMMERCE_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistCommerceChanges"))
	{
		iNumChildren = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"SpecialistCommerceChange"))
		{
			for(j=0;j<iNumChildren;j++)
			{
				pXML->GetChildXmlValByName(szTextVal, "SpecialistType");
				k = pXML->FindInInfoClass(szTextVal);
				SAFE_DELETE_ARRAY(m_ppaiSpecialistCommerceChange[k]);
				if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceChanges") && (k > -1))
				{
					pXML->SetCommerce(&m_ppaiSpecialistCommerceChange[k]);
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
				else
				{
					pXML->InitList(&m_ppaiSpecialistCommerceChange[k], NUM_COMMERCE_TYPES);
				}
				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
//FfH: End Add

	// initialize the boolean list to the correct size and all the booleans to false
	FAssertMsg((GC.getNumImprovementInfos() > 0) && (NUM_YIELD_TYPES) > 0,"either the number of tech infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiImprovementYieldChanges, GC.getNumImprovementInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiImprovementYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiImprovementYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiImprovementYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(BuildingInfos)			05/15/08											**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBuildingInfo::copyNonDefaults(CvBuildingInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()						== cDefault)			setArtDefineTag(					pClassInfo->getArtDefineTag());
	if (getMovieDefineTag()						== cDefault)			setMovieDefineTag(					pClassInfo->getMovieDefineTag());
	//Art Define Tags must be done before InfoBase/Hotkey info to get the right buttons
	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isTeamShare()							== true)				m_bTeamShare						= pClassInfo->isTeamShare();
	if (isWater()								== false)				m_bWater							= pClassInfo->isWater();
	if (isRiver()								== false)				m_bRiver							= pClassInfo->isRiver();
	if (isPower()								== false)				m_bPower							= pClassInfo->isPower();
	if (isDirtyPower()							== false)				m_bDirtyPower						= pClassInfo->isDirtyPower();
	if (isAreaCleanPower()						== false)				m_bAreaCleanPower					= pClassInfo->isAreaCleanPower();
	if (isAreaBorderObstacle()					== false)				m_bAreaBorderObstacle				= pClassInfo->isAreaBorderObstacle();
	if (isForceTeamVoteEligible()				== false)				m_bForceTeamVoteEligible			= pClassInfo->isForceTeamVoteEligible();
	if (isCapital()								== false)				m_bCapital							= pClassInfo->isCapital();
	if (isGovernmentCenter()					== false)				m_bGovernmentCenter					= pClassInfo->isGovernmentCenter();
	if (isGoldenAge ()							== false)				m_bGoldenAge						= pClassInfo->isGoldenAge ();
	if (isAllowsNukes()							== false)				m_bAllowsNukes						= pClassInfo->isAllowsNukes();
	if (isMapCentering()						== false)				m_bMapCentering						= pClassInfo->isMapCentering();
	if (isNoUnhappiness()						== false)				m_bNoUnhappiness					= pClassInfo->isNoUnhappiness();
	if (isNoUnhealthyPopulation()				== false)				m_bNoUnhealthyPopulation			= pClassInfo->isNoUnhealthyPopulation();
	if (isBuildingOnlyHealthy()					== false)				m_bBuildingOnlyHealthy				= pClassInfo->isBuildingOnlyHealthy();
	if (isNeverCapture()						== false)				m_bNeverCapture						= pClassInfo->isNeverCapture();
	if (isNukeImmune()							== false)				m_bNukeImmune						= pClassInfo->isNukeImmune();
	if (isPrereqReligion()						== false)				m_bPrereqReligion					= pClassInfo->isPrereqReligion();
	if (isCenterInCity()						== false)				m_bCenterInCity						= pClassInfo->isCenterInCity();
	if (isStateReligion()						== false)				m_bStateReligion					= pClassInfo->isStateReligion();
	if (isApplyFreePromotionOnMove()			== false)				m_bApplyFreePromotionOnMove			= pClassInfo->isApplyFreePromotionOnMove();
	if (isEquipment()							== false)				m_bEquipment						= pClassInfo->isEquipment();
	if (isHideUnits()							== false)				m_bHideUnits						= pClassInfo->isHideUnits();
	if (isNoCivicAnger()						== false)				m_bNoCivicAnger						= pClassInfo->isNoCivicAnger();
	if (isSeeInvisible()						== false)				m_bSeeInvisible						= pClassInfo->isSeeInvisible();
	if (isUnhappyProduction()					== false)				m_bUnhappyProduction				= pClassInfo->isUnhappyProduction();
	if (getNumFreeBonuses()						== 0)					m_iNumFreeBonuses					= pClassInfo->getNumFreeBonuses();
	if (getCrime()								== 0)					m_iCrime							= pClassInfo->getCrime();
	if (getFreePromotionPick()					== 0)					m_iFreePromotionPick				= pClassInfo->getFreePromotionPick();
	if (getGlobalResistEnemyModify()			== 0)					m_iGlobalResistEnemyModify			= pClassInfo->getGlobalResistEnemyModify();
	if (getGlobalResistModify()					== 0)					m_iGlobalResistModify				= pClassInfo->getGlobalResistModify();
	if (getModifyGlobalCounter()				== 0)					m_iModifyGlobalCounter				= pClassInfo->getModifyGlobalCounter();
	if (getPlotRadius()							== 0)					m_iPlotRadius						= pClassInfo->getPlotRadius();
	if (getResistMagic()						== 0)					m_iResistMagic						= pClassInfo->getResistMagic();
	if (getGreatPeopleRateChange()				== 0)					m_iGreatPeopleRateChange			= pClassInfo->getGreatPeopleRateChange();
	if (getAIWeight()							== 0)					m_iAIWeight							= pClassInfo->getAIWeight();
	if (getProductionCost()						== 0)					m_iProductionCost					= pClassInfo->getProductionCost();
	if (getHurryCostModifier()					== 0)					m_iHurryCostModifier				= pClassInfo->getHurryCostModifier();
	if (getHurryAngerModifier()					== 0)					m_iHurryAngerModifier				= pClassInfo->getHurryAngerModifier();
	if (getAdvancedStartCost()					== 0)					m_iAdvancedStartCost				= pClassInfo->getAdvancedStartCost();
	if (getAdvancedStartCostIncrease()			== 0)					m_iAdvancedStartCostIncrease		= pClassInfo->getAdvancedStartCostIncrease();
	if (getMinAreaSize()						== 0)					m_iMinAreaSize						= pClassInfo->getMinAreaSize();
	if (getConquestProbability()				== 0)					m_iConquestProbability				= pClassInfo->getConquestProbability();
	if (getNumCitiesPrereq()					== 0)					m_iNumCitiesPrereq					= pClassInfo->getNumCitiesPrereq();
	if (getNumTeamsPrereq()						== 0)					m_iNumTeamsPrereq					= pClassInfo->getNumTeamsPrereq();
	if (getUnitLevelPrereq()					== 0)					m_iUnitLevelPrereq					= pClassInfo->getUnitLevelPrereq();
	if (getMinLatitude()						== 0)					m_iMinLatitude						= pClassInfo->getMinLatitude();
	if (getGreatPeopleRateModifier()			== 0)					m_iGreatPeopleRateModifier			= pClassInfo->getGreatPeopleRateModifier();
	if (getGreatGeneralRateModifier()			== 0)					m_iGreatGeneralRateModifier			= pClassInfo->getGreatGeneralRateModifier();
	if (getDomesticGreatGeneralRateModifier()	== 0)					m_iDomesticGreatGeneralRateModifier	= pClassInfo->getDomesticGreatGeneralRateModifier();
	if (getGlobalGreatPeopleRateModifier()		== 0)					m_iGlobalGreatPeopleRateModifier	= pClassInfo->getGlobalGreatPeopleRateModifier();
	if (getAnarchyModifier()					== 0)					m_iAnarchyModifier					= pClassInfo->getAnarchyModifier();
	if (getGoldenAgeModifier()					== 0)					m_iGoldenAgeModifier				= pClassInfo->getGoldenAgeModifier();
	if (getGlobalHurryModifier()				== 0)					m_iGlobalHurryModifier				= pClassInfo->getGlobalHurryModifier();
	if (getFreeExperience()						== 0)					m_iFreeExperience					= pClassInfo->getFreeExperience();
	if (getGlobalFreeExperience()				== 0)					m_iGlobalFreeExperience				= pClassInfo->getGlobalFreeExperience();
	if (getFoodKept()							== 0)					m_iFoodKept							= pClassInfo->getFoodKept();
	if (getAirlift()							== 0)					m_iAirlift							= pClassInfo->getAirlift();
	if (getAirModifier()						== 0)					m_iAirModifier						= pClassInfo->getAirModifier();
	if (getAirUnitCapacity()					== 0)					m_iAirUnitCapacity					= pClassInfo->getAirUnitCapacity();
	if (getNukeModifier()						== 0)					m_iNukeModifier						= pClassInfo->getNukeModifier();
	if (getNukeExplosionRand()					== 0)					m_iNukeExplosionRand				= pClassInfo->getNukeExplosionRand();
	if (getFreeSpecialist()						== 0)					m_iFreeSpecialist					= pClassInfo->getFreeSpecialist();
	if (getAreaFreeSpecialist()					== 0)					m_iAreaFreeSpecialist				= pClassInfo->getAreaFreeSpecialist();
	if (getGlobalFreeSpecialist()				== 0)					m_iGlobalFreeSpecialist				= pClassInfo->getGlobalFreeSpecialist();
	if (getMaintenanceModifier()				== 0)					m_iMaintenanceModifier				= pClassInfo->getMaintenanceModifier();
	if (getWarWearinessModifier()				== 0)					m_iWarWearinessModifier				= pClassInfo->getWarWearinessModifier();
	if (getGlobalWarWearinessModifier()			== 0)					m_iGlobalWarWearinessModifier		= pClassInfo->getGlobalWarWearinessModifier();
	if (getEnemyWarWearinessModifier()			== 0)					m_iEnemyWarWearinessModifier		= pClassInfo->getEnemyWarWearinessModifier();
	if (getHealRateChange()						== 0)					m_iHealRateChange					= pClassInfo->getHealRateChange();
	if (getHealth()								== 0)					m_iHealth							= pClassInfo->getHealth();
	if (getAreaHealth()							== 0)					m_iAreaHealth						= pClassInfo->getAreaHealth();
	if (getGlobalHealth()						== 0)					m_iGlobalHealth						= pClassInfo->getGlobalHealth();
	if (getHappiness()							== 0)					m_iHappiness						= pClassInfo->getHappiness();
	if (getAreaHappiness()						== 0)					m_iAreaHappiness					= pClassInfo->getAreaHappiness();
	if (getGlobalHappiness()					== 0)					m_iGlobalHappiness					= pClassInfo->getGlobalHappiness();
	if (getStateReligionHappiness()				== 0)					m_iStateReligionHappiness			= pClassInfo->getStateReligionHappiness();
	if (getWorkerSpeedModifier()				== 0)					m_iWorkerSpeedModifier				= pClassInfo->getWorkerSpeedModifier();
	if (getMilitaryProductionModifier()			== 0)					m_iMilitaryProductionModifier		= pClassInfo->getMilitaryProductionModifier();
	if (getSpaceProductionModifier()			== 0)					m_iSpaceProductionModifier			= pClassInfo->getSpaceProductionModifier();
	if (getGlobalSpaceProductionModifier()		== 0)					m_iGlobalSpaceProductionModifier	= pClassInfo->getGlobalSpaceProductionModifier();
	if (getTradeRoutes()						== 0)					m_iTradeRoutes						= pClassInfo->getTradeRoutes();
	if (getCoastalTradeRoutes()					== 0)					m_iCoastalTradeRoutes				= pClassInfo->getCoastalTradeRoutes();
	if (getGlobalTradeRoutes()					== 0)					m_iGlobalTradeRoutes				= pClassInfo->getGlobalTradeRoutes();
	if (getTradeRouteModifier()					== 0)					m_iTradeRouteModifier				= pClassInfo->getTradeRouteModifier();
	if (getForeignTradeRouteModifier()			== 0)					m_iForeignTradeRouteModifier		= pClassInfo->getForeignTradeRouteModifier();
	if (getGlobalPopulationChange()				== 0)					m_iGlobalPopulationChange			= pClassInfo->getGlobalPopulationChange();
	if (getFreeTechs()							== 0)					m_iFreeTechs						= pClassInfo->getFreeTechs();
	if (getDefenseModifier()					== 0)					m_iDefenseModifier					= pClassInfo->getDefenseModifier();
	if (getBombardDefenseModifier()				== 0)					m_iBombardDefenseModifier			= pClassInfo->getBombardDefenseModifier();
	if (getAllCityDefenseModifier()				== 0)					m_iAllCityDefenseModifier			= pClassInfo->getAllCityDefenseModifier();
	if (getEspionageDefenseModifier()			== 0)					m_iEspionageDefenseModifier			= pClassInfo->getEspionageDefenseModifier();
	if (getAssetValue()							== 0)					m_iAssetValue						= pClassInfo->getAssetValue();
	if (getPowerValue()							== 0)					m_iPowerValue						= pClassInfo->getPowerValue();
	if (getMaxLatitude()						== 90)					m_iMaxLatitude						= pClassInfo->getMaxLatitude();
	if (getVisibilityPriority()					== 0.0f)				m_fVisibilityPriority				= pClassInfo->getVisibilityPriority();
	if (getConstructSound()						== cDefault)			setConstructSound(					pClassInfo->getConstructSound() );
	if (getFreeStartEra()						== NO_ERA)				m_iFreeStartEra						= pClassInfo->getFreeStartEra();
	if (getMaxStartEra()						== NO_ERA)				m_iMaxStartEra						= pClassInfo->getMaxStartEra();
	if (getObsoleteTech()						== NO_TECH)				m_iObsoleteTech						= pClassInfo->getObsoleteTech();
	if (getPrereqAndTech()						== NO_TECH)				m_iPrereqAndTech					= pClassInfo->getPrereqAndTech();
	if (getPrereqTrait()						== NO_TRAIT)			m_iPrereqTrait						= pClassInfo->getPrereqTrait();
	if (getPrereqAndBonus()						== NO_BONUS)			m_iPrereqAndBonus					= pClassInfo->getPrereqAndBonus();
	if (getNoBonus()							== NO_BONUS)			m_iNoBonus							= pClassInfo->getNoBonus();
	if (getPowerBonus()							== NO_BONUS)			m_iPowerBonus						= pClassInfo->getPowerBonus();
	if (getFreeBonus()							== NO_BONUS)			m_iFreeBonus						= pClassInfo->getFreeBonus();
	if (getFreeBonus2()							== NO_BONUS)			m_iFreeBonus2						= pClassInfo->getFreeBonus2();
	if (getFreeBonus3()							== NO_BONUS)			m_iFreeBonus3						= pClassInfo->getFreeBonus3();
	if (getAdvisorType()						== NO_ADVISOR)			m_iAdvisorType						= pClassInfo->getAdvisorType();
	if (getVictoryPrereq()						== NO_VICTORY)			m_iVictoryPrereq					= pClassInfo->getVictoryPrereq();
	if (getHolyCity()							== NO_RELIGION)			m_iHolyCity							= pClassInfo->getHolyCity();
	if (getReligionType()						== NO_RELIGION)			m_iReligionType						= pClassInfo->getReligionType();
	if (getStateReligion()						== NO_RELIGION)			m_iStateReligion					= pClassInfo->getStateReligion();
	if (getPrereqReligion()						== NO_RELIGION)			m_iPrereqReligion					= pClassInfo->getPrereqReligion();
	if (getGlobalReligionCommerce()				== NO_RELIGION)			m_iGlobalReligionCommerce			= pClassInfo->getGlobalReligionCommerce();
	if (getFreePromotion()						== NO_PROMOTION)		m_iFreePromotion					= pClassInfo->getFreePromotion();
	if (getRemovePromotion()					== NO_PROMOTION)		m_iRemovePromotion					= pClassInfo->getRemovePromotion();
	if (getGreatPeopleUnitClass()				== NO_UNITCLASS)		m_iGreatPeopleUnitClass				= pClassInfo->getGreatPeopleUnitClass();
	if (getVoteSourceType()						== NO_VOTESOURCE)		m_iVoteSourceType					= pClassInfo->getVoteSourceType();
	if (getPrereqCorporation()					== NO_CORPORATION)		m_iPrereqCorporation				= pClassInfo->getPrereqCorporation();
	if (getFoundsCorporation()					== NO_CORPORATION)		m_iFoundsCorporation				= pClassInfo->getFoundsCorporation();
	if (getGlobalCorporationCommerce()			== NO_CORPORATION)		m_iGlobalCorporationCommerce		= pClassInfo->getGlobalCorporationCommerce();
	if (getCivicOption()						== NO_CIVICOPTION)		m_iCivicOption						= pClassInfo->getCivicOption();
	if (getBuildingClassType()					== NO_BUILDINGCLASS)	m_iBuildingClassType				= pClassInfo->getBuildingClassType();
	if (getFreeBuildingClass()					== NO_BUILDINGCLASS)	m_iFreeBuildingClass				= pClassInfo->getFreeBuildingClass();
	if (getSpecialBuildingType()				== NO_SPECIALBUILDING)	m_iSpecialBuildingType				= pClassInfo->getSpecialBuildingType();
	for ( int j = 0; j < GC.getNUM_BUILDING_AND_TECH_PREREQS(); j++)
	{
		if (getPrereqAndTechs(j)				== NO_TECH)				m_piPrereqAndTechs[j]				= pClassInfo->getPrereqAndTechs(j);
	}
	for ( int j = 0; j < GC.getNUM_BUILDING_PREREQ_OR_BONUSES(); j++)
	{
		if (getPrereqOrBonuses(j)				== NO_BONUS)			m_piPrereqOrBonuses[j]				= pClassInfo->getPrereqOrBonuses(j);
	}
	for ( int j = 0; j < GC.getNumTraitInfos(); j++)
	{
		if (getProductionTraits(j)				== 0)					m_piProductionTraits[j]				= pClassInfo->getProductionTraits(j);
		if (getHappinessTraits(j)				== 0)					m_piHappinessTraits[j]				= pClassInfo->getHappinessTraits(j);
	}
	for ( int j = 0; j < NUM_YIELD_TYPES; j++)
	{
		if (getSeaPlotYieldChange(j)			== 0)					m_piSeaPlotYieldChange[j]			= pClassInfo->getSeaPlotYieldChange(j);
		if (getRiverPlotYieldChange(j)			== 0)					m_piRiverPlotYieldChange[j]			= pClassInfo->getRiverPlotYieldChange(j);
		if (getGlobalSeaPlotYieldChange(j)		== 0)					m_piGlobalSeaPlotYieldChange[j]		= pClassInfo->getGlobalSeaPlotYieldChange(j);
		if (getYieldChange(j)					== 0)					m_piYieldChange[j]					= pClassInfo->getYieldChange(j);
		if (getYieldModifier(j)					== 0)					m_piYieldModifier[j]				= pClassInfo->getYieldModifier(j);
		if (getPowerYieldModifier(j)			== 0)					m_piPowerYieldModifier[j]			= pClassInfo->getPowerYieldModifier(j);
		if (getAreaYieldModifier(j)				== 0)					m_piAreaYieldModifier[j]			= pClassInfo->getAreaYieldModifier(j);
		if (getGlobalYieldModifier(j)			== 0)					m_piGlobalYieldModifier[j]			= pClassInfo->getGlobalYieldModifier(j);
	}
	for ( int j = 0; j < NUM_COMMERCE_TYPES; j++)
	{
		if (getCommerceChange(j)				== 0)					m_piCommerceChange[j]				= pClassInfo->getCommerceChange(j);
		if (getObsoleteSafeCommerceChange(j)	== 0)					m_piObsoleteSafeCommerceChange[j]	= pClassInfo->getObsoleteSafeCommerceChange(j);
		if (getCommerceChangeDoubleTime(j)		== 0)					m_piCommerceChangeDoubleTime[j]		= pClassInfo->getCommerceChangeDoubleTime(j);
		if (getCommerceModifier(j)				== 0)					m_piCommerceModifier[j]				= pClassInfo->getCommerceModifier(j);
		if (getGlobalCommerceModifier(j)		== 0)					m_piGlobalCommerceModifier[j]		= pClassInfo->getGlobalCommerceModifier(j);
		if (getSpecialistExtraCommerce(j)		== 0)					m_piSpecialistExtraCommerce[j]		= pClassInfo->getSpecialistExtraCommerce(j);
		if (getStateReligionCommerce(j)			== 0)					m_piStateReligionCommerce[j]		= pClassInfo->getStateReligionCommerce(j);
		if (getCommerceHappiness(j)				== 0)					m_piCommerceHappiness[j]			= pClassInfo->getCommerceHappiness(j);
		if (isCommerceFlexible(j)				== false)				m_pbCommerceFlexible[j]				= pClassInfo->isCommerceFlexible(j);
		if (isCommerceChangeOriginalOwner(j)	== false)				m_pbCommerceChangeOriginalOwner[j]	= pClassInfo->isCommerceChangeOriginalOwner(j);
	}
	for ( int j = 0; j < GC.getNumReligionInfos(); j++)
	{
		if (getReligionChange(j)				== 0)					m_piReligionChange[j]				= pClassInfo->getReligionChange(j);
	}
	for ( int j = 0; j < GC.getNumSpecialistInfos(); j++)
	{
		if (getSpecialistCount(j)				== 0)					m_piSpecialistCount[j]				= pClassInfo->getSpecialistCount(j);
		if (getFreeSpecialistCount(j)			== 0)					m_piFreeSpecialistCount[j]			= pClassInfo->getFreeSpecialistCount(j);

		for ( int i = 0; i < NUM_YIELD_TYPES; i++)
		{
			if (getSpecialistYieldChange(j, i)	== 0)					m_ppaiSpecialistYieldChange[j][i]	= pClassInfo->getSpecialistYieldChange(j, i); //modified Sephi
		}
		for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
		{
			if (getSpecialistCommerceChange(j, i)== 0)					m_ppaiSpecialistCommerceChange[j][i]= pClassInfo->getSpecialistCommerceChange(j, i); //modified Sephi
		}

	}
	for ( int j = 0; j < GC.getNumBonusInfos(); j++)
	{
		if (getBonusHealthChanges(j)			== 0)					m_piBonusHealthChanges[j]			= pClassInfo->getBonusHealthChanges(j);
		if (getBonusHappinessChanges(j)			== 0)					m_piBonusHappinessChanges[j]		= pClassInfo->getBonusHappinessChanges(j);
		if (getBonusProductionModifier(j)		== 0)					m_piBonusProductionModifier[j]		= pClassInfo->getBonusProductionModifier(j);

		for ( int i = 0; i < NUM_YIELD_TYPES; i++)
		{
			if (getBonusYieldModifier(j, i)		== 0)					m_ppaiBonusYieldModifier[j][i]		= pClassInfo->getBonusYieldModifier(j, i); //modified Sephi
		}

	}

	for ( int j = 0; j < GC.getNumUnitCombatInfos(); j++)
	{
		if (getUnitCombatFreeExperience(j)		== 0)					m_piUnitCombatFreeExperience[j]		= pClassInfo->getUnitCombatFreeExperience(j);
	}
	for ( int j = 0; j < NUM_DOMAIN_TYPES; j++)
	{
		if (m_piDomainFreeExperience[j]			== 0)					m_piDomainFreeExperience[j]			= pClassInfo->getDomainFreeExperience(j);
		if (m_piDomainProductionModifier[j]		== 0)					m_piDomainProductionModifier[j]		= pClassInfo->getDomainProductionModifier(j);
	}
	for ( int j = 0; j < GC.getNumBuildingClassInfos(); j++)
	{
		if (isBuildingClassNeededInCity(j)		== false)				m_pbBuildingClassNeededInCity[j]	= pClassInfo->isBuildingClassNeededInCity(j);
		if (getPrereqNumOfBuildingClass(j)		== 0)					m_piPrereqNumOfBuildingClass[j]		= pClassInfo->getPrereqNumOfBuildingClass(j);
	}
	//Storing these values allows us to skip the loop over all buildingclasses if there aren't any prereqs needing checked.
	for ( int j = 0; j < GC.getNumFlavorTypes(); j++)
	{
		if (getFlavorValue(j)					== 0)					m_piFlavorValue[j]					= pClassInfo->getFlavorValue(j);
	}
	for ( int j = 0; j < GC.getNumImprovementInfos(); j++)
	{
		if (getImprovementFreeSpecialist(j)		== 0)					m_piImprovementFreeSpecialist[j]	= pClassInfo->getImprovementFreeSpecialist(j);
	}
	for ( int j = 0; j < GC.getNumBuildingClassInfos(); j++)
	{
		if (getBuildingHappinessChanges(j)		== 0)					m_piBuildingHappinessChanges[j]		= pClassInfo->getBuildingHappinessChanges(j);
	}

/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
	if (getMistDensity()                        == 0       )            m_iMistDensity                      = pClassInfo->getMistDensity();
	if (getManaFromImprovement()                == 0       )            m_iManaFromImprovement              = pClassInfo->getManaFromImprovement();
	if (getManaFromImprovementType()            == NO_IMPROVEMENT       )            m_iManaFromImprovementType          = pClassInfo->getManaFromImprovementType();
	if (getTaxesModifier()                      == 0       )            m_iTaxesModifier                    = pClassInfo->getTaxesModifier();
	if (getBuildingMaintenance()                == 0       )            m_iBuildingMaintenance              = pClassInfo->getBuildingMaintenance();
	if (getGPPThresholdReductionPercent()       == 0       )            m_iGPPThresholdReductionPercent     = pClassInfo->getGPPThresholdReductionPercent();
	if (getMaxManaChange()                      == 0       )            m_iMaxManaChange                    = pClassInfo->getMaxManaChange();
	if (getReducedCostByYieldOverwrite()        == NO_YIELD)            m_iReducedCostByYieldOverwrite      = pClassInfo->getReducedCostByYieldOverwrite();
	if (getPopulationCost()                     == 0       )            m_iPopulationCost                   = pClassInfo->getPopulationCost();
	if (getGlobalYieldTypeCost()                == NO_YIELD)            m_iGlobalYieldTypeCost              = pClassInfo->getGlobalYieldTypeCost();
	if (getGlobalYieldCost()                    == 0       )            m_iGlobalYieldCost                  = pClassInfo->getGlobalYieldCost();
	if (getUnitSupportChange()                  == 0       )            m_iUnitSupportChange                = pClassInfo->getUnitSupportChange();
	if (getLastTurnPossibleBuild()              == 0       )            m_iLastTurnPossibleBuild            = pClassInfo->getLastTurnPossibleBuild();
	if (getCommercePercentTypeForced()          == NO_COMMERCE)         m_iCommercePercentTypeForced        = pClassInfo->getCommercePercentTypeForced();
	if (getPopulationLimitChange()              == 0       )            m_iPopulationLimitChange            = pClassInfo->getPopulationLimitChange();
	if (isAdjacentPeak()						== false   )            m_bAdjacentPeak                     = pClassInfo->isAdjacentPeak();
	if (isAdjacentUF()							== false   )            m_bAdjacentUF	                    = pClassInfo->isAdjacentUF();
	if (isDistrict()							== false   )            m_bDistrict							= pClassInfo->isDistrict();
	if (isEnchantment()							== false   )            m_bEnchantment			            = pClassInfo->isEnchantment();
	if (getPrereqBuildingClass()                == NO_BUILDINGCLASS)    m_iPrereqBuildingClass              = pClassInfo->getPrereqBuildingClass();
	if (getPrereqBuildingClassInAllCities()     == NO_BUILDINGCLASS)    m_iPrereqBuildingClassInAllCities   = pClassInfo->getPrereqBuildingClassInAllCities();
	if (getPrereqImprovement()					== NO_IMPROVEMENT)      m_iPrereqImprovement				= pClassInfo->getPrereqImprovement();

	if (getBonusCommerceType()                  == NO_COMMERCE)			m_iBonusCommerceType				= pClassInfo->getBonusCommerceType();
	if (getBonusYieldType()						== NO_YIELD)            m_iBonusYieldType					= pClassInfo->getBonusYieldType();
	if (getAISpecialization1()					== NO_CITYSPECIALIZATION) m_iAISpecialization1				= pClassInfo->getAISpecialization1();
	if (getAISpecialization2()					== NO_CITYSPECIALIZATION) m_iAISpecialization2				= pClassInfo->getAISpecialization2();

	if (getInitialValue()						== 0       )            m_iInitialValue						= pClassInfo->getInitialValue();
	if (getPerBonusValue()						== 0       )            m_iPerBonusValue					= pClassInfo->getPerBonusValue();

	for ( int j = 0; j < GC.getNumBonusInfos(); j++)
	{
		if (isBonusLinked(j)		== false)	m_pabBonusLinked[j]		= pClassInfo->isBonusLinked(j);
		if (isBonusConsumed(j)		== false)	m_pabBonusConsumed[j]		= pClassInfo->isBonusConsumed(j);
		if (isBonusNearbyNeeded(j)		== false)	m_pabBonusNearbyNeeded[j]		= pClassInfo->isBonusNearbyNeeded(j);
	}

	for ( int j = 0; j < GC.getNumBuildingClassInfos(); j++)
	{		
		if (isBuildingClassBlocked(j)		== false)	m_pabBuildingClassBlocked[j]		= pClassInfo->isBuildingClassBlocked(j);
	}

	for ( int j = 0; j < GC.getNUM_COMMERCE_TYPES(); j++)
	{
		if (getCommercePerPopulation(j)		== 0)	m_paiCommercePerPopulation[j]		= pClassInfo->getCommercePerPopulation(j);
	}

	for ( int j = 0; j < GC.getNUM_COMMERCE_TYPES(); j++)
	{
		if (getCommercePerCultureLevel(j)		== 0)	m_paiCommercePerCultureLevel[j]		= pClassInfo->getCommercePerCultureLevel(j);
	}

	for ( int j = 0; j < GC.getNUM_YIELD_TYPES(); j++)
	{
		if (getYieldPerCultureLevel(j)		== 0)		m_paiYieldPerCultureLevel[j]		= pClassInfo->getYieldPerCultureLevel(j);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	(New Definitions) Sephi                                           							**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiImprovementYieldChanges[i][j]	== 0)			m_ppiImprovementYieldChanges[i][j]	= pClassInfo->getImprovementYieldChanges(i, j);
		}
	}

	if (isVictoryBuilding()						== false)			m_bVictoryBuilding						= pClassInfo->isVictoryBuilding();
	if (getRequiredGameOption()		== NO_GAMEOPTION)					m_iRequiredGameOption	= pClassInfo->getRequiredGameOption();
	for ( int j = 0; j < GC.getNumUnitCombatInfos(); j++)
	{
		if (getTrainXPCap(j)					== 0)				m_paiTrainXPCap[j]					= pClassInfo->getTrainXPCap(j);
		if (getGlobalTrainXPCap(j)				== 0)				m_paiGlobalTrainXPCap[j]			= pClassInfo->getGlobalTrainXPCap(j);
		if (getTrainXPRate(j)					== 0)				m_paiTrainXPRate[j]					= pClassInfo->getTrainXPRate(j);
		if (getGlobalTrainXPRate(j)				== 0)				m_paiGlobalTrainXPRate[j]			= pClassInfo->getGlobalTrainXPRate(j);
	}
    if(getCorporationSupportNeeded()== NO_CORPORATION)                 m_iCorporationSupportNeeded = pClassInfo->getCorporationSupportNeeded();

	for ( int j = 0; j < GC.getNumCorporationInfos(); j++)
	{
		if (getCorporationSupport((CorporationTypes)j)			== 0)				m_paiCorporationSupport[j]			= pClassInfo->getCorporationSupport((CorporationTypes)j);
		if (getCorporationSupportMultiplier((CorporationTypes)j)== 0)				m_paiCorporationSupportMod[j]		= pClassInfo->getCorporationSupportMultiplier((CorporationTypes)j);
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	//readpass3
	for ( int i = 0; i < pClassInfo->getPrereqCivVectorSize(); i++ )
	{
		m_aszExtraXMLforPass3.push_back(pClassInfo->getPrereqCivVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getPrereqCivicVectorSize(); i++ )
	{
		m_aszExtraXML1forPass3.push_back(pClassInfo->getPrereqCivicVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//FfH: Added by Kael 08/27/2009
bool CvBuildingInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular	Sephi           							                                  	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

	m_iPrereqCiv = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);

	m_aszExtraXMLforPass3.clear();
/**								----  End Original Code  ----									**/

	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iPrereqCiv = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}

	m_aszExtraXMLforPass3.clear();

	iSize = m_aszExtraXML1forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML1forPass3[i], true) != -1)
		{
			m_iPrereqCivic = GC.getInfoTypeForString(m_aszExtraXML1forPass3[i]);
			break;
		}
	}

	m_aszExtraXML1forPass3.clear();
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	return true;
}

//FfH: End Add

//======================================================================================================
//					CvSpecialBuildingInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpecialBuildingInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialBuildingInfo::CvSpecialBuildingInfo() :
m_iObsoleteTech(NO_TECH),
m_iTechPrereq(NO_TECH),
m_iTechPrereqAnyone(NO_TECH),
m_bValid(false),
m_piProductionTraits(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpecialBuildingInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpecialBuildingInfo::~CvSpecialBuildingInfo()
{
	SAFE_DELETE_ARRAY(m_piProductionTraits);
}

int CvSpecialBuildingInfo::getObsoleteTech( void ) const
{
	return m_iObsoleteTech;
}

int CvSpecialBuildingInfo::getTechPrereq( void ) const
{
	return m_iTechPrereq;
}

int CvSpecialBuildingInfo::getTechPrereqAnyone( void ) const
{
	return m_iTechPrereqAnyone;
}

bool CvSpecialBuildingInfo::isValid( void ) const
{
	return m_bValid;
}

// Arrays

int CvSpecialBuildingInfo::getProductionTraits(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProductionTraits ? m_piProductionTraits[i] : -1;
}

bool CvSpecialBuildingInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ObsoleteTech");
	m_iObsoleteTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TechPrereqAnyone");
	m_iTechPrereqAnyone = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bValid, "bValid");

	pXML->SetVariableListTagPair(&m_piProductionTraits, "ProductionTraits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpecialBuildingInfo::copyNonDefaults(CvSpecialBuildingInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getObsoleteTech()				== 0)			m_iObsoleteTech				= pClassInfo->getObsoleteTech();
	if (getTechPrereq()					== 0)			m_iTechPrereq				= pClassInfo->getTechPrereq();
	if (getTechPrereqAnyone()			== 0)			m_iTechPrereqAnyone			= pClassInfo->getTechPrereqAnyone();
	if (isValid()						== false)		m_bValid					= pClassInfo->isValid();
	for (int i = 0; i < GC.getNumTraitInfos(); i++)
	{
		if (m_piProductionTraits[i]		== 0)			m_piProductionTraits[i]		= pClassInfo->getProductionTraits(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvBuildingClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBuildingClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingClassInfo::CvBuildingClassInfo() :
m_iMaxGlobalInstances(0),
m_iMaxTeamInstances(0),
m_iMaxPlayerInstances(0),
m_iExtraPlayerInstances(0),
m_iDefaultBuildingIndex(NO_BUILDING),
m_bNoLimit(false),
m_bMonument(false),
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
m_iReducedCostByYield(NO_YIELD),
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
m_piVictoryThreshold(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBuildingClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBuildingClassInfo::~CvBuildingClassInfo()
{
	SAFE_DELETE_ARRAY(m_piVictoryThreshold);
}

int CvBuildingClassInfo::getMaxGlobalInstances() const
{
	return m_iMaxGlobalInstances;
}

int CvBuildingClassInfo::getMaxTeamInstances() const
{
	return m_iMaxTeamInstances;
}

int CvBuildingClassInfo::getMaxPlayerInstances() const
{
	return m_iMaxPlayerInstances;
}

int CvBuildingClassInfo::getExtraPlayerInstances() const
{
	return m_iExtraPlayerInstances;
}

int CvBuildingClassInfo::getDefaultBuildingIndex() const
{
	return m_iDefaultBuildingIndex;
}

void CvBuildingClassInfo::setDefaultBuildingIndex(int i)
{
	m_iDefaultBuildingIndex = i;
}

bool CvBuildingClassInfo::isNoLimit() const
{
	return m_bNoLimit;
}

bool CvBuildingClassInfo::isMonument() const
{
	return m_bMonument;
}
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
int CvBuildingClassInfo::getReducedCostByYield() const
{
	return m_iReducedCostByYield;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

// Arrays

int CvBuildingClassInfo::getVictoryThreshold(int i) const
{
	FAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piVictoryThreshold ? m_piVictoryThreshold[i] : -1;
}

bool CvBuildingClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iMaxGlobalInstances, "iMaxGlobalInstances");
	pXML->GetChildXmlValByName(&m_iMaxTeamInstances, "iMaxTeamInstances");
	pXML->GetChildXmlValByName(&m_iMaxPlayerInstances, "iMaxPlayerInstances");
	pXML->GetChildXmlValByName(&m_iExtraPlayerInstances, "iExtraPlayerInstances");
	pXML->GetChildXmlValByName(&m_bNoLimit, "bNoLimit");
	pXML->GetChildXmlValByName(&m_bMonument, "bMonument");

	pXML->SetVariableListTagPair(&m_piVictoryThreshold, "VictoryThresholds", sizeof(GC.getVictoryInfo((VictoryTypes)0)), GC.getNumVictoryInfos());

	CvString szTextVal;
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
//	pXML->GetChildXmlValByName(szTextVal, "ReducedCostByYield"); disable
//	m_iReducedCostByYield = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "DefaultBuilding");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	return true;
}

bool CvBuildingClassInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iDefaultBuildingIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iTextDefault = -1;
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]) != iTextDefault)
		{
			m_iDefaultBuildingIndex = GC.getInfoTypeForString(m_aszExtraXMLforPass3[iSize - ( i + 1)]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBuildingClassInfo::copyNonDefaults(CvBuildingClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getMaxGlobalInstances()			== 0)				m_iMaxGlobalInstances		= pClassInfo->getMaxGlobalInstances();
	if (getMaxTeamInstances()			== 0)				m_iMaxTeamInstances			= pClassInfo->getMaxTeamInstances();
	if (getMaxPlayerInstances()			== 0)				m_iMaxPlayerInstances		= pClassInfo->getMaxPlayerInstances();
	if (getExtraPlayerInstances()		== 0)				m_iExtraPlayerInstances		= pClassInfo->getExtraPlayerInstances();
	if (isNoLimit()						== false)			m_bNoLimit					= pClassInfo->isNoLimit();
	if (isMonument()					== false)			m_bMonument					= pClassInfo->isMonument();
/*************************************************************************************************/
/**	ADDON (New Function Definitions) Sephi                                                      **/
/*************************************************************************************************/
	if (getReducedCostByYield()			== NO_YIELD)		m_iReducedCostByYield		= pClassInfo->getReducedCostByYield();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	for ( int i = 0; i < GC.getNumVictoryInfos(); i++ )
	{
		if (m_piVictoryThreshold[i]		== 0)				m_piVictoryThreshold[i]		= pClassInfo->getVictoryThreshold(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvRiverInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRiverInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRiverInfo::CvRiverInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRiverInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRiverInfo::~CvRiverInfo()
{
}

//======================================================================================================
//					CvRiverModelInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRiverModelInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRiverModelInfo::CvRiverModelInfo() :
m_iTextureIndex(0)
{
	m_szDeltaString[0] = '\0';
	m_szConnectString[0] = '\0';
	m_szRotateString[0] = '\0';
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRiverModelInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRiverModelInfo::~CvRiverModelInfo()
{
}

const TCHAR* CvRiverModelInfo::getModelFile() const
{
	return m_szModelFile;
}

void CvRiverModelInfo::setModelFile(const TCHAR* szVal)					// The model filename
{
	m_szModelFile=szVal;
}

const TCHAR* CvRiverModelInfo::getBorderFile() const
{
	return m_szBorderFile;
}

void CvRiverModelInfo::setBorderFile(const TCHAR* szVal)					// The model filename
{
	m_szBorderFile=szVal;
}

int CvRiverModelInfo::getTextureIndex() const
{
	return m_iTextureIndex;
}

const TCHAR* CvRiverModelInfo::getDeltaString() const
{
	return m_szDeltaString;
}

const TCHAR* CvRiverModelInfo::getConnectString() const
{
	return m_szConnectString;
}

const TCHAR* CvRiverModelInfo::getRotateString() const
{
	return m_szRotateString;
}

bool CvRiverModelInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	if(pXML->GetChildXmlValByName(szTextVal, "ModelFile"))
	{
		setModelFile(szTextVal);
	}
	if(pXML->GetChildXmlValByName(szTextVal, "BorderFile"))
	{
		setBorderFile(szTextVal);
	}

	pXML->GetChildXmlValByName(&m_iTextureIndex, "TextureIndex");
	pXML->GetChildXmlValByName(m_szDeltaString, "DeltaType");
	pXML->GetChildXmlValByName(m_szConnectString, "Connections");
	pXML->GetChildXmlValByName(m_szRotateString, "Rotations");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvRiverModelInfo::copyNonDefaults(CvRiverModelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTextureIndex()	== 0)			m_iTextureIndex													= pClassInfo->getTextureIndex();
	if (getModelFile()		== cDefault)	setModelFile(													pClassInfo->getModelFile());
	if (getBorderFile()		== cDefault)	setBorderFile(													pClassInfo->getBorderFile());
	if (getDeltaString()	== cDefault)	strcpy (m_szDeltaString, (LPCTSTR) CvString::format("%s",		pClassInfo->getDeltaString()));
	if (getConnectString()	== cDefault)	strcpy (m_szConnectString, (LPCTSTR) CvString::format("%s",		pClassInfo->getConnectString()));
	if (getRotateString()	== cDefault)	strcpy (m_szRotateString, (LPCTSTR) CvString::format("%s",		pClassInfo->getRotateString()));
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvRouteModelInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRouteModelInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRouteModelInfo::CvRouteModelInfo() :
m_eRouteType(NO_ROUTE),
m_bAnimated(false)
{
	m_szConnectString[0] = '\0';
	m_szModelConnectString[0] = '\0';
	m_szRotateString[0] = '\0';
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRouteModelInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRouteModelInfo::~CvRouteModelInfo()
{
}

RouteTypes CvRouteModelInfo::getRouteType() const		// The route type
{
	return m_eRouteType;
}

const TCHAR* CvRouteModelInfo::getModelFile() const
{
	return m_szModelFile;
}

void CvRouteModelInfo::setModelFile(const TCHAR* szVal)				// The model filename
{
	m_szModelFile=szVal;
}

const TCHAR* CvRouteModelInfo::getLateModelFile() const
{
	return m_szLateModelFile;
}

void CvRouteModelInfo::setLateModelFile(const TCHAR* szVal)				// The model filename
{
	m_szLateModelFile=szVal;
}

const TCHAR* CvRouteModelInfo::getModelFileKey() const
{
	return m_szModelFileKey;
}

void CvRouteModelInfo::setModelFileKey(const TCHAR* szVal)				// The model filename Key
{
	m_szModelFileKey=szVal;
}

bool CvRouteModelInfo::isAnimated() const
{
	return m_bAnimated;
}

const TCHAR* CvRouteModelInfo::getConnectString() const
{
	return m_szConnectString;
}

const TCHAR* CvRouteModelInfo::getModelConnectString() const
{
	return m_szModelConnectString;
}

const TCHAR* CvRouteModelInfo::getRotateString() const
{
	return m_szRotateString;
}

bool CvRouteModelInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ModelFile");
	setModelFile(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "LateModelFile");
	setLateModelFile(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ModelFileKey");
	setModelFileKey(szTextVal);

	pXML->GetChildXmlValByName(&m_bAnimated, "Animated");

	pXML->GetChildXmlValByName(szTextVal, "RouteType");
	m_eRouteType = (RouteTypes)(pXML->FindInInfoClass(szTextVal));
	pXML->GetChildXmlValByName(m_szConnectString, "Connections");
	pXML->GetChildXmlValByName(m_szModelConnectString, "ModelConnections");
	pXML->GetChildXmlValByName(m_szRotateString, "Rotations");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvRouteModelInfo::copyNonDefaults(CvRouteModelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isAnimated()				== false)			m_bAnimated															= pClassInfo->isAnimated();
	if (getRouteType()				== NO_ROUTE)		m_eRouteType														= pClassInfo->getRouteType();
	if (getModelFile()				== cDefault)		setModelFile(														pClassInfo->getModelFile());
	if (getLateModelFile()			== cDefault)		setLateModelFile(													pClassInfo->getLateModelFile());
	if (getModelFileKey()			== cDefault)		setModelFileKey(													pClassInfo->getModelFileKey());
	if (getConnectString()			== cDefault)		strcpy (m_szConnectString, (LPCTSTR) CvString::format("%s",			pClassInfo->getConnectString()));
	if (getModelConnectString()		== cDefault)		strcpy (m_szModelConnectString, (LPCTSTR) CvString::format("%s",	pClassInfo->getModelConnectString()));
	if (getRotateString()			== cDefault)		strcpy (m_szRotateString, (LPCTSTR) CvString::format("%s",			pClassInfo->getRotateString()));
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCivilizationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCivilizationInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCivilizationInfo::CvCivilizationInfo():
m_iDefaultPlayerColor(NO_PLAYERCOLOR),
m_iArtStyleType(NO_ARTSTYLE),
m_iUnitArtStyleType(NO_UNIT_ARTSTYLE),
m_iNumCityNames(0),
m_iNumLeaders(0),
m_iSelectionSoundScriptId(0),
m_iActionSoundScriptId(0),
m_iDerivativeCiv(NO_CIVILIZATION),
m_bPlayable(false),
m_bAIPlayable(false),
m_piCivilizationBuildings(NULL),
m_piCivilizationUnits(NULL),
m_piCivilizationFreeUnitsClass(NULL),
m_piCivilizationInitialCivics(NULL),
m_pbCivilizationAllowedCivics(NULL),
m_pbLeaders(NULL),
m_pbCivilizationFreeBuildingClass(NULL),
m_pbCivilizationFreeTechs(NULL),
m_pbCivilizationDisableTechs(NULL),
m_paszCityNames(NULL),

//FfH: Added by Kael 08/07/2007
m_iCivTrait(NO_TRAIT),
m_iDefaultRace(NO_PROMOTION),
m_iHero(NO_UNIT),
m_pbMaintainFeatures(NULL),
m_pbNativeTerrains(NULL),
m_pbImprovementNonDefault(NULL),
m_pbUnitRoster(NULL)
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
,m_eBestDefender1(NO_UNITCLASS)
,m_eBestDefender2(NO_UNITCLASS)
,m_eBestDefender3(NO_UNITCLASS)
,m_eBestPatrol1(NO_UNITCLASS)
,m_eBestPatrol2(NO_UNITCLASS)
,m_eBestPatrol3(NO_UNITCLASS)
,m_bNewCiv(false)
,m_bNoFaith(false)
,m_bAlwaysConnectResources(false)
,m_bSpellResearchFromMaintainFeatures(false)
,m_iReducedManaCostInGoldenAge(0)
,m_iPopulationLimit(-1)
,m_iImpInfrastructureHalfCost(NO_IMPROVEMENT)
,m_iImprovementCostIncrease(0)
,m_iNativePlane(NO_PLANE)
,m_iDefaultUnit(NO_UNIT)
,m_iFavoredYield(NO_YIELD)
,m_piFlavorValue(NULL)
,m_szFlavorScreenImage(NULL)
,m_szFlavorCityScreenImage(NULL)

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCivilizationInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCivilizationInfo::~CvCivilizationInfo()
{
	SAFE_DELETE_ARRAY(m_piCivilizationBuildings);
	SAFE_DELETE_ARRAY(m_piCivilizationUnits);
	SAFE_DELETE_ARRAY(m_piCivilizationFreeUnitsClass);
	SAFE_DELETE_ARRAY(m_piCivilizationInitialCivics);
	SAFE_DELETE_ARRAY(m_pbCivilizationAllowedCivics);
	SAFE_DELETE_ARRAY(m_pbLeaders);
	SAFE_DELETE_ARRAY(m_pbCivilizationFreeBuildingClass);
	SAFE_DELETE_ARRAY(m_pbCivilizationFreeTechs);
	SAFE_DELETE_ARRAY(m_pbCivilizationDisableTechs);
	SAFE_DELETE_ARRAY(m_paszCityNames);

//FfH: Added by Kael 05/27/2008
	SAFE_DELETE_ARRAY(m_pbMaintainFeatures);
	SAFE_DELETE_ARRAY(m_pbNativeTerrains);
	SAFE_DELETE_ARRAY(m_pbImprovementNonDefault);
	SAFE_DELETE_ARRAY(m_pbUnitRoster);
//FfH: End Add
	SAFE_DELETE_ARRAY(m_piFlavorValue);
}

void CvCivilizationInfo::reset()
{
	CvInfoBase::reset();
	m_aszAdjective.clear();
	m_aszShortDescription.clear();
}


int CvCivilizationInfo::getDefaultPlayerColor() const
{
	return m_iDefaultPlayerColor;
}

int CvCivilizationInfo::getArtStyleType() const
{
	return m_iArtStyleType;
}

int CvCivilizationInfo::getUnitArtStyleType() const
{
	return m_iUnitArtStyleType;
}

int CvCivilizationInfo::getNumCityNames() const
{
	return m_iNumCityNames;
}

int CvCivilizationInfo::getNumLeaders() const// the number of leaders the Civ has, this is needed so that random leaders can be generated easily
{
	return m_iNumLeaders;
}

int CvCivilizationInfo::getSelectionSoundScriptId() const
{
	return m_iSelectionSoundScriptId;
}

int CvCivilizationInfo::getActionSoundScriptId() const
{
	return m_iActionSoundScriptId;
}

bool CvCivilizationInfo::isAIPlayable() const
{

//FfH: Added by Kael 07/01/2008
	if (CvPlayerAI::areStaticsInitialized())
	{
		if (GC.getGameINLINE().isFinalInitialized())
		{
            if (isGraphicalOnly())
            {
                return false;
			}
		}
	}
//FfH: End Add

	return m_bAIPlayable;
}

bool CvCivilizationInfo::isPlayable() const
{

//FfH: Added by Kael 07/01/2008
	if (CvPlayerAI::areStaticsInitialized())
	{
		if (GC.getGameINLINE().isFinalInitialized())
		{
            if (isGraphicalOnly())
            {
                return false;
			}
		}
	}
//FfH: End Add

	return m_bPlayable;
}

const wchar* CvCivilizationInfo::getShortDescription(uint uiForm)
{
	while(m_aszShortDescription.size() <= uiForm)
	{
		m_aszShortDescription.push_back(gDLL->getObjectText(m_szShortDescriptionKey, m_aszShortDescription.size()));
	}

	return m_aszShortDescription[uiForm];
}

const wchar* CvCivilizationInfo::getShortDescriptionKey() const
{
	return m_szShortDescriptionKey;
}

const wchar* CvCivilizationInfo::getAdjective(uint uiForm)
{
	while(m_aszAdjective.size() <= uiForm)
	{
		m_aszAdjective.push_back(gDLL->getObjectText(m_szAdjectiveKey, m_aszAdjective.size()));
	}

	return m_aszAdjective[uiForm];
}

const wchar* CvCivilizationInfo::getAdjectiveKey() const
{
	return m_szAdjectiveKey;
}

const TCHAR* CvCivilizationInfo::getFlagTexture() const
{
	return ARTFILEMGR.getCivilizationArtInfo( getArtDefineTag() )->getPath();
}

const TCHAR* CvCivilizationInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvCivilizationInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

//FfH: Added by Kael 08/07/2007
int CvCivilizationInfo::getCivTrait() const
{
	return m_iCivTrait;
}

int CvCivilizationInfo::getDefaultRace() const
{
	return m_iDefaultRace;
}

int CvCivilizationInfo::getHero() const
{
	return m_iHero;
}

bool CvCivilizationInfo::isMaintainFeatures(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbMaintainFeatures ? m_pbMaintainFeatures[i] : false;
}

bool CvCivilizationInfo::isNativeTerrains(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbNativeTerrains ? m_pbNativeTerrains[i] : false;
}

//FfH: End Add

bool CvCivilizationInfo::isImprovementNonDefault(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbImprovementNonDefault ? m_pbImprovementNonDefault[i] : false;
}

bool CvCivilizationInfo::isUnitRoster(int i) const
{
	FAssertMsg(i < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbUnitRoster ? m_pbUnitRoster[i] : false;
}

bool CvCivilizationInfo::canBuildImprovement(int iImprovement) const
{
	if(iImprovement == NO_IMPROVEMENT)
		return false;
	bool bDefault = GC.getImprovementInfo((ImprovementTypes)iImprovement).isDefaultBuildableAllCivs();
	if(bDefault && isImprovementNonDefault(iImprovement))
		return false;
	if(!bDefault && !isImprovementNonDefault(iImprovement))
		return false;
	return true;
}

/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
UnitClassTypes CvCivilizationInfo::getBestDefender1() const
{
    return m_eBestDefender1;
}

UnitClassTypes CvCivilizationInfo::getBestDefender2() const
{
    return m_eBestDefender2;
}

UnitClassTypes CvCivilizationInfo::getBestDefender3() const
{
    return m_eBestDefender3;
}

UnitClassTypes CvCivilizationInfo::getBestPatrol1() const
{
    return m_eBestPatrol1;
}

UnitClassTypes CvCivilizationInfo::getBestPatrol2() const
{
    return m_eBestPatrol2;
}

UnitClassTypes CvCivilizationInfo::getBestPatrol3() const
{
    return m_eBestPatrol3;
}

bool CvCivilizationInfo::isNewCiv() const
{
    return m_bNewCiv;
}

bool CvCivilizationInfo::isNoFaith() const
{
    return m_bNoFaith;
}

bool CvCivilizationInfo::isAlwaysConnectResources() const
{
	return m_bAlwaysConnectResources;
}

bool CvCivilizationInfo::isSpellResearchFromMaintainFeatures() const
{
	return m_bSpellResearchFromMaintainFeatures;
}

int CvCivilizationInfo::getReducedManaCostInGoldenAge() const
{
	return m_iReducedManaCostInGoldenAge;
}

int CvCivilizationInfo::getPopulationLimit() const
{
    return m_iPopulationLimit;
}

int CvCivilizationInfo::getImpInfrastructureHalfCost() const
{
    return m_iImpInfrastructureHalfCost;
}

int CvCivilizationInfo::getImprovementCostIncrease() const
{
	return m_iImprovementCostIncrease;
}

int CvCivilizationInfo::getNativePlane() const 
{ 
	return m_iNativePlane; 
}

int CvCivilizationInfo::getDefaultUnit() const 
{ 
	return m_iDefaultUnit; 
}

int CvCivilizationInfo::getFavoredYield() const
{
    return m_iFavoredYield;
}

int CvCivilizationInfo::getFlavorValue(int i) const
{
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

const TCHAR* CvCivilizationInfo::getFlavorScreenImage() const
{
	return m_szFlavorScreenImage;
}

const TCHAR* CvCivilizationInfo::getFlavorCityScreenImage() const
{
	return m_szFlavorCityScreenImage;
}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Arrays

int CvCivilizationInfo::getCivilizationBuildings(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationBuildings ? m_piCivilizationBuildings[i] : -1;
}

int CvCivilizationInfo::getCivilizationUnits(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationUnits ? m_piCivilizationUnits[i] : -1;
}

int CvCivilizationInfo::getCivilizationFreeUnitsClass(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationFreeUnitsClass ? m_piCivilizationFreeUnitsClass[i] : -1;
}

int CvCivilizationInfo::getCivilizationInitialCivics(int i) const
{
	FAssertMsg(i < GC.getNumCivicOptionInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCivilizationInitialCivics ? m_piCivilizationInitialCivics[i] : -1;
}

bool CvCivilizationInfo::isCivilizationAllowedCivics(int i) const
{
	FAssertMsg(i < GC.getNumCivicInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationAllowedCivics ? m_pbCivilizationAllowedCivics[i] : -1;
}

bool CvCivilizationInfo::isCivicAllowed(int eCivic) const
{
	//only check first two categories //todo move into XML
	if(GC.getCivicInfo((CivicTypes)eCivic).getCivicOptionType() > 1)
		return true;

	//do bFound temparound until all civs are implemented
	bool bFound = false;
	bool bAllowed = false;
	for(int i = 0; i < GC.getNumCivicInfos(); ++i) {
		if(isCivilizationAllowedCivics(i))
		{
			bFound = true;
			if(i == eCivic)
				bAllowed = true;
		}
	}
	if(bFound && !bAllowed)
		return false;

	return true;
}

bool CvCivilizationInfo::isLeaders(int i) const
{
	FAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbLeaders ? m_pbLeaders[i] : false;
}

bool CvCivilizationInfo::isCivilizationFreeBuildingClass(int i) const
{
	FAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationFreeBuildingClass ? m_pbCivilizationFreeBuildingClass[i] : false;
}

bool CvCivilizationInfo::isCivilizationFreeTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationFreeTechs ? m_pbCivilizationFreeTechs[i] : false;
}

bool CvCivilizationInfo::isCivilizationDisableTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbCivilizationDisableTechs ? m_pbCivilizationDisableTechs[i] : false;
}

const CvArtInfoCivilization* CvCivilizationInfo::getArtInfo() const
{
	return ARTFILEMGR.getCivilizationArtInfo( getArtDefineTag() );
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**Not entirely certain about the last few lines here, but it is safety measures to preven NULLs**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
const TCHAR* CvCivilizationInfo::getButton() const
{
	return getArtInfo()->getButton();
}
/**								----  End Original Code  ----									**/
const TCHAR* CvCivilizationInfo::getButton() const
{
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
	const CvArtInfoCivilization * pArtInfoCivilization;
	pArtInfoCivilization = getArtInfo();
	if (pArtInfoCivilization != NULL)
	{
		return getArtInfo()->getButton();
    }
	return NULL;
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

std::string CvCivilizationInfo::getCityNames(int i) const
{
	FAssertMsg(i < getNumCityNames(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paszCityNames[i];
}

int CvCivilizationInfo::getDerivativeCiv() const
{
	return m_iDerivativeCiv;
}

void CvCivilizationInfo::setDerivativeCiv(int iCiv)
{
	m_iDerivativeCiv = iCiv;
}

void CvCivilizationInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iDefaultPlayerColor);
	stream->Read(&m_iArtStyleType);
	stream->Read(&m_iUnitArtStyleType);   // FlavorUnits by Impaler[WrG]
	stream->Read(&m_iNumCityNames);
	stream->Read(&m_iNumLeaders);
	stream->Read(&m_iSelectionSoundScriptId);
	stream->Read(&m_iActionSoundScriptId);
	stream->Read(&m_iDerivativeCiv);

	stream->Read(&m_bAIPlayable);
	stream->Read(&m_bPlayable);

	stream->ReadString(m_szArtDefineTag);
	stream->ReadString(m_szShortDescriptionKey);
	stream->ReadString(m_szAdjectiveKey);

//FfH: Added by Kael 08/07/2007
	stream->Read(&m_iCivTrait);
	stream->Read(&m_iDefaultRace);
	stream->Read(&m_iHero);

	SAFE_DELETE_ARRAY(m_pbMaintainFeatures);
	m_pbMaintainFeatures = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbMaintainFeatures);
//FfH: End Add

	// Arrays

	SAFE_DELETE_ARRAY(m_piCivilizationBuildings);
	m_piCivilizationBuildings = new int[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_piCivilizationBuildings);

	SAFE_DELETE_ARRAY(m_piCivilizationUnits);
	m_piCivilizationUnits = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piCivilizationUnits);

	SAFE_DELETE_ARRAY(m_piCivilizationFreeUnitsClass);
	m_piCivilizationFreeUnitsClass = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piCivilizationFreeUnitsClass);

	SAFE_DELETE_ARRAY(m_piCivilizationInitialCivics);
	m_piCivilizationInitialCivics = new int[GC.getNumCivicOptionInfos()];
	stream->Read(GC.getNumCivicOptionInfos(), m_piCivilizationInitialCivics);

	SAFE_DELETE_ARRAY(m_pbLeaders);
	m_pbLeaders = new bool[GC.getNumLeaderHeadInfos()];
	stream->Read(GC.getNumLeaderHeadInfos(), m_pbLeaders);

	SAFE_DELETE_ARRAY(m_pbCivilizationFreeBuildingClass);
	m_pbCivilizationFreeBuildingClass = new bool[GC.getNumBuildingClassInfos()];
	stream->Read(GC.getNumBuildingClassInfos(), m_pbCivilizationFreeBuildingClass);

	SAFE_DELETE_ARRAY(m_pbCivilizationFreeTechs);
	m_pbCivilizationFreeTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbCivilizationFreeTechs);

	SAFE_DELETE_ARRAY(m_pbCivilizationDisableTechs);
	m_pbCivilizationDisableTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbCivilizationDisableTechs);

	SAFE_DELETE_ARRAY(m_paszCityNames);
	m_paszCityNames = new CvString[m_iNumCityNames];
	stream->ReadString(m_iNumCityNames, m_paszCityNames);
}

void CvCivilizationInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iDefaultPlayerColor);
	stream->Write(m_iArtStyleType);
	stream->Write(m_iUnitArtStyleType);
	stream->Write(m_iNumCityNames);
	stream->Write(m_iNumLeaders);
	stream->Write(m_iSelectionSoundScriptId);
	stream->Write(m_iActionSoundScriptId);
	stream->Write(m_iDerivativeCiv);

	stream->Write(m_bAIPlayable);
	stream->Write(m_bPlayable);

	stream->WriteString(m_szArtDefineTag);
	stream->WriteString(m_szShortDescriptionKey);
	stream->WriteString(m_szAdjectiveKey);

//FfH: Added by Kael 08/07/2007
	stream->Write(m_iCivTrait);
	stream->Write(m_iDefaultRace);
	stream->Write(m_iHero);
	stream->Write(GC.getNumFeatureInfos(), m_pbMaintainFeatures);
//FfH: End Add

	// Arrays

	stream->Write(GC.getNumBuildingClassInfos(), m_piCivilizationBuildings);
	stream->Write(GC.getNumUnitClassInfos(), m_piCivilizationUnits);
	stream->Write(GC.getNumUnitClassInfos(), m_piCivilizationFreeUnitsClass);
	stream->Write(GC.getNumCivicOptionInfos(), m_piCivilizationInitialCivics);
	stream->Write(GC.getNumLeaderHeadInfos(), m_pbLeaders);
	stream->Write(GC.getNumBuildingClassInfos(), m_pbCivilizationFreeBuildingClass);
	stream->Write(GC.getNumTechInfos(), m_pbCivilizationFreeTechs);
	stream->Write(GC.getNumTechInfos(), m_pbCivilizationDisableTechs);
	stream->WriteString(m_iNumCityNames, m_paszCityNames);
}

bool CvCivilizationInfo::read(CvXMLLoadUtility* pXML)
{
	char szClassVal[256];					// holds the text value of the relevant classinfo

	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j, iNumSibs;

	pXML->GetChildXmlValByName(m_szShortDescriptionKey, "ShortDescription");
	// Get the Text from Text/Civ4GameTextXML.xml

	pXML->GetChildXmlValByName(m_szAdjectiveKey, "Adjective");
	// Get the Text from Text/Civ4GameTextXML.xml

	pXML->GetChildXmlValByName(szTextVal, "DefaultPlayerColor");
	m_iDefaultPlayerColor = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ArtStyleType");
	m_iArtStyleType = GC.getTypesEnum(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "UnitArtStyleType");
	m_iUnitArtStyleType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "CivilizationSelectionSound");
	m_iSelectionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;
	pXML->GetChildXmlValByName(szTextVal, "CivilizationActionSound");
	m_iActionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;

	// set the current xml node to it's next sibling and then
	pXML->GetChildXmlValByName(&m_bPlayable, "bPlayable");
	pXML->GetChildXmlValByName(&m_bAIPlayable, "bAIPlayable");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Cities"))
	{
		pXML->SetStringList(&m_paszCityNames, &m_iNumCityNames);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Buildings"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default civilization buildings
			pXML->InitBuildingDefaults(&m_piCivilizationBuildings);
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ( (0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())) )
			{
				int iBuildingClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumBuildingClassInfos()) ,"In SetGlobalCivilizationInfo iNumSibs is greater than GC.getNumBuildingClassInfos()");

				// loop through all the siblings
				for (j=0;j<iNumSibs;j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// get the index into the array based on the building class type
						iBuildingClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iBuildingClassIndex)
						{
							// get the next value which should be the building type to set this civilization's version of this building class too
							pXML->GetNextXmlVal( szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_piCivilizationBuildings[iBuildingClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0,"BuildingClass index is -1 in SetGlobalCivilizationInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		Quickly adjusted to account for bUnique tag, should work as now written, but untested	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitBuildingDefaults(&m_piCivilizationBuildings);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Units"))
	{
		// pXML->Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// call the function that sets the default civilization buildings
			pXML->InitUnitDefaults(&m_piCivilizationUnits);
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			// if the call to the function that sets the current xml node to it's first non-comment
			// child and sets the parameter with the new node's value succeeds
			if ( (0 < iNumSibs) && (gDLL->getXMLIFace()->SetToChild(pXML->GetXML())) )
			{
				int iUnitClassIndex;

				FAssertMsg((iNumSibs <= GC.getNumUnitClassInfos()),"In SetGlobalCivilizationInfo iNumSibs is greater than GC.getNumUnitClassInfos()");

				// loop through all the siblings
				for (j=0;j<iNumSibs;j++)
				{
					if (pXML->GetChildXmlVal(szClassVal))
					{
						// set the unit class index
						iUnitClassIndex = pXML->FindInInfoClass(szClassVal);
						if (-1 < iUnitClassIndex)
						{
							// get the next value which should be the building type to set this civilization's version of this building class too
							pXML->GetNextXmlVal( szTextVal);
							// call the find in list function to return either -1 if no value is found
							// or the index in the list the match is found at
							m_piCivilizationUnits[iUnitClassIndex] = pXML->FindInInfoClass(szTextVal);
						}
						else
						{
							FAssertMsg(0, "UnitClass index is -1 in SetGlobalCivilizationInfo function");
						}

						// set the current xml node to it's parent node
						gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
					}

					// if the call to the function that sets the current xml node to it's first non-comment
					// sibling and sets the parameter with the new node's value does not succeed
					// we will break out of this for loop
					if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
					{
						break;
					}
				}

				// set the current xml node to it's parent node
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**		Quickly adjusted to account for bUnique tag, should work as now written, but untested	**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitUnitDefaults(&m_piCivilizationUnits);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piCivilizationFreeUnitsClass, "FreeUnitClasses", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos());

	pXML->SetVariableListTagPair(&m_pbCivilizationFreeBuildingClass, "FreeBuildingClasses", sizeof(GC.getBuildingClassInfo((BuildingClassTypes)0)), GC.getNumBuildingClassInfos());

	pXML->SetVariableListTagPair(&m_pbCivilizationFreeTechs, "FreeTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
	pXML->SetVariableListTagPair(&m_pbCivilizationDisableTechs, "DisableTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"InitialCivics"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			pXML->InitList(&m_piCivilizationInitialCivics, GC.getNumCivicOptionInfos());

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNumCivicOptionInfos()),"For loop iterator is greater than array size");
					for (j=0;j<iNumSibs;j++)
					{
						m_piCivilizationInitialCivics[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piCivilizationInitialCivics, GC.getNumCivicOptionInfos());
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_pbCivilizationAllowedCivics, "AllowedCivics", sizeof(GC.getCivicInfo((CivicTypes)0)), GC.getNumCivicInfos());

	pXML->SetVariableListTagPair(&m_pbLeaders, "Leaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());

	pXML->GetChildXmlValByName(szTextVal, "CivilizationSelectionSound");

//FfH: Added by Kael 08/06/2007
	pXML->GetChildXmlValByName(szTextVal, "CivTrait");
	m_iCivTrait = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DefaultRace");
	m_iDefaultRace = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "Hero");
	m_iHero = GC.getInfoTypeForString(szTextVal);
	pXML->SetVariableListTagPair(&m_pbMaintainFeatures, "MaintainFeatures", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_pbNativeTerrains, "NativeTerrains", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbImprovementNonDefault, "ImprovementNonDefaults", sizeof(GC.getImprovementInfo((ImprovementTypes)0)), GC.getNumImprovementInfos());	
	pXML->SetVariableListTagPair(&m_pbUnitRoster, "UnitRoster", sizeof(GC.getUnitInfo((UnitTypes)0)), GC.getNumUnitInfos());	
//FfH: End Add
/*************************************************************************************************/
/**	BETTER AI (New Definitions) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "eBestDefender1", "UNITCLASS_ARCHER");
	m_eBestDefender1 = (UnitClassTypes)GC.getInfoTypeForString(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "eBestDefender2", "UNITCLASS_LONGBOWMAN");
	m_eBestDefender2 = (UnitClassTypes)GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "eBestDefender3", "UNITCLASS_ARQUEBUS");
	m_eBestDefender3 = (UnitClassTypes)GC.getInfoTypeForString(szTextVal);

    pXML->GetChildXmlValByName(szTextVal, "eBestPatrol1", "UNITCLASS_HUNTER");
	m_eBestPatrol1 = (UnitClassTypes)GC.getInfoTypeForString(szTextVal);
    pXML->GetChildXmlValByName(szTextVal, "eBestPatrol2", "UNITCLASS_RANGER");
	m_eBestPatrol2 = (UnitClassTypes)GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "eBestPatrol3");
	m_eBestPatrol3 = (UnitClassTypes)GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(&m_bNewCiv, "bNewCiv",false);
	pXML->GetChildXmlValByName(&m_bNoFaith, "bNoFaith",false);
	pXML->GetChildXmlValByName(&m_bAlwaysConnectResources, "bAlwaysConnectResources",false);	
	pXML->GetChildXmlValByName(&m_bSpellResearchFromMaintainFeatures, "bSpellResearchFromMaintainFeatures",false);		
	pXML->GetChildXmlValByName(&m_iReducedManaCostInGoldenAge, "iReducedManaCostInGoldenAge");		
	pXML->GetChildXmlValByName(&m_iPopulationLimit, "iPopulationLimit",-1);
	pXML->GetChildXmlValByName(&m_iImprovementCostIncrease, "ImprovementCostIncrease", 0);
	pXML->GetChildXmlValByName(szTextVal, "ImpInfrastructureHalfCost");
	m_iImpInfrastructureHalfCost = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FavoredYield");
	m_iFavoredYield = GC.getInfoTypeForString(szTextVal);
	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());
	
	pXML->GetChildXmlValByName(szTextVal, "NativePlane");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DefaultUnit");
	m_iDefaultUnit = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(m_szFlavorScreenImage, "FlavorScreenImage");
	pXML->GetChildXmlValByName(m_szFlavorCityScreenImage, "FlavorCityScreenImage");
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}

bool CvCivilizationInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "DerivativeCiv");
	m_iDerivativeCiv = GC.getInfoTypeForString(szTextVal);

	return true;
}

bool CvCivilizationInfo::readPass3()
{
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iNativePlane = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
	m_aszExtraXMLforPass3.clear();
	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(CivilizationInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCivilizationInfo::copyNonDefaults(CvCivilizationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()							== cDefault)			setArtDefineTag(						pClassInfo->getArtDefineTag());
	//Must set the Art Define before doing the Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isPlayable()								== false)				m_bPlayable								= (pClassInfo->isPlayable());
	if (isAIPlayable()								== false)				m_bAIPlayable							= (pClassInfo->isAIPlayable());
	if (getShortDescriptionKey()					== wDefault)			m_szShortDescriptionKey					= pClassInfo->getShortDescriptionKey();
	if (getAdjectiveKey()							== wDefault)			m_szAdjectiveKey						= pClassInfo->getAdjectiveKey();
	if (getHero()									== NO_UNIT)				m_iHero									= (pClassInfo->getHero());
	if (getCivTrait()								== NO_TRAIT)			m_iCivTrait								= (pClassInfo->getCivTrait());
	if (getArtStyleType()							== NO_ARTSTYLE)			m_iArtStyleType							= (pClassInfo->getArtStyleType());
	if (getDefaultRace()							== NO_PROMOTION)		m_iDefaultRace							= (pClassInfo->getDefaultRace());
	if (getSelectionSoundScriptId()					== AUDIOTAG_NONE)		m_iSelectionSoundScriptId				= (pClassInfo->getSelectionSoundScriptId());
	if (getActionSoundScriptId()					== AUDIOTAG_NONE)		m_iActionSoundScriptId					= (pClassInfo->getActionSoundScriptId());
	if (getDefaultPlayerColor()						== NO_PLAYERCOLOR)		m_iDefaultPlayerColor					= (pClassInfo->getDefaultPlayerColor());
	if (getUnitArtStyleType()						== NO_UNIT_ARTSTYLE)	m_iUnitArtStyleType						= (pClassInfo->getUnitArtStyleType());

	//NEED A MASSIVE RE-WRITE IN HERE FOR FINDING DEFAULT BUILDINGS
	for ( int i = 0; i < GC.getNumBuildingClassInfos(); i++)
	{
		int iDefaultBuilding = GC.getBuildingClassInfo((BuildingClassTypes) i).getDefaultBuildingIndex();
		if (getCivilizationBuildings(i)				== iDefaultBuilding)	m_piCivilizationBuildings[i]			= pClassInfo->getCivilizationBuildings(i);
		if (isCivilizationFreeBuildingClass(i)		== false)				m_pbCivilizationFreeBuildingClass[i]	= pClassInfo->isCivilizationFreeBuildingClass(i);
	}
	for ( int i = 0; i < GC.getNumUnitClassInfos(); i++)
	{
		int iDefaultUnit = GC.getUnitClassInfo((UnitClassTypes) i).getDefaultUnitIndex();
		if (getCivilizationUnits(i)					== iDefaultUnit)		m_piCivilizationUnits[i]				= pClassInfo->getCivilizationUnits(i);
		if (getCivilizationFreeUnitsClass(i)		== 0)					m_piCivilizationFreeUnitsClass[i]		= pClassInfo->getCivilizationFreeUnitsClass(i);
	}
	for ( int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if (isCivilizationFreeTechs(i)				== false)				m_pbCivilizationFreeTechs[i]			= pClassInfo->isCivilizationFreeTechs(i);
		if (isCivilizationDisableTechs(i)			== false)				m_pbCivilizationDisableTechs[i]			= pClassInfo->isCivilizationDisableTechs(i);
	}
	for ( int i = 0; i < GC.getNumCivicOptionInfos(); i++)
	{
		if (getCivilizationInitialCivics(i)			== 0)					m_piCivilizationInitialCivics[i]		= pClassInfo->getCivilizationInitialCivics(i);
	}
	for ( int i = 0; i < GC.getNumCivicInfos(); i++)
	{
		if (isCivilizationAllowedCivics(i)			== false)					m_pbCivilizationAllowedCivics[i]		= pClassInfo->isCivilizationAllowedCivics(i);
	}
	for ( int i = 0; i < GC.getNumLeaderHeadInfos(); i++)
	{
		if (isLeaders(i)							== false)				m_pbLeaders[i]							= pClassInfo->isLeaders(i);
	}
	for (int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if (isMaintainFeatures(i)					== false)				m_pbMaintainFeatures[i]					= pClassInfo->isMaintainFeatures(i);
	}

	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (isNativeTerrains(i)					== false)				m_pbNativeTerrains[i]					= pClassInfo->isNativeTerrains(i);
	}

	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		if (isImprovementNonDefault(i)			== false)				m_pbImprovementNonDefault[i]			= pClassInfo->isImprovementNonDefault(i);
	}

	for (int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		if (isUnitRoster(i)			== false)				m_pbUnitRoster[i]			= pClassInfo->isUnitRoster(i);
	}

	if (getBestDefender1()							== NO_UNITCLASS)		m_eBestDefender1						= pClassInfo->getBestDefender1();
	if (getBestDefender2()							== NO_UNITCLASS)		m_eBestDefender2						= pClassInfo->getBestDefender2();
	if (getBestDefender3()							== NO_UNITCLASS)		m_eBestDefender3						= pClassInfo->getBestDefender3();

	if (getBestPatrol1()							== NO_UNITCLASS)		m_eBestPatrol1						    = pClassInfo->getBestPatrol1();
	if (getBestPatrol2()							== NO_UNITCLASS)		m_eBestPatrol2						    = pClassInfo->getBestPatrol2();
	if (getBestPatrol3()							== NO_UNITCLASS)		m_eBestPatrol3						    = pClassInfo->getBestPatrol3();

	if (isNewCiv()      							== false)	        	m_bNewCiv   						    = pClassInfo->isNewCiv();
	if (isNoFaith()      							== false)	        	m_bNoFaith   						    = pClassInfo->isNoFaith();
	if (isAlwaysConnectResources() 					== false)	        	m_bAlwaysConnectResources			    = pClassInfo->isAlwaysConnectResources();
	if (isSpellResearchFromMaintainFeatures()		== false)	        	m_bSpellResearchFromMaintainFeatures    = pClassInfo->isSpellResearchFromMaintainFeatures();	
	if (getReducedManaCostInGoldenAge()				== false)	        	m_iReducedManaCostInGoldenAge			= pClassInfo->getReducedManaCostInGoldenAge();	
	
	if (getPopulationLimit()      					== -1)	        	    m_iPopulationLimit  				    = pClassInfo->getPopulationLimit();
	if (getImprovementCostIncrease()                == 0)                   m_iImprovementCostIncrease              = pClassInfo->getImprovementCostIncrease();
	if (getImpInfrastructureHalfCost()      		== NO_IMPROVEMENT) 	    m_iImpInfrastructureHalfCost  			= pClassInfo->getImpInfrastructureHalfCost();
	if (getNativePlane()							== NO_PLANE)			m_iNativePlane							= pClassInfo->getNativePlane();
	if (getDefaultUnit()							== NO_UNIT)			m_iNativePlane								= pClassInfo->getDefaultUnit();
	if (getFavoredYield()      						== NO_YIELD) 			m_iFavoredYield  						= pClassInfo->getFavoredYield();
	if (getFlavorScreenImage()						== cDefault)			m_szFlavorScreenImage					= pClassInfo->getFlavorScreenImage();
	if (getFlavorCityScreenImage()					== cDefault)			m_szFlavorCityScreenImage				= pClassInfo->getFlavorCityScreenImage();


	for(int i = 0; i < GC.getNumFlavorTypes(); i++)
	{
		if(getFlavorValue(i)						== 0)					m_piFlavorValue[i]						= pClassInfo->getFlavorValue(i);
	}

	// First we check if there are different Unique Names in the Modules(we want to keep all of them)
	// So we have to set the Arraysize properly, knowing the amount of Unique Names
	if ( pClassInfo->getNumCityNames() != 0 )
	{
		CvString* m_paszOldNames = new CvString[pClassInfo->getNumCityNames()];
		for ( int i = 0; i < pClassInfo->getNumCityNames(); i++)
		{
																			m_paszOldNames[i]						= pClassInfo->getCityNames(i);
		}
		CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
		pCurrentUnitClass->StringArrayExtend(&m_paszCityNames, &m_iNumCityNames, &m_paszOldNames, pClassInfo->getNumCityNames());
		SAFE_DELETE_ARRAY(m_paszOldNames)
	}

	// Readpass2 stuff
	if (getDerivativeCiv()							== NO_CIVILIZATION)		m_iDerivativeCiv						= pClassInfo->getDerivativeCiv();
}

void CvCivilizationInfo::copyNonDefaultsReadPass2(CvCivilizationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getDerivativeCiv()		!= -1)					m_iDerivativeCiv						= pClassInfo->getDerivativeCiv();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/



//======================================================================================================
//					CvVictoryInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvVictoryInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvVictoryInfo::CvVictoryInfo() :
m_iPopulationPercentLead(0),
m_iLandPercent(0),
m_iMinLandPercent(0),
m_iReligionPercent(0),
m_iCityCulture(0),
m_iNumCultureCities(0),
m_iTotalCultureRatio(0),
m_iVictoryDelayTurns(0),
m_bTargetScore(false),
m_bEndScore(false),
m_bConquest(false),
m_bDiploVote(false),
m_bPermanent(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvVictoryInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvVictoryInfo::~CvVictoryInfo()
{
}

int CvVictoryInfo::getPopulationPercentLead() const
{
	return m_iPopulationPercentLead;
}

int CvVictoryInfo::getLandPercent() const
{
	return m_iLandPercent;
}

int CvVictoryInfo::getMinLandPercent() const
{
	return m_iMinLandPercent;
}

int CvVictoryInfo::getReligionPercent() const
{
	return m_iReligionPercent;
}

int CvVictoryInfo::getCityCulture() const
{
	return m_iCityCulture;
}

int CvVictoryInfo::getNumCultureCities() const
{
	return m_iNumCultureCities;
}

int CvVictoryInfo::getTotalCultureRatio() const
{
	return m_iTotalCultureRatio;
}

int CvVictoryInfo::getVictoryDelayTurns() const
{
	return m_iVictoryDelayTurns;
}

bool CvVictoryInfo::isTargetScore() const
{
	return m_bTargetScore;
}

bool CvVictoryInfo::isEndScore() const
{
	return m_bEndScore;
}

bool CvVictoryInfo::isConquest() const
{
	return m_bConquest;
}

bool CvVictoryInfo::isDiploVote() const
{
	return m_bDiploVote;
}

bool CvVictoryInfo::isPermanent() const
{
	return m_bPermanent;
}

const char* CvVictoryInfo::getMovie() const
{
	return m_szMovie;
}


//
// read from xml
//
bool CvVictoryInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bTargetScore, "bTargetScore");
	pXML->GetChildXmlValByName(&m_bEndScore, "bEndScore");
	pXML->GetChildXmlValByName(&m_bConquest, "bConquest");
	pXML->GetChildXmlValByName(&m_bDiploVote, "bDiploVote");
	pXML->GetChildXmlValByName(&m_bPermanent, "bPermanent");
	pXML->GetChildXmlValByName(&m_iPopulationPercentLead, "iPopulationPercentLead");
	pXML->GetChildXmlValByName(&m_iLandPercent, "iLandPercent");
	pXML->GetChildXmlValByName(&m_iMinLandPercent, "iMinLandPercent");
	pXML->GetChildXmlValByName(&m_iReligionPercent, "iReligionPercent");

	pXML->GetChildXmlValByName(szTextVal, "CityCulture");
	m_iCityCulture = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iNumCultureCities, "iNumCultureCities");
	pXML->GetChildXmlValByName(&m_iTotalCultureRatio, "iTotalCultureRatio");
	pXML->GetChildXmlValByName(&m_iVictoryDelayTurns, "iVictoryDelayTurns");
	pXML->GetChildXmlValByName(m_szMovie, "VictoryMovie");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(VictoryInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvVictoryInfo::copyNonDefaults(CvVictoryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isTargetScore()				== false)				m_bTargetScore				= pClassInfo->isTargetScore();
	if (isEndScore()				== false)				m_bEndScore					= pClassInfo->isEndScore();
	if (isConquest()				== false)				m_bConquest					= pClassInfo->isConquest();
	if (isDiploVote()				== false)				m_bDiploVote				= pClassInfo->isDiploVote();
	if (isPermanent()				== false)				m_bPermanent				= pClassInfo->isPermanent();
	if (getPopulationPercentLead()	== 0)					m_iPopulationPercentLead	= pClassInfo->getPopulationPercentLead();
	if (getLandPercent()			== 0)					m_iLandPercent				= pClassInfo->getLandPercent();
	if (getMinLandPercent()			== 0)					m_iMinLandPercent			= pClassInfo->getMinLandPercent();
	if (getReligionPercent()		== 0)					m_iReligionPercent			= pClassInfo->getReligionPercent();
	if (getCityCulture()			== NO_CULTURELEVEL)		m_iCityCulture				= pClassInfo->getCityCulture();
	if (getNumCultureCities()		== 0)					m_iNumCultureCities			= pClassInfo->getNumCultureCities();
	if (getTotalCultureRatio()		== 0)					m_iTotalCultureRatio		= pClassInfo->getTotalCultureRatio();
	if (getVictoryDelayTurns()		== 0)					m_iVictoryDelayTurns		= pClassInfo->getVictoryDelayTurns();
	if (getMovie()					== cDefault)			m_szMovie					= pClassInfo->getMovie();

	//Readpass2 stuff
}
void CvVictoryInfo::copyNonDefaultsReadPass2(CvVictoryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvHurryInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvHurryInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvHurryInfo::CvHurryInfo() :
m_iGoldPerProduction(0),
m_iStonePerProduction(0),
m_iProductionPerPopulation(0),
m_bAnger(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvHurryInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvHurryInfo::~CvHurryInfo()
{
}

int CvHurryInfo::getGoldPerProduction() const
{
	return m_iGoldPerProduction;
}

int CvHurryInfo::getStonePerProduction() const
{
	return m_iStonePerProduction;
}

int CvHurryInfo::getProductionPerPopulation() const
{
	return m_iProductionPerPopulation;
}

bool CvHurryInfo::isAnger() const
{
	return m_bAnger;
}

bool CvHurryInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iGoldPerProduction, "iGoldPerProduction");
	pXML->GetChildXmlValByName(&m_iStonePerProduction, "iStonePerProduction");
	pXML->GetChildXmlValByName(&m_iProductionPerPopulation, "iProductionPerPopulation");

	pXML->GetChildXmlValByName(&m_bAnger, "bAnger");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvHurryInfo::copyNonDefaults(CvHurryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getStonePerProduction()			== 0)		m_iStonePerProduction		= pClassInfo->getStonePerProduction();
	if (getGoldPerProduction()			== 0)		m_iGoldPerProduction		= pClassInfo->getGoldPerProduction();
	if (getProductionPerPopulation()	== 0)		m_iProductionPerPopulation	= pClassInfo->getProductionPerPopulation();
	if (isAnger()						== false)	m_bAnger					= pClassInfo->isAnger();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
//======================================================================================================
//					CvHandicapInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvHandicapInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvHandicapInfo::CvHandicapInfo() :
m_iFreeWinsVsBarbs(0),
m_iAnimalAttackProb(0),
m_iStartingLocationPercent(0),
m_iAdvancedStartPointsMod(0),
m_iStartingGold(0),
m_iFreeUnits(0),
m_iUnitCostPercent(0),
m_iResearchPercent(0),
m_iDistanceMaintenancePercent(0),
m_iNumCitiesMaintenancePercent(0),
m_iMaxNumCitiesMaintenance(0),
m_iColonyMaintenancePercent(0),
m_iMaxColonyMaintenance(0),
m_iCorporationMaintenancePercent(0),
m_iCivicUpkeepPercent(0),
m_iInflationPercent(0),
m_iHealthBonus(0),
m_iHappyBonus(0),
m_iAttitudeChange(0),
m_iNoTechTradeModifier(0),
m_iTechTradeKnownModifier(0),
m_iUnownedTilesPerGameAnimal(0),
m_iUnownedTilesPerBarbarianUnit(0),
m_iUnownedWaterTilesPerBarbarianUnit(0),
m_iUnownedTilesPerBarbarianCity(0),
m_iBarbarianCreationTurnsElapsed(0),
m_iBarbarianCityCreationTurnsElapsed(0),
m_iBarbarianCityCreationProb(0),
m_iAnimalCombatModifier(0),
m_iBarbarianCombatModifier(0),
m_iAIAnimalCombatModifier(0),
m_iAIBarbarianCombatModifier(0),
m_iStartingDefenseUnits(0),
m_iStartingWorkerUnits(0),
m_iStartingExploreUnits(0),
m_iAIStartingUnitMultiplier(0),
m_iAIStartingDefenseUnits(0),
m_iAIStartingWorkerUnits(0),
m_iAIStartingExploreUnits(0),
m_iBarbarianInitialDefenders(0),
m_iAIDeclareWarProb(0),
m_iAIWorkRateModifier(0),
m_iAIGrowthPercent(0),
m_iAITrainPercent(0),
m_iAIWorldTrainPercent(0),
m_iAIConstructPercent(0),
m_iAIWorldConstructPercent(0),
m_iAICreatePercent(0),
m_iAIWorldCreatePercent(0),
m_iAICivicUpkeepPercent(0),
m_iAIUnitCostPercent(0),
m_iAIUnitSupplyPercent(0),
m_iAIUnitSupportBonusPercent(0),
m_iAIUnitUpgradePercent(0),
m_iAIInflationPercent(0),
m_iAIWarWearinessPercent(0),
m_iAIPerEraModifier(0),
m_iAIAdvancedStartPercent(0),
m_iNumGoodies(0),
m_piGoodies(NULL),
m_pbFreeTechs(NULL),
m_pbAIFreeTechs(NULL),

//FfH Improvements: Added by Kael 08/07/2007
m_iAIFreeXP(0),
m_iLairSpawnRate(0)
//FfH: End Add

/*************************************************************************************************/
/**	New Gameoption (Handicap Mana) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
,m_iFreeBonusMana(0)
/** new tags **/
,m_iAICombatOddsCapped(100)
,m_iAIFreeNobleHouseSupportModifier(0)
,m_iAIManaModifier(0)
,m_iAIFreeHappinessInterval(0)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvHandicapInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvHandicapInfo::~CvHandicapInfo()
{
	SAFE_DELETE_ARRAY(m_piGoodies);
	SAFE_DELETE_ARRAY(m_pbFreeTechs);
	SAFE_DELETE_ARRAY(m_pbAIFreeTechs);
}

int CvHandicapInfo::getFreeWinsVsBarbs() const
{
	return m_iFreeWinsVsBarbs;
}

int CvHandicapInfo::getAnimalAttackProb() const
{
	return m_iAnimalAttackProb;
}

int CvHandicapInfo::getStartingLocationPercent() const
{
	return m_iStartingLocationPercent;
}

int CvHandicapInfo::getAdvancedStartPointsMod() const
{
	return m_iAdvancedStartPointsMod;
}

int CvHandicapInfo::getStartingGold() const
{
	return m_iStartingGold;
}

int CvHandicapInfo::getFreeUnits() const
{
	return m_iFreeUnits;
}

int CvHandicapInfo::getUnitCostPercent() const
{
	return m_iUnitCostPercent;
}

int CvHandicapInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvHandicapInfo::getDistanceMaintenancePercent() const
{
	return m_iDistanceMaintenancePercent;
}

int CvHandicapInfo::getNumCitiesMaintenancePercent() const
{
	return m_iNumCitiesMaintenancePercent;
}

int CvHandicapInfo::getMaxNumCitiesMaintenance() const
{
	return m_iMaxNumCitiesMaintenance;
}

int CvHandicapInfo::getColonyMaintenancePercent() const
{
	return m_iColonyMaintenancePercent;
}

int CvHandicapInfo::getMaxColonyMaintenance() const
{
	return m_iMaxColonyMaintenance;
}

int CvHandicapInfo::getCorporationMaintenancePercent() const
{
	return m_iCorporationMaintenancePercent;
}

int CvHandicapInfo::getCivicUpkeepPercent() const
{
	return m_iCivicUpkeepPercent;
}

int CvHandicapInfo::getInflationPercent() const
{
	return m_iInflationPercent;
}

int CvHandicapInfo::getHealthBonus() const
{
	return m_iHealthBonus;
}

int CvHandicapInfo::getHappyBonus() const
{
	return m_iHappyBonus;
}

int CvHandicapInfo::getAttitudeChange() const
{
	return m_iAttitudeChange;
}

int CvHandicapInfo::getNoTechTradeModifier() const
{
	return m_iNoTechTradeModifier;
}

int CvHandicapInfo::getTechTradeKnownModifier() const
{
	return m_iTechTradeKnownModifier;
}

int CvHandicapInfo::getUnownedTilesPerGameAnimal() const
{
	return m_iUnownedTilesPerGameAnimal;
}

int CvHandicapInfo::getUnownedTilesPerBarbarianUnit() const
{
	return m_iUnownedTilesPerBarbarianUnit;
}

int CvHandicapInfo::getUnownedWaterTilesPerBarbarianUnit() const
{
	return m_iUnownedWaterTilesPerBarbarianUnit;
}

int CvHandicapInfo::getUnownedTilesPerBarbarianCity() const
{
	return m_iUnownedTilesPerBarbarianCity;
}

int CvHandicapInfo::getBarbarianCreationTurnsElapsed() const
{
	return m_iBarbarianCreationTurnsElapsed;
}

int CvHandicapInfo::getBarbarianCityCreationTurnsElapsed() const
{
	return m_iBarbarianCityCreationTurnsElapsed;
}

int CvHandicapInfo::getBarbarianCityCreationProb() const
{
	return m_iBarbarianCityCreationProb;
}

int CvHandicapInfo::getAnimalCombatModifier() const
{
	return m_iAnimalCombatModifier;
}

int CvHandicapInfo::getBarbarianCombatModifier() const
{
	return m_iBarbarianCombatModifier;
}

int CvHandicapInfo::getAIAnimalCombatModifier() const
{
	return m_iAIAnimalCombatModifier;
}

int CvHandicapInfo::getAIBarbarianCombatModifier() const
{
	return m_iAIBarbarianCombatModifier;
}

int CvHandicapInfo::getStartingDefenseUnits() const
{
	return m_iStartingDefenseUnits;
}

int CvHandicapInfo::getStartingWorkerUnits() const
{
	return m_iStartingWorkerUnits;
}

int CvHandicapInfo::getStartingExploreUnits() const
{
	return m_iStartingExploreUnits;
}

int CvHandicapInfo::getAIStartingUnitMultiplier() const
{
	return m_iAIStartingUnitMultiplier;
}

int CvHandicapInfo::getAIStartingDefenseUnits() const
{
	return m_iAIStartingDefenseUnits;
}

int CvHandicapInfo::getAIStartingWorkerUnits() const
{
	return m_iAIStartingWorkerUnits;
}

int CvHandicapInfo::getAIStartingExploreUnits() const
{
	return m_iAIStartingExploreUnits;
}

int CvHandicapInfo::getBarbarianInitialDefenders() const
{
	return m_iBarbarianInitialDefenders;
}

int CvHandicapInfo::getAIDeclareWarProb() const
{
	return m_iAIDeclareWarProb;
}

int CvHandicapInfo::getAIWorkRateModifier() const
{
	return m_iAIWorkRateModifier;
}

int CvHandicapInfo::getAIGrowthPercent() const
{
	return m_iAIGrowthPercent;
}

int CvHandicapInfo::getAITrainPercent() const
{
	return m_iAITrainPercent;
}

int CvHandicapInfo::getAIWorldTrainPercent() const
{
	return m_iAIWorldTrainPercent;
}

int CvHandicapInfo::getAIConstructPercent() const
{
	return m_iAIConstructPercent;
}

int CvHandicapInfo::getAIWorldConstructPercent() const
{
	return m_iAIWorldConstructPercent;
}

int CvHandicapInfo::getAICreatePercent() const
{
	return m_iAICreatePercent;
}

int CvHandicapInfo::getAIWorldCreatePercent() const
{
	return m_iAIWorldCreatePercent;
}

int CvHandicapInfo::getAICivicUpkeepPercent() const
{
	return m_iAICivicUpkeepPercent;
}

int CvHandicapInfo::getAIUnitCostPercent() const
{
	return m_iAIUnitCostPercent;
}

int CvHandicapInfo::getAIUnitSupplyPercent() const
{
	return m_iAIUnitSupplyPercent;
}

int CvHandicapInfo::getAIUnitSupportBonusPercent() const
{
	return m_iAIUnitSupportBonusPercent;
}

int CvHandicapInfo::getAIUnitUpgradePercent() const
{
	return m_iAIUnitUpgradePercent;
}

int CvHandicapInfo::getAIInflationPercent() const
{
	return m_iAIInflationPercent;
}

int CvHandicapInfo::getAIWarWearinessPercent() const
{
	return m_iAIWarWearinessPercent;
}

int CvHandicapInfo::getAIPerEraModifier() const
{
	return m_iAIPerEraModifier;
}

int CvHandicapInfo::getAIAdvancedStartPercent() const
{
	return m_iAIAdvancedStartPercent;
}

int CvHandicapInfo::getNumGoodies() const
{
	return m_iNumGoodies;
}

//FfH Improvements: Added by Kael 08/07/2007
int CvHandicapInfo::getAIFreeXP() const
{
	return m_iAIFreeXP;
}

int CvHandicapInfo::getLairSpawnRate() const
{
	return m_iLairSpawnRate;
}
//FfH: End Add

/*************************************************************************************************/
/**	New Gameoption (Handicap Mana) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
int CvHandicapInfo::getFreeBonusMana() const
{
	return m_iFreeBonusMana;
}

int CvHandicapInfo::getAICombatOddsCapped() const
{
	return m_iAICombatOddsCapped;
}

int CvHandicapInfo::getAIFreeNobleHouseSupportModifier() const
{
    return m_iAIFreeNobleHouseSupportModifier;
}

int CvHandicapInfo::getAIManaModifier() const
{
    return m_iAIManaModifier;
}

int CvHandicapInfo::getAIFreeHappinessInterval() const
{
    return m_iAIFreeHappinessInterval;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Arrays

int CvHandicapInfo::getGoodies(int i) const
{
	FAssertMsg(i < getNumGoodies(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piGoodies[i];
}

int CvHandicapInfo::isFreeTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFreeTechs[i];
}

int CvHandicapInfo::isAIFreeTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbAIFreeTechs[i];
}

void CvHandicapInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// Flag for Expansion

	stream->Read(&m_iFreeWinsVsBarbs);
	stream->Read(&m_iAnimalAttackProb);
	stream->Read(&m_iStartingLocationPercent);
	stream->Read(&m_iAdvancedStartPointsMod);
	stream->Read(&m_iStartingGold);
	stream->Read(&m_iFreeUnits);
	stream->Read(&m_iUnitCostPercent);
	stream->Read(&m_iResearchPercent);
	stream->Read(&m_iDistanceMaintenancePercent);
	stream->Read(&m_iNumCitiesMaintenancePercent);
	stream->Read(&m_iMaxNumCitiesMaintenance);
	stream->Read(&m_iColonyMaintenancePercent);
	stream->Read(&m_iMaxColonyMaintenance);
	stream->Read(&m_iCorporationMaintenancePercent);
	stream->Read(&m_iCivicUpkeepPercent);
	stream->Read(&m_iInflationPercent);
	stream->Read(&m_iHealthBonus);
	stream->Read(&m_iHappyBonus);
	stream->Read(&m_iAttitudeChange);
	stream->Read(&m_iNoTechTradeModifier);
	stream->Read(&m_iTechTradeKnownModifier);
	stream->Read(&m_iUnownedTilesPerGameAnimal);
	stream->Read(&m_iUnownedTilesPerBarbarianUnit);
	stream->Read(&m_iUnownedWaterTilesPerBarbarianUnit);
	stream->Read(&m_iUnownedTilesPerBarbarianCity);
	stream->Read(&m_iBarbarianCreationTurnsElapsed);
	stream->Read(&m_iBarbarianCityCreationTurnsElapsed);
	stream->Read(&m_iBarbarianCityCreationProb);
	stream->Read(&m_iAnimalCombatModifier);
	stream->Read(&m_iBarbarianCombatModifier);
	stream->Read(&m_iAIAnimalCombatModifier);
	stream->Read(&m_iAIBarbarianCombatModifier);

	stream->Read(&m_iStartingDefenseUnits);
	stream->Read(&m_iStartingWorkerUnits);
	stream->Read(&m_iStartingExploreUnits);
	stream->Read(&m_iAIStartingUnitMultiplier);
	stream->Read(&m_iAIStartingDefenseUnits);
	stream->Read(&m_iAIStartingWorkerUnits);
	stream->Read(&m_iAIStartingExploreUnits);
	stream->Read(&m_iBarbarianInitialDefenders);
	stream->Read(&m_iAIDeclareWarProb);
	stream->Read(&m_iAIWorkRateModifier);
	stream->Read(&m_iAIGrowthPercent);
	stream->Read(&m_iAITrainPercent);
	stream->Read(&m_iAIWorldTrainPercent);
	stream->Read(&m_iAIConstructPercent);
	stream->Read(&m_iAIWorldConstructPercent);
	stream->Read(&m_iAICreatePercent);
	stream->Read(&m_iAIWorldCreatePercent);
	stream->Read(&m_iAICivicUpkeepPercent);
	stream->Read(&m_iAIUnitCostPercent);
	stream->Read(&m_iAIUnitSupplyPercent);
	stream->Read(&m_iAIUnitUpgradePercent);
	stream->Read(&m_iAIInflationPercent);
	stream->Read(&m_iAIWarWearinessPercent);
	stream->Read(&m_iAIPerEraModifier);
	stream->Read(&m_iAIAdvancedStartPercent);
	stream->Read(&m_iNumGoodies);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Read(&m_iAIFreeXP);
	stream->Read(&m_iLairSpawnRate);
//FfH: End Add
/*************************************************************************************************/
/**	New Gameoption (Handicap Mana) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
    stream->Read(&m_iFreeBonusMana);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	stream->ReadString(m_szHandicapName);

	// Arrays

	SAFE_DELETE_ARRAY(m_piGoodies);
	m_piGoodies = new int[getNumGoodies()];
	stream->Read(getNumGoodies(), m_piGoodies);

	SAFE_DELETE_ARRAY(m_pbFreeTechs);
	m_pbFreeTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbFreeTechs);

	SAFE_DELETE_ARRAY(m_pbAIFreeTechs);
	m_pbAIFreeTechs = new bool[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_pbAIFreeTechs);
}

void CvHandicapInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// Flag for Expansion

	stream->Write(m_iFreeWinsVsBarbs);
	stream->Write(m_iAnimalAttackProb);
	stream->Write(m_iStartingLocationPercent);
	stream->Write(m_iAdvancedStartPointsMod);
	stream->Write(m_iStartingGold);
	stream->Write(m_iFreeUnits);
	stream->Write(m_iUnitCostPercent);
	stream->Write(m_iResearchPercent);
	stream->Write(m_iDistanceMaintenancePercent);
	stream->Write(m_iNumCitiesMaintenancePercent);
	stream->Write(m_iMaxNumCitiesMaintenance);
	stream->Write(m_iColonyMaintenancePercent);
	stream->Write(m_iMaxColonyMaintenance);
	stream->Write(m_iCorporationMaintenancePercent);
	stream->Write(m_iCivicUpkeepPercent);
	stream->Write(m_iInflationPercent);
	stream->Write(m_iHealthBonus);
	stream->Write(m_iHappyBonus);
	stream->Write(m_iAttitudeChange);
	stream->Write(m_iNoTechTradeModifier);
	stream->Write(m_iTechTradeKnownModifier);
	stream->Write(m_iUnownedTilesPerGameAnimal);
	stream->Write(m_iUnownedTilesPerBarbarianUnit);
	stream->Write(m_iUnownedWaterTilesPerBarbarianUnit);
	stream->Write(m_iUnownedTilesPerBarbarianCity);
	stream->Write(m_iBarbarianCreationTurnsElapsed);
	stream->Write(m_iBarbarianCityCreationTurnsElapsed);
	stream->Write(m_iBarbarianCityCreationProb);
	stream->Write(m_iAnimalCombatModifier);
	stream->Write(m_iBarbarianCombatModifier);
	stream->Write(m_iAIAnimalCombatModifier);
	stream->Write(m_iAIBarbarianCombatModifier);

	stream->Write(m_iStartingDefenseUnits);
	stream->Write(m_iStartingWorkerUnits);
	stream->Write(m_iStartingExploreUnits);
	stream->Write(m_iAIStartingUnitMultiplier);
	stream->Write(m_iAIStartingDefenseUnits);
	stream->Write(m_iAIStartingWorkerUnits);
	stream->Write(m_iAIStartingExploreUnits);
	stream->Write(m_iBarbarianInitialDefenders);
	stream->Write(m_iAIDeclareWarProb);
	stream->Write(m_iAIWorkRateModifier);
	stream->Write(m_iAIGrowthPercent);
	stream->Write(m_iAITrainPercent);
	stream->Write(m_iAIWorldTrainPercent);
	stream->Write(m_iAIConstructPercent);
	stream->Write(m_iAIWorldConstructPercent);
	stream->Write(m_iAICreatePercent);
	stream->Write(m_iAIWorldCreatePercent);
	stream->Write(m_iAICivicUpkeepPercent);
	stream->Write(m_iAIUnitCostPercent);
	stream->Write(m_iAIUnitSupplyPercent);
	stream->Write(m_iAIUnitUpgradePercent);
	stream->Write(m_iAIInflationPercent);
	stream->Write(m_iAIWarWearinessPercent);
	stream->Write(m_iAIPerEraModifier);
	stream->Write(m_iAIAdvancedStartPercent);
	stream->Write(m_iNumGoodies);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Write(m_iAIFreeXP);
	stream->Write(m_iLairSpawnRate);
//FfH: End Add

/*************************************************************************************************/
/**	New Gameoption (Handicap Mana) Sephi                                           				**/
/**																			                    **/
/**	                                                                 							**/
/*************************************************************************************************/
    stream->Write(m_iFreeBonusMana);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	stream->WriteString(m_szHandicapName);

	// Arrays

	stream->Write(getNumGoodies(), m_piGoodies);
	stream->Write(GC.getNumTechInfos(), m_pbFreeTechs);
	stream->Write(GC.getNumTechInfos(), m_pbAIFreeTechs);
}

bool CvHandicapInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j;

	pXML->GetChildXmlValByName(&m_iFreeWinsVsBarbs, "iFreeWinsVsBarbs");
	pXML->GetChildXmlValByName(&m_iAnimalAttackProb, "iAnimalAttackProb");
	pXML->GetChildXmlValByName(&m_iStartingLocationPercent, "iStartingLocPercent");
	pXML->GetChildXmlValByName(&m_iAdvancedStartPointsMod, "iAdvancedStartPointsMod");
	pXML->GetChildXmlValByName(&m_iStartingGold, "iGold");
	pXML->GetChildXmlValByName(&m_iFreeUnits, "iFreeUnits");
	pXML->GetChildXmlValByName(&m_iUnitCostPercent, "iUnitCostPercent");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iDistanceMaintenancePercent, "iDistanceMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iNumCitiesMaintenancePercent, "iNumCitiesMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iMaxNumCitiesMaintenance, "iMaxNumCitiesMaintenance");
	pXML->GetChildXmlValByName(&m_iColonyMaintenancePercent, "iColonyMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iMaxColonyMaintenance, "iMaxColonyMaintenance");
	pXML->GetChildXmlValByName(&m_iCorporationMaintenancePercent, "iCorporationMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iCivicUpkeepPercent, "iCivicUpkeepPercent");
	pXML->GetChildXmlValByName(&m_iInflationPercent, "iInflationPercent");
	pXML->GetChildXmlValByName(&m_iHealthBonus, "iHealthBonus");
	pXML->GetChildXmlValByName(&m_iHappyBonus, "iHappyBonus");
	pXML->GetChildXmlValByName(&m_iAttitudeChange, "iAttitudeChange");
	pXML->GetChildXmlValByName(&m_iNoTechTradeModifier, "iNoTechTradeModifier");
	pXML->GetChildXmlValByName(&m_iTechTradeKnownModifier, "iTechTradeKnownModifier");
	pXML->GetChildXmlValByName(&m_iUnownedTilesPerGameAnimal, "iUnownedTilesPerGameAnimal");
	pXML->GetChildXmlValByName(&m_iUnownedTilesPerBarbarianUnit, "iUnownedTilesPerBarbarianUnit");
	pXML->GetChildXmlValByName(&m_iUnownedWaterTilesPerBarbarianUnit, "iUnownedWaterTilesPerBarbarianUnit");
	pXML->GetChildXmlValByName(&m_iUnownedTilesPerBarbarianCity, "iUnownedTilesPerBarbarianCity");
	pXML->GetChildXmlValByName(&m_iBarbarianCreationTurnsElapsed, "iBarbarianCreationTurnsElapsed");
	pXML->GetChildXmlValByName(&m_iBarbarianCityCreationTurnsElapsed, "iBarbarianCityCreationTurnsElapsed");
	pXML->GetChildXmlValByName(&m_iBarbarianCityCreationProb, "iBarbarianCityCreationProb");
	pXML->GetChildXmlValByName(&m_iAnimalCombatModifier, "iAnimalBonus");
	pXML->GetChildXmlValByName(&m_iBarbarianCombatModifier, "iBarbarianBonus");
	pXML->GetChildXmlValByName(&m_iAIAnimalCombatModifier, "iAIAnimalBonus");
	pXML->GetChildXmlValByName(&m_iAIBarbarianCombatModifier, "iAIBarbarianBonus");
	pXML->GetChildXmlValByName(&m_iStartingDefenseUnits, "iStartingDefenseUnits");
	pXML->GetChildXmlValByName(&m_iStartingWorkerUnits, "iStartingWorkerUnits");
	pXML->GetChildXmlValByName(&m_iStartingExploreUnits, "iStartingExploreUnits");
	pXML->GetChildXmlValByName(&m_iAIStartingUnitMultiplier, "iAIStartingUnitMultiplier");
	pXML->GetChildXmlValByName(&m_iAIStartingDefenseUnits, "iAIStartingDefenseUnits");
	pXML->GetChildXmlValByName(&m_iAIStartingWorkerUnits, "iAIStartingWorkerUnits");
	pXML->GetChildXmlValByName(&m_iAIStartingExploreUnits, "iAIStartingExploreUnits");
	pXML->GetChildXmlValByName(&m_iBarbarianInitialDefenders, "iBarbarianDefenders");
	pXML->GetChildXmlValByName(&m_iAIDeclareWarProb, "iAIDeclareWarProb");
	pXML->GetChildXmlValByName(&m_iAIWorkRateModifier, "iAIWorkRateModifier");
	pXML->GetChildXmlValByName(&m_iAIGrowthPercent, "iAIGrowthPercent");
	pXML->GetChildXmlValByName(&m_iAITrainPercent, "iAITrainPercent");
	pXML->GetChildXmlValByName(&m_iAIWorldTrainPercent, "iAIWorldTrainPercent");
	pXML->GetChildXmlValByName(&m_iAIConstructPercent, "iAIConstructPercent");
	pXML->GetChildXmlValByName(&m_iAIWorldConstructPercent, "iAIWorldConstructPercent");
	pXML->GetChildXmlValByName(&m_iAICreatePercent, "iAICreatePercent");
	pXML->GetChildXmlValByName(&m_iAIWorldCreatePercent, "iAIWorldCreatePercent");
	pXML->GetChildXmlValByName(&m_iAICivicUpkeepPercent, "iAICivicUpkeepPercent");
	pXML->GetChildXmlValByName(&m_iAIUnitCostPercent, "iAIUnitCostPercent");
	pXML->GetChildXmlValByName(&m_iAIUnitSupplyPercent, "iAIUnitSupplyPercent");
	pXML->GetChildXmlValByName(&m_iAIUnitSupportBonusPercent, "iAIUnitSupportBonusPercent");
	pXML->GetChildXmlValByName(&m_iAIUnitUpgradePercent, "iAIUnitUpgradePercent");
	pXML->GetChildXmlValByName(&m_iAIInflationPercent, "iAIInflationPercent");
//	pXML->GetChildXmlValByName(&m_iAIWarWearinessPercent, "iAIWarWearinessPercent");	No WarWeariness
	pXML->GetChildXmlValByName(&m_iAIPerEraModifier, "iAIPerEraModifier");
	pXML->GetChildXmlValByName(&m_iAIAdvancedStartPercent, "iAIAdvancedStartPercent");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Goodies"))
	{
		CvString* pszGoodyNames = NULL;
		pXML->SetStringList(&pszGoodyNames, &m_iNumGoodies);

		if (m_iNumGoodies > 0)
		{
			m_piGoodies = new int[m_iNumGoodies];

			for (j=0;j<m_iNumGoodies;j++)
			{
				m_piGoodies[j] = pXML->FindInInfoClass(pszGoodyNames[j]);
			}
		}
		else
		{
			m_piGoodies = NULL;
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

		SAFE_DELETE_ARRAY(pszGoodyNames);
	}

	pXML->SetVariableListTagPair(&m_pbFreeTechs, "FreeTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());
	pXML->SetVariableListTagPair(&m_pbAIFreeTechs, "AIFreeTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());

//FfH Improvements: Added by Kael 08/07/2007
	pXML->GetChildXmlValByName(&m_iAIFreeXP, "iAIFreeXP");
	pXML->GetChildXmlValByName(&m_iLairSpawnRate, "iLairSpawnRate");
//FfH: End Add

/*************************************************************************************************/
/**	New Gameoption (Handicap Mana) Sephi                                           				**/
/**	        																                    **/
/**	                                                                 							**/
/*************************************************************************************************/
	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "FreeBonusMana");
	m_iFreeBonusMana = pXML->FindInInfoClass( szTextVal);
	/** new tags **/
	pXML->GetChildXmlValByName(&m_iAICombatOddsCapped, "iAICombatOddsCapped");
	pXML->GetChildXmlValByName(&m_iAIFreeNobleHouseSupportModifier, "iAIFreeNobleHouseSupportModifier",0);
	pXML->GetChildXmlValByName(&m_iAIManaModifier, "iAIManaModifier",0);
	pXML->GetChildXmlValByName(&m_iAIFreeHappinessInterval, "iAIFreeHappinessInterval", 0);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(HandicapInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvHandicapInfo::copyNonDefaults(CvHandicapInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getFreeWinsVsBarbs()					== 0)		m_iFreeWinsVsBarbs						= pClassInfo->getFreeWinsVsBarbs();
	if (getAnimalAttackProb()					== 0)		m_iAnimalAttackProb						= pClassInfo->getAnimalAttackProb();
	if (getStartingLocationPercent()			== 0)		m_iStartingLocationPercent				= pClassInfo->getStartingLocationPercent();
	if (getAdvancedStartPointsMod()				== 0)		m_iAdvancedStartPointsMod				= pClassInfo->getAdvancedStartPointsMod();
	if (getStartingGold()						== 0)		m_iStartingGold							= pClassInfo->getStartingGold();
	if (getFreeUnits()							== 0)		m_iFreeUnits							= pClassInfo->getFreeUnits();
	if (getUnitCostPercent()					== 0)		m_iUnitCostPercent						= pClassInfo->getUnitCostPercent();
	if (getResearchPercent()					== 0)		m_iResearchPercent						= pClassInfo->getResearchPercent();
	if (getDistanceMaintenancePercent()			== 0)		m_iDistanceMaintenancePercent			= pClassInfo->getDistanceMaintenancePercent();
	if (getNumCitiesMaintenancePercent()		== 0)		m_iNumCitiesMaintenancePercent			= pClassInfo->getNumCitiesMaintenancePercent();
	if (getMaxNumCitiesMaintenance()			== 0)		m_iMaxNumCitiesMaintenance				= pClassInfo->getMaxNumCitiesMaintenance();
	if (getColonyMaintenancePercent()			== 0)		m_iColonyMaintenancePercent				= pClassInfo->getColonyMaintenancePercent();
	if (getMaxColonyMaintenance()				== 0)		m_iMaxColonyMaintenance					= pClassInfo->getMaxColonyMaintenance();
	if (getCorporationMaintenancePercent()		== 0)		m_iCorporationMaintenancePercent		= pClassInfo->getCorporationMaintenancePercent();
	if (getCivicUpkeepPercent()					== 0)		m_iCivicUpkeepPercent					= pClassInfo->getCivicUpkeepPercent();
	if (getInflationPercent()					== 0)		m_iInflationPercent						= pClassInfo->getInflationPercent();
	if (getHealthBonus()						== 0)		m_iHealthBonus							= pClassInfo->getHealthBonus();
	if (getHappyBonus()							== 0)		m_iHappyBonus							= pClassInfo->getHappyBonus();
	if (getAttitudeChange()						== 0)		m_iAttitudeChange						= pClassInfo->getAttitudeChange();
	if (getNoTechTradeModifier()				== 0)		m_iNoTechTradeModifier					= pClassInfo->getNoTechTradeModifier();
	if (getTechTradeKnownModifier()				== 0)		m_iTechTradeKnownModifier				= pClassInfo->getTechTradeKnownModifier();
	if (getUnownedTilesPerGameAnimal()			== 0)		m_iUnownedTilesPerGameAnimal			= pClassInfo->getUnownedTilesPerGameAnimal();
	if (getUnownedTilesPerBarbarianUnit()		== 0)		m_iUnownedTilesPerBarbarianUnit			= pClassInfo->getUnownedTilesPerBarbarianUnit();
	if (getUnownedWaterTilesPerBarbarianUnit()	== 0)		m_iUnownedWaterTilesPerBarbarianUnit	= pClassInfo->getUnownedWaterTilesPerBarbarianUnit();
	if (getUnownedTilesPerBarbarianCity()		== 0)		m_iUnownedTilesPerBarbarianCity			= pClassInfo->getUnownedTilesPerBarbarianCity();
	if (getBarbarianCreationTurnsElapsed()		== 0)		m_iBarbarianCreationTurnsElapsed		= pClassInfo->getBarbarianCreationTurnsElapsed();
	if (getBarbarianCityCreationTurnsElapsed()	== 0)		m_iBarbarianCityCreationTurnsElapsed	= pClassInfo->getBarbarianCityCreationTurnsElapsed();
	if (getBarbarianCityCreationProb()			== 0)		m_iBarbarianCityCreationProb			= pClassInfo->getBarbarianCityCreationProb();
	if (getAnimalCombatModifier()				== 0)		m_iAnimalCombatModifier					= pClassInfo->getAnimalCombatModifier();
	if (getBarbarianCombatModifier()			== 0)		m_iBarbarianCombatModifier				= pClassInfo->getBarbarianCombatModifier();
	if (getAIAnimalCombatModifier()				== 0)		m_iAIAnimalCombatModifier				= pClassInfo->getAIAnimalCombatModifier();
	if (getAIBarbarianCombatModifier()			== 0)		m_iAIBarbarianCombatModifier			= pClassInfo->getAIBarbarianCombatModifier();
	if (getStartingDefenseUnits()				== 0)		m_iStartingDefenseUnits					= pClassInfo->getStartingDefenseUnits();
	if (getStartingWorkerUnits()				== 0)		m_iStartingWorkerUnits					= pClassInfo->getStartingWorkerUnits();
	if (getStartingExploreUnits()				== 0)		m_iStartingExploreUnits					= pClassInfo->getStartingExploreUnits();
	if (getAIStartingUnitMultiplier()			== 0)		m_iAIStartingUnitMultiplier				= pClassInfo->getAIStartingUnitMultiplier();
	if (getAIStartingDefenseUnits()				== 0)		m_iAIStartingDefenseUnits				= pClassInfo->getAIStartingDefenseUnits();
	if (getAIStartingWorkerUnits()				== 0)		m_iAIStartingWorkerUnits				= pClassInfo->getAIStartingWorkerUnits();
	if (getAIStartingExploreUnits()				== 0)		m_iAIStartingExploreUnits				= pClassInfo->getAIStartingExploreUnits();
	if (getBarbarianInitialDefenders()			== 0)		m_iBarbarianInitialDefenders			= pClassInfo->getBarbarianInitialDefenders();
	if (getAIDeclareWarProb()					== 0)		m_iAIDeclareWarProb						= pClassInfo->getAIDeclareWarProb();
	if (getAIWorkRateModifier()					== 0)		m_iAIWorkRateModifier					= pClassInfo->getAIWorkRateModifier();
	if (getAIGrowthPercent()					== 0)		m_iAIGrowthPercent						= pClassInfo->getAIGrowthPercent();
	if (getAITrainPercent()						== 0)		m_iAITrainPercent						= pClassInfo->getAITrainPercent();
	if (getAIWorldTrainPercent()				== 0)		m_iAIWorldTrainPercent					= pClassInfo->getAIWorldTrainPercent();
	if (getAIConstructPercent()					== 0)		m_iAIConstructPercent					= pClassInfo->getAIConstructPercent();
	if (getAIWorldConstructPercent()			== 0)		m_iAIWorldConstructPercent				= pClassInfo->getAIWorldConstructPercent();
	if (getAICreatePercent()					== 0)		m_iAICreatePercent						= pClassInfo->getAICreatePercent();
	if (getAIWorldCreatePercent()				== 0)		m_iAIWorldCreatePercent					= pClassInfo->getAIWorldCreatePercent();
	if (getAICivicUpkeepPercent()				== 0)		m_iAICivicUpkeepPercent					= pClassInfo->getAICivicUpkeepPercent();
	if (getAIUnitCostPercent()					== 0)		m_iAIUnitCostPercent					= pClassInfo->getAIUnitCostPercent();
	if (getAIUnitSupplyPercent()				== 0)		m_iAIUnitSupplyPercent					= pClassInfo->getAIUnitSupplyPercent();
	if (getAIUnitSupportBonusPercent()				== 0)		m_iAIUnitSupportBonusPercent					= pClassInfo->getAIUnitSupportBonusPercent();
	if (getAIUnitUpgradePercent()				== 0)		m_iAIUnitUpgradePercent					= pClassInfo->getAIUnitUpgradePercent();
	if (getAIInflationPercent()					== 0)		m_iAIInflationPercent					= pClassInfo->getAIInflationPercent();
	if (getAIWarWearinessPercent()				== 0)		m_iAIWarWearinessPercent				= pClassInfo->getAIWarWearinessPercent();
	if (getAIPerEraModifier()					== 0)		m_iAIPerEraModifier						= pClassInfo->getAIPerEraModifier();
	if (getAIAdvancedStartPercent()				== 0)		m_iAIAdvancedStartPercent				= pClassInfo->getAIAdvancedStartPercent();
	if (getAIFreeXP()							== 0)		m_iAIFreeXP								= pClassInfo->getAIFreeXP();
	if (getLairSpawnRate()						== 0)		m_iLairSpawnRate						= pClassInfo->getLairSpawnRate();
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if (m_pbFreeTechs[i]					== false)	m_pbFreeTechs[i]						= pClassInfo->isFreeTechs(i);
		if (m_pbAIFreeTechs[i]					== false)	m_pbAIFreeTechs[i]						= pClassInfo->isAIFreeTechs(i);
	}
	if ( pClassInfo->getNumGoodies() >= 0 )
	{
		int iNumGoodiesOld = m_iNumGoodies;
		CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
		for ( int i = 0; i < pClassInfo->getNumGoodies(); i++ )
		{
			if (!(pCurrentUnitClass->isDuplicate(getNumGoodies(), &m_piGoodies[0], pClassInfo->getGoodies(i))))
			{
				if (pClassInfo->getGoodies(i) != NO_GOODY)	m_iNumGoodies++;
			}
		}
		int* m_piGoodiesTemp = new int[m_iNumGoodies];
		for ( int i = 0; i < m_iNumGoodies; i++ )
		{
			if (i < iNumGoodiesOld)		m_piGoodiesTemp[i] = m_piGoodies[i];
			else if (!(pCurrentUnitClass->isDuplicate(getNumGoodies(), &m_piGoodiesTemp[0], pClassInfo->getGoodies(i))))		m_piGoodiesTemp[i] = pClassInfo->getGoodies(i);
		}
		SAFE_DELETE_ARRAY(m_piGoodies);
		m_piGoodies = new int[m_iNumGoodies];
		for ( int i = 0; i < m_iNumGoodies; i++ )
		{
															m_piGoodies[i]							= m_piGoodiesTemp[i];
		}
		SAFE_DELETE_ARRAY(m_piGoodiesTemp);
		SAFE_DELETE(pCurrentUnitClass);
	}
	if (getFreeBonusMana()				        == 0)		m_iFreeBonusMana				        = pClassInfo->getFreeBonusMana();
	if (getAICombatOddsCapped()			        == 0)		m_iAICombatOddsCapped			        = pClassInfo->getAICombatOddsCapped();
	if (getAIFreeNobleHouseSupportModifier()	== 0)		m_iAIFreeNobleHouseSupportModifier      = pClassInfo->getAIFreeNobleHouseSupportModifier();
	if (getAIManaModifier()						== 0)		m_iAIManaModifier					    = pClassInfo->getAIManaModifier();
	if (getAIFreeHappinessInterval()			== 0)		m_iAIFreeHappinessInterval				= pClassInfo->getAIFreeHappinessInterval();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvGameSpeedInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvGameSpeedInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvGameSpeedInfo::CvGameSpeedInfo() :
m_iGrowthPercent(0),
m_iTrainPercent(0),
m_iConstructPercent(0),
m_iCreatePercent(0),
m_iResearchPercent(0),
m_iBuildPercent(0),
m_iImprovementPercent(0),
m_iGreatPeoplePercent(0),
m_iAnarchyPercent(0),
m_iBarbPercent(0),
m_iFeatureProductionPercent(0),
m_iUnitDiscoverPercent(0),
m_iUnitHurryPercent(0),
m_iUnitTradePercent(0),
m_iUnitGreatWorkPercent(0),
m_iGoldenAgePercent(0),
m_iHurryPercent(0),
m_iHurryConscriptAngerPercent(0),
m_iInflationOffset(0),
m_iInflationPercent(0),
m_iVictoryDelayPercent(0),

m_iNumTurnIncrements(0),
m_pGameTurnInfo(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvGameSpeedInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvGameSpeedInfo::~CvGameSpeedInfo()
{
	SAFE_DELETE_ARRAY(m_pGameTurnInfo);
}

int CvGameSpeedInfo::getGrowthPercent() const
{
	return m_iGrowthPercent;
}

int CvGameSpeedInfo::getTrainPercent() const
{
	return m_iTrainPercent;
}

int CvGameSpeedInfo::getConstructPercent() const
{
	return m_iConstructPercent;
}

int CvGameSpeedInfo::getCreatePercent() const
{
	return m_iCreatePercent;
}

int CvGameSpeedInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvGameSpeedInfo::getBuildPercent() const
{
	return m_iBuildPercent;
}

int CvGameSpeedInfo::getImprovementPercent() const
{
	return m_iImprovementPercent;
}

int CvGameSpeedInfo::getGreatPeoplePercent() const
{
	return m_iGreatPeoplePercent;
}

int CvGameSpeedInfo::getAnarchyPercent() const
{
	return m_iAnarchyPercent;
}

int CvGameSpeedInfo::getBarbPercent() const
{
	return m_iBarbPercent;
}

int CvGameSpeedInfo::getFeatureProductionPercent() const
{
	return m_iFeatureProductionPercent;
}

int CvGameSpeedInfo::getUnitDiscoverPercent() const
{
	return m_iUnitDiscoverPercent;
}

int CvGameSpeedInfo::getUnitHurryPercent() const
{
	return m_iUnitHurryPercent;
}

int CvGameSpeedInfo::getUnitTradePercent() const
{
	return m_iUnitTradePercent;
}

int CvGameSpeedInfo::getUnitGreatWorkPercent() const
{
	return m_iUnitGreatWorkPercent;
}

int CvGameSpeedInfo::getGoldenAgePercent() const
{
	return m_iGoldenAgePercent;
}

int CvGameSpeedInfo::getHurryPercent() const
{
	return m_iHurryPercent;
}

int CvGameSpeedInfo::getHurryConscriptAngerPercent() const
{
	return m_iHurryConscriptAngerPercent;
}

int CvGameSpeedInfo::getInflationOffset() const
{
	return m_iInflationOffset;
}

int CvGameSpeedInfo::getInflationPercent() const
{
	return m_iInflationPercent;
}

int CvGameSpeedInfo::getVictoryDelayPercent() const
{
	return m_iVictoryDelayPercent;
}

int CvGameSpeedInfo::getNumTurnIncrements() const
{
	return m_iNumTurnIncrements;
}

GameTurnInfo& CvGameSpeedInfo::getGameTurnInfo(int iIndex) const
{
	return m_pGameTurnInfo[iIndex];
}

void CvGameSpeedInfo::allocateGameTurnInfos(const int iSize)
{
	m_pGameTurnInfo = new GameTurnInfo[iSize];
}

bool CvGameSpeedInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j, iTempVal;

	pXML->GetChildXmlValByName(&m_iGrowthPercent, "iGrowthPercent");
	pXML->GetChildXmlValByName(&m_iTrainPercent, "iTrainPercent");
	pXML->GetChildXmlValByName(&m_iConstructPercent, "iConstructPercent");
	pXML->GetChildXmlValByName(&m_iCreatePercent, "iCreatePercent");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iBuildPercent, "iBuildPercent");
	pXML->GetChildXmlValByName(&m_iImprovementPercent, "iImprovementPercent");
	pXML->GetChildXmlValByName(&m_iGreatPeoplePercent, "iGreatPeoplePercent");
	pXML->GetChildXmlValByName(&m_iAnarchyPercent, "iAnarchyPercent");
	pXML->GetChildXmlValByName(&m_iBarbPercent, "iBarbPercent");
	pXML->GetChildXmlValByName(&m_iFeatureProductionPercent, "iFeatureProductionPercent");
	pXML->GetChildXmlValByName(&m_iUnitDiscoverPercent, "iUnitDiscoverPercent");
	pXML->GetChildXmlValByName(&m_iUnitHurryPercent, "iUnitHurryPercent");
	pXML->GetChildXmlValByName(&m_iUnitTradePercent, "iUnitTradePercent");
	pXML->GetChildXmlValByName(&m_iUnitGreatWorkPercent, "iUnitGreatWorkPercent");
	pXML->GetChildXmlValByName(&m_iGoldenAgePercent, "iGoldenAgePercent");
	pXML->GetChildXmlValByName(&m_iHurryPercent, "iHurryPercent");
	pXML->GetChildXmlValByName(&m_iHurryConscriptAngerPercent, "iHurryConscriptAngerPercent");
	pXML->GetChildXmlValByName(&m_iInflationOffset, "iInflationOffset");
	pXML->GetChildXmlValByName(&m_iInflationPercent, "iInflationPercent");
	pXML->GetChildXmlValByName(&m_iVictoryDelayPercent, "iVictoryDelayPercent");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GameTurnInfos"))
	{
		m_iNumTurnIncrements = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
		if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
		{
			allocateGameTurnInfos(getNumTurnIncrements());

			// loop through each tag
			for (j=0;j<getNumTurnIncrements();j++)
			{
				pXML->GetChildXmlValByName(&iTempVal, "iMonthIncrement");
				getGameTurnInfo(j).iMonthIncrement = iTempVal;
				pXML->GetChildXmlValByName(&iTempVal, "iTurnsPerIncrement");
				getGameTurnInfo(j).iNumGameTurnsPerIncrement = iTempVal;

				// if we cannot set the current xml node to it's next sibling then we will break out of the for loop
				// otherwise we will continue looping
				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(GameSpeedInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGameSpeedInfo::copyNonDefaults(CvGameSpeedInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getGrowthPercent()				== 0)		m_iGrowthPercent				= pClassInfo->getGrowthPercent();
	if (getTrainPercent()				== 0)		m_iTrainPercent					= pClassInfo->getTrainPercent();
	if (getConstructPercent()			== 0)		m_iConstructPercent				= pClassInfo->getConstructPercent();
	if (getCreatePercent()				== 0)		m_iCreatePercent				= pClassInfo->getCreatePercent();
	if (getResearchPercent()			== 0)		m_iResearchPercent				= pClassInfo->getResearchPercent();
	if (getBuildPercent()				== 0)		m_iBuildPercent					= pClassInfo->getBuildPercent();
	if (getImprovementPercent()			== 0)		m_iImprovementPercent			= pClassInfo->getImprovementPercent();
	if (getGreatPeoplePercent()			== 0)		m_iGreatPeoplePercent			= pClassInfo->getGreatPeoplePercent();
	if (getAnarchyPercent()				== 0)		m_iAnarchyPercent				= pClassInfo->getAnarchyPercent();
	if (getBarbPercent()				== 0)		m_iBarbPercent					= pClassInfo->getBarbPercent();
	if (getFeatureProductionPercent()	== 0)		m_iFeatureProductionPercent		= pClassInfo->getFeatureProductionPercent();
	if (getUnitDiscoverPercent()		== 0)		m_iUnitDiscoverPercent			= pClassInfo->getUnitDiscoverPercent();
	if (getUnitHurryPercent()			== 0)		m_iUnitHurryPercent				= pClassInfo->getUnitHurryPercent();
	if (getUnitTradePercent()			== 0)		m_iUnitTradePercent				= pClassInfo->getUnitTradePercent();
	if (getUnitGreatWorkPercent()		== 0)		m_iUnitGreatWorkPercent			= pClassInfo->getUnitGreatWorkPercent();
	if (getGoldenAgePercent()			== 0)		m_iGoldenAgePercent				= pClassInfo->getGoldenAgePercent();
	if (getHurryPercent()				== 0)		m_iHurryPercent					= pClassInfo->getHurryPercent();
	if (getHurryConscriptAngerPercent()	== 0)		m_iHurryConscriptAngerPercent	= pClassInfo->getHurryConscriptAngerPercent();
	if (getInflationOffset()			== 0)		m_iInflationOffset				= pClassInfo->getInflationOffset();
	if (getInflationPercent()			== 0)		m_iInflationPercent				= pClassInfo->getInflationPercent();
	if (getVictoryDelayPercent()		== 0)		m_iVictoryDelayPercent			= pClassInfo->getVictoryDelayPercent();
	if (getNumTurnIncrements()			== 0)
	{
													m_iNumTurnIncrements			= pClassInfo->getNumTurnIncrements();
		allocateGameTurnInfos(getNumTurnIncrements());
		for (int j = 0; j < getNumTurnIncrements(); j++)
		{
													m_pGameTurnInfo[j]				= pClassInfo->getGameTurnInfo(j);
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvTurnTimerInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTurnTimerInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTurnTimerInfo::CvTurnTimerInfo() :
m_iBaseTime(0),
m_iCityBonus(0),
m_iUnitBonus(0),
m_iFirstTurnMultiplier(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTurnTimerInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTurnTimerInfo::~CvTurnTimerInfo()
{
}

int CvTurnTimerInfo::getBaseTime() const
{
	return m_iBaseTime;
}

int CvTurnTimerInfo::getCityBonus() const
{
	return m_iCityBonus;
}

int CvTurnTimerInfo::getUnitBonus() const
{
	return m_iUnitBonus;
}

int CvTurnTimerInfo::getFirstTurnMultiplier() const
{
	return m_iFirstTurnMultiplier;
}

bool CvTurnTimerInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iBaseTime, "iBaseTime");
	pXML->GetChildXmlValByName(&m_iCityBonus, "iCityBonus");
	pXML->GetChildXmlValByName(&m_iUnitBonus, "iUnitBonus");
	pXML->GetChildXmlValByName(&m_iFirstTurnMultiplier, "iFirstTurnMultiplier");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTurnTimerInfo::copyNonDefaults(CvTurnTimerInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getBaseTime()				== 0)		m_iBaseTime				= pClassInfo->getBaseTime();
	if (getCityBonus()				== 0)		m_iCityBonus			= pClassInfo->getCityBonus();
	if (getUnitBonus()				== 0)		m_iUnitBonus			= pClassInfo->getUnitBonus();
	if (getFirstTurnMultiplier()	== 0)		m_iFirstTurnMultiplier	= pClassInfo->getFirstTurnMultiplier();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvBuildInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBuildInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBuildInfo::CvBuildInfo() :
m_iTime(0),
m_iCost(0),
m_iTechPrereq(NO_TECH),
m_iImprovement(NO_IMPROVEMENT),
m_iRoute(NO_ROUTE),
m_iEntityEvent(ENTITY_EVENT_NONE),
m_iMissionType(NO_MISSION),
m_bKill(false),
m_bApplyImprovementCost(false),
m_iTerrainPre(NO_TERRAIN),
m_iTerrainPost(NO_TERRAIN),
m_paiFeatureTech(NULL),
m_paiFeatureTime(NULL),
m_paiFeatureProduction(NULL),
m_pabFeatureRemove(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBuildInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBuildInfo::~CvBuildInfo()
{
	SAFE_DELETE_ARRAY(m_paiFeatureTech);
	SAFE_DELETE_ARRAY(m_paiFeatureTime);
	SAFE_DELETE_ARRAY(m_paiFeatureProduction);
	SAFE_DELETE_ARRAY(m_pabFeatureRemove);
}

int CvBuildInfo::getTime() const
{
	return m_iTime;
}

int CvBuildInfo::getCost() const
{
	return m_iCost;
}

int CvBuildInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvBuildInfo::getImprovement() const
{
	return m_iImprovement;
}

int CvBuildInfo::getRoute() const
{
	return m_iRoute;
}

int CvBuildInfo::getEntityEvent() const
{
	return m_iEntityEvent;
}

int CvBuildInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvBuildInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

bool CvBuildInfo::isKill() const
{
	return m_bKill;
}

bool CvBuildInfo::isApplyImprovementCost() const { return m_bApplyImprovementCost; }
int CvBuildInfo::getTerrainPre() const { return m_iTerrainPre; }
int CvBuildInfo::getTerrainPost() const { return m_iTerrainPost; }
// Arrays

int CvBuildInfo::getFeatureTech(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureTech ? m_paiFeatureTech[i] : -1;
}

int CvBuildInfo::getFeatureTime(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureTime ? m_paiFeatureTime[i] : -1;
}

int CvBuildInfo::getFeatureProduction(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiFeatureProduction ? m_paiFeatureProduction[i] : -1;
}

bool CvBuildInfo::isFeatureRemove(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pabFeatureRemove ? m_pabFeatureRemove[i] : false;
}

bool CvBuildInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iTime, "iTime");
	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_bKill, "bKill");
	pXML->GetChildXmlValByName(&m_bApplyImprovementCost, "bApplyImprovementCost");
	pXML->GetChildXmlValByName(szTextVal, "TerrainPre");
	m_iTerrainPre = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainPost");
	m_iTerrainPost = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
	m_iImprovement = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "RouteType");
	m_iRoute = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EntityEvent");
	m_iEntityEvent = pXML->FindInInfoClass(szTextVal);

	pXML->SetFeatureStruct(&m_paiFeatureTech, &m_paiFeatureTime, &m_paiFeatureProduction, &m_pabFeatureRemove);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(BuildInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBuildInfo::copyNonDefaults(CvBuildInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getTechPrereq()				== NO_TECH)				m_iTechPrereq				= pClassInfo->getTechPrereq();
	if (getTime()					== 0)					m_iTime						= pClassInfo->getTime();
	if (getCost()					== 0)					m_iCost						= pClassInfo->getCost();
	if (isKill()					== false)				m_bKill						= pClassInfo->isKill();
	if (isApplyImprovementCost      == false)               m_bApplyImprovementCost		= pClassInfo->isApplyImprovementCost();
	if (getTerrainPre()				== NO_TERRAIN)			m_iTerrainPre				= pClassInfo->getTerrainPre();
	if (getTerrainPost()			== NO_TERRAIN)			m_iTerrainPost				= pClassInfo->getTerrainPost();
	if (getImprovement()			== NO_IMPROVEMENT)		m_iImprovement				= pClassInfo->getImprovement();
	if (getRoute()					== NO_ROUTE)			m_iRoute					= pClassInfo->getRoute();
	if (getEntityEvent()			== ENTITY_EVENT_NONE)	m_iEntityEvent				= pClassInfo->getEntityEvent();
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if (m_paiFeatureTech[i]		== NO_TECH)
		{
															m_paiFeatureTech[i]			= pClassInfo->getFeatureTech(i);
															m_paiFeatureTime[i]			= pClassInfo->getFeatureTime(i);
															m_paiFeatureProduction[i]	= pClassInfo->getFeatureProduction(i);
															m_pabFeatureRemove[i]		= pClassInfo->isFeatureRemove(i);
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvGoodyInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvGoodyInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvGoodyInfo::CvGoodyInfo() :
m_iGold(0),
m_iGoldRand1(0),
m_iGoldRand2(0),
m_iMapOffset(0),
m_iMapRange(0),
m_iMapProb(0),
m_iExperience(0),
m_iHealing(0),
m_iDamagePrereq(0),
m_iBarbarianUnitProb(0),
m_iMinBarbarians(0),
m_iUnitClassType(NO_UNITCLASS),
m_iBarbarianUnitClass(NO_UNITCLASS),
m_bTech(false),
m_bBad(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvGoodyInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvGoodyInfo::~CvGoodyInfo()
{
}

int CvGoodyInfo::getGold() const
{
	return m_iGold;
}

int CvGoodyInfo::getGoldRand1() const
{
	return m_iGoldRand1;
}

int CvGoodyInfo::getGoldRand2() const
{
	return m_iGoldRand2;
}

int CvGoodyInfo::getMapOffset() const
{
	return m_iMapOffset;
}

int CvGoodyInfo::getMapRange() const
{
	return m_iMapRange;
}

int CvGoodyInfo::getMapProb() const
{
	return m_iMapProb;
}

int CvGoodyInfo::getExperience() const
{
	return m_iExperience;
}

int CvGoodyInfo::getHealing() const
{
	return m_iHealing;
}

int CvGoodyInfo::getDamagePrereq() const
{
	return m_iDamagePrereq;
}

int CvGoodyInfo::getBarbarianUnitProb() const
{
	return m_iBarbarianUnitProb;
}

int CvGoodyInfo::getMinBarbarians() const
{
	return m_iMinBarbarians;
}

int CvGoodyInfo::getUnitClassType() const
{
	return m_iUnitClassType;
}

int CvGoodyInfo::getBarbarianUnitClass() const
{
	return m_iBarbarianUnitClass;
}

bool CvGoodyInfo::isTech() const
{
	return m_bTech;
}

bool CvGoodyInfo::isBad() const
{
	return m_bBad;
}

const TCHAR* CvGoodyInfo::getSound() const
{
	return m_szSound;
}

void CvGoodyInfo::setSound(const TCHAR* szVal)
{
	m_szSound=szVal;
}

bool CvGoodyInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(&m_iGold, "iGold");
	pXML->GetChildXmlValByName(&m_iGoldRand1, "iGoldRand1");
	pXML->GetChildXmlValByName(&m_iGoldRand2, "iGoldRand2");
	pXML->GetChildXmlValByName(&m_iMapOffset, "iMapOffset");
	pXML->GetChildXmlValByName(&m_iMapRange, "iMapRange");
	pXML->GetChildXmlValByName(&m_iMapProb, "iMapProb");
	pXML->GetChildXmlValByName(&m_iExperience, "iExperience");
	pXML->GetChildXmlValByName(&m_iHealing, "iHealing");
	pXML->GetChildXmlValByName(&m_iDamagePrereq, "iDamagePrereq");
	pXML->GetChildXmlValByName(&m_bTech, "bTech");
	pXML->GetChildXmlValByName(&m_bBad, "bBad");

	pXML->GetChildXmlValByName(szTextVal, "UnitClass");
	m_iUnitClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "BarbarianClass");
	m_iBarbarianUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iBarbarianUnitProb, "iBarbarianUnitProb");
	pXML->GetChildXmlValByName(&m_iMinBarbarians, "iMinBarbarians");

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(GoodyInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGoodyInfo::copyNonDefaults(CvGoodyInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isTech()					== false)			m_bTech					= pClassInfo->isTech();
	if (isBad()						== false)			m_bBad					= pClassInfo->isBad();
	if (getGold()					== 0)				m_iGold					= pClassInfo->getGold();
	if (getGoldRand1()				== 0)				m_iGoldRand1			= pClassInfo->getGoldRand1();
	if (getGoldRand2()				== 0)				m_iGoldRand2			= pClassInfo->getGoldRand2();
	if (getMapOffset()				== 0)				m_iMapOffset			= pClassInfo->getMapOffset();
	if (getMapRange()				== 0)				m_iMapRange				= pClassInfo->getMapRange();
	if (getMapProb()				== 0)				m_iMapProb				= pClassInfo->getMapProb();
	if (getExperience()				== 0)				m_iExperience			= pClassInfo->getExperience();
	if (getHealing()				== 0)				m_iHealing				= pClassInfo->getHealing();
	if (getDamagePrereq()			== 0)				m_iDamagePrereq			= pClassInfo->getDamagePrereq();
	if (getBarbarianUnitProb()		== 0)				m_iBarbarianUnitProb	= pClassInfo->getBarbarianUnitProb();
	if (getMinBarbarians()			== 0)				m_iMinBarbarians		= pClassInfo->getMinBarbarians();
	if (getSound()					== cDefault)		setSound(				pClassInfo->getSound());
	if (getUnitClassType()			== NO_UNITCLASS)	m_iUnitClassType		= pClassInfo->getUnitClassType();
	if (getBarbarianUnitClass()		== NO_UNITCLASS)	m_iBarbarianUnitClass	= pClassInfo->getBarbarianUnitClass();

	//Readpass3 stuff
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvRouteInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvRouteInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvRouteInfo::CvRouteInfo() :
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iValue(0),
m_iMovementCost(0),
m_iFlatMovementCost(0),
m_iPrereqBonus(NO_BONUS),
m_piYieldChange(NULL),
m_piTechMovementChange(NULL),
m_piPrereqOrBonuses(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvRouteInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvRouteInfo::~CvRouteInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piTechMovementChange);
	SAFE_DELETE_ARRAY(m_piPrereqOrBonuses);
}

int CvRouteInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvRouteInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvRouteInfo::getValue() const
{
	return m_iValue;
}

int CvRouteInfo::getMovementCost() const
{
	return m_iMovementCost;
}

int CvRouteInfo::getFlatMovementCost() const
{
	return m_iFlatMovementCost;
}

int CvRouteInfo::getPrereqBonus() const
{
	return m_iPrereqBonus;
}

// Arrays

int CvRouteInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int CvRouteInfo::getTechMovementChange(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTechMovementChange ? m_piTechMovementChange[i] : -1;
}

int CvRouteInfo::getPrereqOrBonus(int i) const
{
	return m_piPrereqOrBonuses ? m_piPrereqOrBonuses[i] : -1;
}

bool CvRouteInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");

	pXML->GetChildXmlValByName(&m_iValue, "iValue");
	pXML->GetChildXmlValByName(&m_iMovementCost, "iMovement");
	pXML->GetChildXmlValByName(&m_iFlatMovementCost, "iFlatMovement");

	pXML->GetChildXmlValByName(szTextVal, "BonusType");
	m_iPrereqBonus = pXML->FindInInfoClass(szTextVal);

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Yields"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldChange);
		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	pXML->SetVariableListTagPair(&m_piTechMovementChange, "TechMovementChanges", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqOrBonuses"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getNUM_ROUTE_PREREQ_OR_BONUSES()) ,"Allocating zero or less memory in SetGlobalUnitInfo");
			pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_ROUTE_PREREQ_OR_BONUSES(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_ROUTE_PREREQ_OR_BONUSES()) ,"There are more siblings than memory allocated for them in SetGlobalUnitInfo");
					for (int j=0;j<iNumSibs;j++)
					{
						m_piPrereqOrBonuses[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_piPrereqOrBonuses, GC.getNUM_ROUTE_PREREQ_OR_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvRouteInfo::copyNonDefaults(CvRouteInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getAdvancedStartCost()			== 0)			m_iAdvancedStartCost			= pClassInfo->getAdvancedStartCost();
	if (getAdvancedStartCostIncrease()	== 0)			m_iAdvancedStartCostIncrease	= pClassInfo->getAdvancedStartCostIncrease();
	if (getValue()						== 0)			m_iValue						= pClassInfo->getValue();
	if (getMovementCost()				== 0)			m_iMovementCost					= pClassInfo->getMovementCost();
	if (getFlatMovementCost()			== 0)			m_iFlatMovementCost				= pClassInfo->getFlatMovementCost();
	if (getPrereqBonus()				== NO_BONUS)	m_iPrereqBonus					= pClassInfo->getPrereqBonus();
	for (int i = 0;  i < NUM_YIELD_TYPES; i++)
	{
		if (getYieldChange(i)			== 0)			m_piYieldChange[i]				= pClassInfo->getYieldChange(i);
	}
	for (int i = 0;  i < GC.getNumTechInfos(); i++)
	{
		if (getTechMovementChange(i)	== 0)			m_piTechMovementChange[i]		= pClassInfo->getTechMovementChange(i);
	}
	for (int i = 0;  i < GC.getNUM_ROUTE_PREREQ_OR_BONUSES(); i++)
	{
		if (getPrereqOrBonus(i)			== 0)			m_piPrereqOrBonuses[i]			= pClassInfo->getPrereqOrBonus(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvImprovementBonusInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvImprovementBonusInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementBonusInfo::CvImprovementBonusInfo() :
m_iDiscoverRand(0),
m_bBonusMakesValid(false),
m_bBonusTrade(false),
m_piYieldChange(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvImprovementBonusInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementBonusInfo::~CvImprovementBonusInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
}

int CvImprovementBonusInfo::getDiscoverRand() const
{
	return m_iDiscoverRand;
}

bool CvImprovementBonusInfo::isBonusMakesValid() const
{
	return m_bBonusMakesValid;
}

bool CvImprovementBonusInfo::isBonusTrade() const
{
	return m_bBonusTrade;
}

int CvImprovementBonusInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

void CvImprovementBonusInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iDiscoverRand);

	stream->Read(&m_bBonusMakesValid);
	stream->Read(&m_bBonusTrade);

	// Arrays

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);
}

void CvImprovementBonusInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iDiscoverRand);

	stream->Write(m_bBonusMakesValid);
	stream->Write(m_bBonusTrade);

	// Arrays

	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
}

//======================================================================================================
//					CvImprovementInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvImprovementInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementInfo::CvImprovementInfo() :
m_iAdvancedStartCost(0),
m_iAdvancedStartCostIncrease(0),
m_iTilesPerGoody(0),
m_iGoodyUniqueRange(0),
m_iFeatureGrowthProbability(0),
m_iUpgradeTime(0),
m_iAirBombDefense(0),
m_iDefenseModifier(0),
m_iHappiness(0),
m_iPillageGold(0),
m_iImprovementPillage(NO_IMPROVEMENT),
m_iImprovementUpgrade(NO_IMPROVEMENT),
m_bActsAsCity(true),
m_bHillsMakesValid(false),
m_bFreshWaterMakesValid(false),
m_bFloodPlainsMakesValid(false),
m_bRiverSideMakesValid(false),
m_bNoFreshWater(false),
m_bRequiresFlatlands(false),
m_bRequiresRiverSide(false),
m_bRequiresIrrigation(false),
m_bCarriesIrrigation(false),
m_bRequiresFeature(false),
m_bWater(false),
m_bGoody(false),
m_bPermanent(false),
m_bOutsideBorders(false),
m_iWorldSoundscapeScriptId(0),
m_piPrereqNatureYield(NULL),
m_piYieldChange(NULL),
m_piRiverSideYieldChange(NULL),
m_piHillsYieldChange(NULL),
m_piIrrigatedChange(NULL),
m_pbTerrainMakesValid(NULL),
m_pbFeatureMakesValid(NULL),
m_ppiTechYieldChanges(NULL),
m_ppiRouteYieldChanges(NULL),
m_paImprovementBonus(NULL),

//FfH Improvements: Added by Kael 08/07/2007
m_bRequiresPeak(false),
m_bUnique(false),
m_iAppearanceProbability(0),
m_iHealRateChange(0),
m_iDestroyAdjacentImprovementChance(0),
m_iRange(0),
m_iRangeDefenseModifier(0),
m_iBonusConvert(NO_BONUS),
m_iFeatureUpgrade(NO_FEATURE),
m_iPrereqCivilization(NO_CIVILIZATION),
m_iSpawnUnitType(NO_UNIT),
m_iVisibilityChange(0)
//FfH: End Add

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                   					**/
/*************************************************************************************************/
,m_iHealth(0)
,m_iImprovementClassType(-1)
,m_iPrereqTerrainSpreadResources(NO_TERRAIN)
,m_iGoldCost(0)
,m_iCultureChange(0)
,m_iAdjacentFindResourceModify(0)
,m_iMinWilderness(0)
,m_iMaxWilderness(MAX_INT)
,m_iSpawnGroup(NO_AIGROUP)
,m_iDungeonType(NO_DUNGEON)
/** multibarb **/
,m_iSpawnUnitCiv(NO_CIVILIZATION)
,m_bDefaultBuildableAllCivs(false)
,m_iNativePlane(NO_PLANE)
,m_piAppearanceTechs(NULL)
,m_piYieldCost(NULL)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvImprovementInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvImprovementInfo::~CvImprovementInfo()
{
	int iI;

	SAFE_DELETE_ARRAY(m_piPrereqNatureYield);
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piRiverSideYieldChange);
	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	SAFE_DELETE_ARRAY(m_piIrrigatedChange);
	SAFE_DELETE_ARRAY(m_pbTerrainMakesValid);
	SAFE_DELETE_ARRAY(m_pbFeatureMakesValid);
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    SAFE_DELETE_ARRAY(m_piAppearanceTechs);
    SAFE_DELETE_ARRAY(m_piYieldCost);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	if (m_paImprovementBonus != NULL)
	{
		SAFE_DELETE_ARRAY(m_paImprovementBonus); // XXX make sure this isn't leaking memory...
	}

	if (m_ppiTechYieldChanges != NULL)
	{
		for (iI=0;iI<GC.getNumTechInfos();iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiTechYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiTechYieldChanges);
	}

	if (m_ppiRouteYieldChanges != NULL)
	{
		for (iI=0;iI<GC.getNumRouteInfos();iI++)
		{
			SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges[iI]);
		}
		SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges);
	}
}

int CvImprovementInfo::getAdvancedStartCost() const
{
	return m_iAdvancedStartCost;
}

int CvImprovementInfo::getAdvancedStartCostIncrease() const
{
	return m_iAdvancedStartCostIncrease;
}

int CvImprovementInfo::getTilesPerGoody() const
{
	return m_iTilesPerGoody;
}

int CvImprovementInfo::getGoodyUniqueRange() const
{
	return m_iGoodyUniqueRange;
}

int CvImprovementInfo::getFeatureGrowthProbability() const
{
	return m_iFeatureGrowthProbability;
}

int CvImprovementInfo::getUpgradeTime() const
{
	return m_iUpgradeTime;
}

int CvImprovementInfo::getAirBombDefense() const
{
	return m_iAirBombDefense;
}

int CvImprovementInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

int CvImprovementInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvImprovementInfo::getPillageGold() const
{
	return m_iPillageGold;
}

bool CvImprovementInfo::isOutsideBorders() const
{
	return m_bOutsideBorders;
}

int CvImprovementInfo::getImprovementPillage() const
{
	return m_iImprovementPillage;
}

void CvImprovementInfo::setImprovementPillage(int i)
{
	m_iImprovementPillage = i;
}

int CvImprovementInfo::getImprovementUpgrade() const
{
	return m_iImprovementUpgrade;
}

void CvImprovementInfo::setImprovementUpgrade(int i)
{
	m_iImprovementUpgrade = i;
}

bool CvImprovementInfo::isActsAsCity() const
{
	return m_bActsAsCity;
}

bool CvImprovementInfo::isHillsMakesValid() const
{
	return m_bHillsMakesValid;
}

bool CvImprovementInfo::isFreshWaterMakesValid() const
{
	return m_bFreshWaterMakesValid;
}

bool CvImprovementInfo::isFloodPlainsMakesValid() const
{
	return m_bFloodPlainsMakesValid;
}

bool CvImprovementInfo::isRiverSideMakesValid() const
{
	return m_bRiverSideMakesValid;
}

bool CvImprovementInfo::isNoFreshWater() const
{
	return m_bNoFreshWater;
}

bool CvImprovementInfo::isRequiresFlatlands() const
{
	return m_bRequiresFlatlands;
}

bool CvImprovementInfo::isRequiresRiverSide() const
{
	return m_bRequiresRiverSide;
}

bool CvImprovementInfo::isRequiresIrrigation() const
{
	return m_bRequiresIrrigation;
}

bool CvImprovementInfo::isCarriesIrrigation() const
{
	return m_bCarriesIrrigation;
}

bool CvImprovementInfo::isRequiresFeature() const
{
	return m_bRequiresFeature;
}

bool CvImprovementInfo::isWater() const
{
	return m_bWater;
}

bool CvImprovementInfo::isGoody() const
{
	return m_bGoody;
}

bool CvImprovementInfo::isPermanent() const
{
	return m_bPermanent;
}

const TCHAR* CvImprovementInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvImprovementInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

int CvImprovementInfo::getWorldSoundscapeScriptId() const
{
	return m_iWorldSoundscapeScriptId;
}

//FfH Improvements: Added by Kael 08/07/2007
int CvImprovementInfo::getAppearanceProbability() const
{
	return m_iAppearanceProbability;
}

int CvImprovementInfo::getHealRateChange() const
{
	return m_iHealRateChange;
}

int CvImprovementInfo::getDestroyAdjacentImprovementChance() const
{
	return m_iDestroyAdjacentImprovementChance;
}

int CvImprovementInfo::getRange() const
{
	return m_iRange;
}

int CvImprovementInfo::getRangeDefenseModifier() const
{
	return m_iRangeDefenseModifier;
}

int CvImprovementInfo::getBonusConvert() const
{
	return m_iBonusConvert;
}

int CvImprovementInfo::getFeatureUpgrade() const
{
	return m_iFeatureUpgrade;
}

int CvImprovementInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

const TCHAR *CvImprovementInfo::getPythonAtRange() const
{
	return m_szPythonAtRange;
}

const TCHAR *CvImprovementInfo::getPythonOnMove() const
{
	return m_szPythonOnMove;
}

int CvImprovementInfo::getSpawnUnitType() const
{
	return m_iSpawnUnitType;
}

int CvImprovementInfo::getVisibilityChange() const
{
	return m_iVisibilityChange;
}

bool CvImprovementInfo::isRequiresPeak() const
{
	return m_bRequiresPeak;
}

bool CvImprovementInfo::isUnique() const
{
	return m_bUnique;
}
//FfH: End Add

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                   					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvImprovementInfo::getImprovementClassType() const { return m_iImprovementClassType; }
int CvImprovementInfo::getPrereqTerrainSpreadResources() const { return m_iPrereqTerrainSpreadResources; }
int CvImprovementInfo::getGoldCost() const { return m_iGoldCost; }
int CvImprovementInfo::getYieldCost(int i) const { return m_piYieldCost ? m_piYieldCost[i] : -1; }

int CvImprovementInfo::getCultureChange() const
{
	return m_iCultureChange;
}

int CvImprovementInfo::getHealth() const
{
	return m_iHealth;
}

int CvImprovementInfo::getAdjacentFindResourceModify() const
{
	return m_iAdjacentFindResourceModify;
}

int CvImprovementInfo::getMinWilderness() const
{
	return m_iMinWilderness;
}

int CvImprovementInfo::getMaxWilderness() const
{
	return m_iMaxWilderness;
}

int CvImprovementInfo::getSpawnGroup() const
{
	return m_iSpawnGroup;
}

int CvImprovementInfo::getDungeonType() const
{
	return m_iDungeonType;
}

/** multibarb **/
bool CvImprovementInfo::isDefaultBuildableAllCivs() const { return m_bDefaultBuildableAllCivs; }

int CvImprovementInfo::getSpawnUnitCiv() const
{
	return m_iSpawnUnitCiv;
}

int CvImprovementInfo::getNativePlane() const
{
	return m_iNativePlane;
}

int CvImprovementInfo::getAppearanceTechs(int i) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piAppearanceTechs ? m_piAppearanceTechs[i] : -1;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Arrays

int CvImprovementInfo::getPrereqNatureYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPrereqNatureYield ? m_piPrereqNatureYield[i] : -1;
}

int* CvImprovementInfo::getPrereqNatureYieldArray()
{
	return m_piPrereqNatureYield;
}

int CvImprovementInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int* CvImprovementInfo::getYieldChangeArray()
{
	return m_piYieldChange;
}

int CvImprovementInfo::getRiverSideYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverSideYieldChange ? m_piRiverSideYieldChange[i] : -1;
}

int* CvImprovementInfo::getRiverSideYieldChangeArray()
{
	return m_piRiverSideYieldChange;
}

int CvImprovementInfo::getHillsYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;
}

int* CvImprovementInfo::getHillsYieldChangeArray()
{
	return m_piHillsYieldChange;
}

int CvImprovementInfo::getIrrigatedYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piIrrigatedChange ? m_piIrrigatedChange[i] : -1;
}

int* CvImprovementInfo::getIrrigatedYieldChangeArray()
{
	return m_piIrrigatedChange;
}

bool CvImprovementInfo::getTerrainMakesValid(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrainMakesValid ? m_pbTerrainMakesValid[i] : false;
}

bool CvImprovementInfo::getFeatureMakesValid(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureMakesValid ? m_pbFeatureMakesValid[i] : false;
}

int CvImprovementInfo::getTechYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiTechYieldChanges[i][j];
}

int* CvImprovementInfo::getTechYieldChangesArray(int i)
{
	return m_ppiTechYieldChanges[i];
}

int CvImprovementInfo::getRouteYieldChanges(int i, int j) const
{
	FAssertMsg(i < GC.getNumRouteInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_ppiRouteYieldChanges[i][j];
}

int* CvImprovementInfo::getRouteYieldChangesArray(int i)
{
	return m_ppiRouteYieldChanges[i];
}

int CvImprovementInfo::getImprovementBonusYield(int i, int j) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_piYieldChange ? m_paImprovementBonus[i].getYieldChange(j) : -1;
}

bool CvImprovementInfo::isImprovementBonusMakesValid(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_bBonusMakesValid;
}

bool CvImprovementInfo::isImprovementBonusTrade(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_bBonusTrade;
}

int CvImprovementInfo::getImprovementBonusDiscoverRand(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paImprovementBonus[i].m_iDiscoverRand;
}

const TCHAR* CvImprovementInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoImprovement * pImprovementArtInfo;
	pImprovementArtInfo = getArtInfo();
	if (pImprovementArtInfo != NULL)
	{
		return pImprovementArtInfo->getButton();
	}
	return NULL;
}

const CvArtInfoImprovement* CvImprovementInfo::getArtInfo() const
{
	return ARTFILEMGR.getImprovementArtInfo(getArtDefineTag());
}

const TCHAR* CvArtInfoImprovement::getShaderNIF() const
{
	return m_szShaderNIF;
}
void CvArtInfoImprovement::setShaderNIF(const TCHAR* szDesc)
{
	m_szShaderNIF = szDesc;
}

void CvImprovementInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iAdvancedStartCost);
	stream->Read(&m_iAdvancedStartCostIncrease);

	stream->Read(&m_iTilesPerGoody);
	stream->Read(&m_iGoodyUniqueRange);
	stream->Read(&m_iFeatureGrowthProbability);
	stream->Read(&m_iUpgradeTime);
	stream->Read(&m_iAirBombDefense);
	stream->Read(&m_iDefenseModifier);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iPillageGold);
	stream->Read(&m_iImprovementPillage);
	stream->Read(&m_iImprovementUpgrade);

	stream->Read(&m_bActsAsCity);
	stream->Read(&m_bHillsMakesValid);
	stream->Read(&m_bFreshWaterMakesValid);
	stream->Read(&m_bRiverSideMakesValid);
	stream->Read(&m_bNoFreshWater);
	stream->Read(&m_bRequiresFlatlands);
	stream->Read(&m_bRequiresRiverSide);
	stream->Read(&m_bRequiresIrrigation);
	stream->Read(&m_bCarriesIrrigation);
	stream->Read(&m_bRequiresFeature);
	stream->Read(&m_bWater);
	stream->Read(&m_bGoody);
	stream->Read(&m_bPermanent);
	stream->Read(&m_bOutsideBorders);

	stream->ReadString(m_szArtDefineTag);

	stream->Read(&m_iWorldSoundscapeScriptId);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Read(&m_bRequiresPeak);
	stream->Read(&m_bUnique);
	stream->Read(&m_iAppearanceProbability);
	stream->Read(&m_iHealRateChange);
	stream->Read(&m_iRange);
	stream->Read(&m_iRangeDefenseModifier);
	stream->Read(&m_iBonusConvert);
	stream->Read(&m_iFeatureUpgrade);
	stream->Read(&m_iPrereqCivilization);
	stream->ReadString(m_szPythonAtRange);
	stream->ReadString(m_szPythonOnMove);
	stream->Read(&m_iSpawnUnitType);
	stream->Read(&m_iVisibilityChange);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                   					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
/** multibarb **/
	stream->Read(&m_iSpawnUnitCiv);

	SAFE_DELETE_ARRAY(m_piAppearanceTechs);
	m_piAppearanceTechs = new int[GC.getNumTechInfos()];
	stream->Read(GC.getNumTechInfos(), m_piAppearanceTechs);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	// Arrays

	SAFE_DELETE_ARRAY(m_piPrereqNatureYield);
	m_piPrereqNatureYield = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piPrereqNatureYield);

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);

	SAFE_DELETE_ARRAY(m_piRiverSideYieldChange);
	m_piRiverSideYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piRiverSideYieldChange);

	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	m_piHillsYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piHillsYieldChange);

	SAFE_DELETE_ARRAY(m_piIrrigatedChange);
	m_piIrrigatedChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piIrrigatedChange);

	SAFE_DELETE_ARRAY(m_pbTerrainMakesValid);
	m_pbTerrainMakesValid = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrainMakesValid);

	SAFE_DELETE_ARRAY(m_pbFeatureMakesValid);
	m_pbFeatureMakesValid = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeatureMakesValid);

	SAFE_DELETE_ARRAY(m_paImprovementBonus);
	m_paImprovementBonus = new CvImprovementBonusInfo[GC.getNumBonusInfos()];
	int i;
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		m_paImprovementBonus[i].read(stream);
	}

	if (m_ppiTechYieldChanges != NULL)
	{
		for(i=0;i<GC.getNumTechInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppiTechYieldChanges[i]);
		}
		SAFE_DELETE_ARRAY(m_ppiTechYieldChanges);
	}

	m_ppiTechYieldChanges = new int*[GC.getNumTechInfos()];
	for(i=0;i<GC.getNumTechInfos();i++)
	{
		m_ppiTechYieldChanges[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppiTechYieldChanges[i]);
	}

	if (m_ppiRouteYieldChanges != NULL)
	{
		for(i=0;i<GC.getNumRouteInfos();i++)
		{
			SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges[i]);
		}
		SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges);
	}

	m_ppiRouteYieldChanges = new int*[GC.getNumRouteInfos()];
	for(i=0;i<GC.getNumRouteInfos();i++)
	{
		m_ppiRouteYieldChanges[i]  = new int[NUM_YIELD_TYPES];
		stream->Read(NUM_YIELD_TYPES, m_ppiRouteYieldChanges[i]);
	}
}

void CvImprovementInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iAdvancedStartCost);
	stream->Write(m_iAdvancedStartCostIncrease);

	stream->Write(m_iTilesPerGoody);
	stream->Write(m_iGoodyUniqueRange);
	stream->Write(m_iFeatureGrowthProbability);
	stream->Write(m_iUpgradeTime);
	stream->Write(m_iAirBombDefense);
	stream->Write(m_iDefenseModifier);
	stream->Write(m_iHappiness);
	stream->Write(m_iPillageGold);
	stream->Write(m_iImprovementPillage);
	stream->Write(m_iImprovementUpgrade);

	stream->Write(m_bActsAsCity);
	stream->Write(m_bHillsMakesValid);
	stream->Write(m_bFreshWaterMakesValid);
	stream->Write(m_bRiverSideMakesValid);
	stream->Write(m_bNoFreshWater);
	stream->Write(m_bRequiresFlatlands);
	stream->Write(m_bRequiresRiverSide);
	stream->Write(m_bRequiresIrrigation);
	stream->Write(m_bCarriesIrrigation);
	stream->Write(m_bRequiresFeature);
	stream->Write(m_bWater);
	stream->Write(m_bGoody);
	stream->Write(m_bPermanent);
	stream->Write(m_bOutsideBorders);

	stream->WriteString(m_szArtDefineTag);

	stream->Write(m_iWorldSoundscapeScriptId);

//FfH Improvements: Added by Kael 08/07/2007
	stream->Write(m_bRequiresPeak);
	stream->Write(m_bUnique);
	stream->Write(m_iAppearanceProbability);
	stream->Write(m_iHealRateChange);
	stream->Write(m_iRange);
	stream->Write(m_iRangeDefenseModifier);
	stream->Write(m_iBonusConvert);
	stream->Write(m_iFeatureUpgrade);
	stream->Write(m_iPrereqCivilization);
	stream->WriteString(m_szPythonAtRange);
	stream->WriteString(m_szPythonOnMove);
	stream->Write(m_iSpawnUnitType);
	stream->Write(m_iVisibilityChange);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                   					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
/** multibarb **/
	stream->Write(m_iSpawnUnitCiv);
    stream->Write(GC.getNumTechInfos(), m_piAppearanceTechs);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	// Arrays

	stream->Write(NUM_YIELD_TYPES, m_piPrereqNatureYield);
	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piRiverSideYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piHillsYieldChange);
	stream->Write(NUM_YIELD_TYPES, m_piIrrigatedChange);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrainMakesValid);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeatureMakesValid);

	int i;
	for (i = 0; i < GC.getNumBonusInfos(); i++)
	{
		m_paImprovementBonus[i].write(stream);
	}

	for(i=0;i<GC.getNumTechInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppiTechYieldChanges[i]);
	}

	for(i=0;i<GC.getNumRouteInfos();i++)
	{
		stream->Write(NUM_YIELD_TYPES, m_ppiRouteYieldChanges[i]);
	}
}
bool CvImprovementInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int iIndex, j, iNumSibs;

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqNatureYields"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piPrereqNatureYield);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piPrereqNatureYield, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverSideYieldChange"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piRiverSideYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverSideYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HillsYieldChange"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piHillsYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piHillsYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"IrrigatedYieldChange"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piIrrigatedChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piIrrigatedChange, NUM_YIELD_TYPES);
	}

	pXML->GetChildXmlValByName(&m_iAdvancedStartCost, "iAdvancedStartCost");
	pXML->GetChildXmlValByName(&m_iAdvancedStartCostIncrease, "iAdvancedStartCostIncrease");
	pXML->GetChildXmlValByName(&m_bActsAsCity, "bActsAsCity");
	pXML->GetChildXmlValByName(&m_bHillsMakesValid, "bHillsMakesValid");
	pXML->GetChildXmlValByName(&m_bFreshWaterMakesValid, "bFreshWaterMakesValid");
	pXML->GetChildXmlValByName(&m_bFloodPlainsMakesValid, "bFloodPlainsMakesValid");
	pXML->GetChildXmlValByName(&m_bRiverSideMakesValid, "bRiverSideMakesValid");
	pXML->GetChildXmlValByName(&m_bNoFreshWater, "bNoFreshWater");
	pXML->GetChildXmlValByName(&m_bRequiresFlatlands, "bRequiresFlatlands");
	pXML->GetChildXmlValByName(&m_bRequiresRiverSide, "bRequiresRiverSide");
	pXML->GetChildXmlValByName(&m_bRequiresIrrigation, "bRequiresIrrigation");
	pXML->GetChildXmlValByName(&m_bCarriesIrrigation, "bCarriesIrrigation");
	pXML->GetChildXmlValByName(&m_bRequiresFeature, "bRequiresFeature");
	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(&m_bGoody, "bGoody");
	pXML->GetChildXmlValByName(&m_bPermanent, "bPermanent");
	pXML->GetChildXmlValByName(&m_iTilesPerGoody, "iTilesPerGoody");
	pXML->GetChildXmlValByName(&m_iGoodyUniqueRange, "iGoodyRange");
	pXML->GetChildXmlValByName(&m_iFeatureGrowthProbability, "iFeatureGrowth");
	pXML->GetChildXmlValByName(&m_iUpgradeTime, "iUpgradeTime");
	pXML->GetChildXmlValByName(&m_iAirBombDefense, "iAirBombDefense");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefenseModifier");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iPillageGold, "iPillageGold");
	pXML->GetChildXmlValByName(&m_bOutsideBorders, "bOutsideBorders");

	pXML->SetVariableListTagPair(&m_pbTerrainMakesValid, "TerrainMakesValids", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureMakesValid, "FeatureMakesValids", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusTypeStructs"))
	{
		// call the function that sets the bonus booleans
		pXML->SetImprovementBonuses(&m_paImprovementBonus);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		// initialize the boolean list to the correct size and all the booleans to false
		pXML->InitImprovementBonusList(&m_paImprovementBonus, GC.getNumBonusInfos());
	}

	// initialize the boolean list to the correct size and all the booleans to false
	FAssertMsg((GC.getNumTechInfos() > 0) && (NUM_YIELD_TYPES) > 0,"either the number of tech infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiTechYieldChanges, GC.getNumTechInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiTechYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TechYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiTechYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiTechYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	// initialize the boolean list to the correct size and all the booleans to false
	FAssertMsg((GC.getNumRouteInfos() > 0) && (NUM_YIELD_TYPES) > 0,"either the number of route infos is zero or less or the number of yield types is zero or less");
	pXML->Init2DIntList(&m_ppiRouteYieldChanges, GC.getNumRouteInfos(), NUM_YIELD_TYPES);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RouteYieldChanges"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{

				if (0 < iNumSibs)
				{
					for (j=0;j<iNumSibs;j++)
					{
						pXML->GetChildXmlValByName(szTextVal, "RouteType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							// delete the array since it will be reallocated
							SAFE_DELETE_ARRAY(m_ppiRouteYieldChanges[iIndex]);
							// if we can set the current xml node to it's next sibling
							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RouteYields"))
							{
								// call the function that sets the yield change variable
								pXML->SetYields(&m_ppiRouteYieldChanges[iIndex]);
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
							else
							{
								pXML->InitList(&m_ppiRouteYieldChanges[iIndex], NUM_YIELD_TYPES);
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "WorldSoundscapeAudioScript");
	if ( szTextVal.GetLength() > 0 )
		m_iWorldSoundscapeScriptId = gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_SOUNDSCAPE );
	else
		m_iWorldSoundscapeScriptId = -1;

//FfH Improvements: Added by Kael 08/07/2007
	pXML->GetChildXmlValByName(&m_bRequiresPeak, "bRequiresPeak");
	pXML->GetChildXmlValByName(&m_bUnique, "bUnique");
	pXML->GetChildXmlValByName(&m_iAppearanceProbability, "iAppearanceProbability");
	pXML->GetChildXmlValByName(&m_iHealRateChange, "iHealRateChange");
	pXML->GetChildXmlValByName(&m_iDestroyAdjacentImprovementChance, "iDestroyAdjacentImprovementChance");
	pXML->GetChildXmlValByName(&m_iRange, "iRange");
	pXML->GetChildXmlValByName(&m_iRangeDefenseModifier, "iRangeDefenseModifier");
	pXML->GetChildXmlValByName(&m_iVisibilityChange, "iVisibilityChange");
	pXML->GetChildXmlValByName(szTextVal, "BonusConvert");
	m_iBonusConvert = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureUpgrade");
	m_iFeatureUpgrade = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization");
	m_aszExtraXML2forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(m_szPythonAtRange, "PythonAtRange");
	pXML->GetChildXmlValByName(m_szPythonOnMove, "PythonOnMove");
	pXML->GetChildXmlValByName(szTextVal, "SpawnUnitType");
	m_aszExtraXMLforPass3.push_back(szTextVal);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                   					**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "PrereqTerrainSpreadResources");
	m_iPrereqTerrainSpreadResources = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(&m_iImprovementClassType, "iImprovementClassType",-1);
	pXML->GetChildXmlValByName(&m_iGoldCost, "iGoldCost", 0);
	pXML->GetChildXmlValByName(&m_iCultureChange, "iCultureChange");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iAdjacentFindResourceModify, "iAdjacentFindResourceModify");
	pXML->GetChildXmlValByName(&m_iMinWilderness, "iMinWilderness",0);
	pXML->GetChildXmlValByName(&m_iMaxWilderness, "iMaxWilderness", MAX_INT);
	pXML->GetChildXmlValByName(szTextVal, "SpawnGroup");
	m_iSpawnGroup = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DungeonType");
	m_iDungeonType = GC.getInfoTypeForString(szTextVal);
/** multibarb **/
	pXML->GetChildXmlValByName(&m_bDefaultBuildableAllCivs, "bDefaultBuildableAllCivs");
	pXML->GetChildXmlValByName(szTextVal, "SpawnUnitCiv");
	m_aszExtraXML3forPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "NativePlane");
	m_aszExtraXML4forPass3.push_back(szTextVal);

    pXML->SetVariableListTagPair(&m_piAppearanceTechs, "AppearanceTechs", sizeof(GC.getTechInfo((TechTypes)0)), GC.getNumTechInfos());

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldCosts"))
	{
		// call the function that sets the yield change variable
		pXML->SetYields(&m_piYieldCost);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldCost, NUM_YIELD_TYPES);
	}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}

bool CvImprovementInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "ImprovementPillage");
	m_iImprovementPillage = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ImprovementUpgrade");
	m_iImprovementUpgrade = GC.getInfoTypeForString(szTextVal);

	return true;
}

//FfH Improvements: Added by Kael 05/12/2007
bool CvImprovementInfo::readPass3()
{
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                   					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

	m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXML2forPass3[0]);
	m_aszExtraXML2forPass3.clear();
	m_iSpawnUnitType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_aszExtraXMLforPass3.clear();
/**								----  End Original Code  ----									**/
/** multibarb **/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iSpawnUnitType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
	m_aszExtraXMLforPass3.clear();

	iSize = m_aszExtraXML2forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML2forPass3[i], true) != -1)
		{
			m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXML2forPass3[i]);
			break;
		}
	}
	m_aszExtraXML2forPass3.clear();

	iSize = m_aszExtraXML3forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML3forPass3[i], true) != -1)
		{
			m_iSpawnUnitCiv = GC.getInfoTypeForString(m_aszExtraXML3forPass3[i]);
			break;
		}
	}
	m_aszExtraXML3forPass3.clear();

	iSize = m_aszExtraXML4forPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXML4forPass3[i], true) != -1)
		{
			m_iNativePlane = GC.getInfoTypeForString(m_aszExtraXML4forPass3[i]);
			break;
		}
	}
	m_aszExtraXML4forPass3.clear();

	return true;
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(ImprovementInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvImprovementInfo::copyNonDefaults(CvImprovementInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()									== cDefault)		setArtDefineTag(							pClassInfo->getArtDefineTag());
	//Must do Art Define before InfoBase to get the right button on time
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isActsAsCity()										== false)			m_bActsAsCity								= pClassInfo->isActsAsCity();
	if (isHillsMakesValid()									== false)			m_bHillsMakesValid							= pClassInfo->isHillsMakesValid();
	if (isFreshWaterMakesValid()							== false)			m_bFreshWaterMakesValid						= pClassInfo->isFreshWaterMakesValid();
	if (isFloodPlainsMakesValid()							== false)			m_bFloodPlainsMakesValid					= pClassInfo->isFloodPlainsMakesValid();
	if (isRiverSideMakesValid()								== false)			m_bRiverSideMakesValid						= pClassInfo->isRiverSideMakesValid();
	if (isNoFreshWater()									== false)			m_bNoFreshWater								= pClassInfo->isNoFreshWater();
	if (isRequiresFlatlands()								== false)			m_bRequiresFlatlands						= pClassInfo->isRequiresFlatlands();
	if (isRequiresRiverSide()								== false)			m_bRequiresRiverSide						= pClassInfo->isRequiresRiverSide();
	if (isRequiresIrrigation()								== false)			m_bRequiresIrrigation						= pClassInfo->isRequiresIrrigation();
	if (isCarriesIrrigation()								== false)			m_bCarriesIrrigation						= pClassInfo->isCarriesIrrigation();
	if (isRequiresFeature()									== false)			m_bRequiresFeature							= pClassInfo->isRequiresFeature();
	if (isWater()											== false)			m_bWater									= pClassInfo->isWater();
	if (isGoody()											== false)			m_bGoody									= pClassInfo->isGoody();
	if (isPermanent()										== false)			m_bPermanent								= pClassInfo->isPermanent();
	if (isOutsideBorders()									== false)			m_bOutsideBorders							= pClassInfo->isOutsideBorders();
	if (isRequiresPeak()									== false)			m_bRequiresPeak								= pClassInfo->isRequiresPeak();
	if (isUnique()											== false)			m_bUnique									= pClassInfo->isUnique();
	if (getAppearanceProbability()							== 0)				m_iAppearanceProbability					= pClassInfo->getAppearanceProbability();
	if (getHealRateChange()									== 0)				m_iHealRateChange							= pClassInfo->getHealRateChange();
	if (getDestroyAdjacentImprovementChance()				== 0)				m_iDestroyAdjacentImprovementChance			= pClassInfo->getDestroyAdjacentImprovementChance();
	if (getRange()											== 0)				m_iRange									= pClassInfo->getRange();
	if (getRangeDefenseModifier()							== 0)				m_iRangeDefenseModifier						= pClassInfo->getRangeDefenseModifier();
	if (getVisibilityChange()								== 0)				m_iVisibilityChange							= pClassInfo->getVisibilityChange();
	if (getAdvancedStartCostIncrease()						== 0)				m_iAdvancedStartCostIncrease				= pClassInfo->getAdvancedStartCostIncrease();
	if (getTilesPerGoody()									== 0)				m_iTilesPerGoody							= pClassInfo->getTilesPerGoody();
	if (getGoodyUniqueRange()								== 0)				m_iGoodyUniqueRange							= pClassInfo->getGoodyUniqueRange();
	if (getFeatureGrowthProbability()						== 0)				m_iFeatureGrowthProbability					= pClassInfo->getFeatureGrowthProbability();
	if (getUpgradeTime()									== 0)				m_iUpgradeTime								= pClassInfo->getUpgradeTime();
	if (getAirBombDefense()									== 0)				m_iAirBombDefense							= pClassInfo->getAirBombDefense();
	if (getDefenseModifier()								== 0)				m_iDefenseModifier							= pClassInfo->getDefenseModifier();
	if (getHappiness()										== 0)				m_iHappiness								= pClassInfo->getHappiness();
	if (getPillageGold()									== 0)				m_iPillageGold								= pClassInfo->getPillageGold();
	if (getAdvancedStartCost()								== -1)				m_iAdvancedStartCost						= pClassInfo->getAdvancedStartCost();
	if (m_iWorldSoundscapeScriptId							== -1)				m_iWorldSoundscapeScriptId					= pClassInfo->getWorldSoundscapeScriptId();
	if (getPythonAtRange()									== cDefault)		m_szPythonAtRange							= pClassInfo->getPythonAtRange();
	if (getPythonOnMove()									== cDefault)		m_szPythonOnMove							= pClassInfo->getPythonOnMove();
	if (getBonusConvert()									== NO_BONUS)		m_iBonusConvert								= pClassInfo->getBonusConvert();
	if (getFeatureUpgrade()									== NO_FEATURE)		m_iFeatureUpgrade							= pClassInfo->getFeatureUpgrade();
	if (getImprovementClassType()							== -1)				m_iImprovementClassType						= pClassInfo->getImprovementClassType();
	if (getPrereqTerrainSpreadResources()					== -1)				m_iPrereqTerrainSpreadResources				= pClassInfo->getPrereqTerrainSpreadResources();	
	if (getGoldCost()										== 0)				m_iGoldCost									= pClassInfo->getGoldCost();
	if (getCultureChange()									== 0)				m_iCultureChange							= pClassInfo->getCultureChange();
	if (getHealth()											== 0)				m_iHealth									= pClassInfo->getHealth();
	if (getAdjacentFindResourceModify()						== 0)				m_iAdjacentFindResourceModify				= pClassInfo->getAdjacentFindResourceModify();
	if (getMinWilderness()									== 0)				m_iMinWilderness							= pClassInfo->getMinWilderness();
	if (getMaxWilderness()									== MAX_INT)			m_iMaxWilderness							= pClassInfo->getMaxWilderness();
	if (getSpawnGroup()										== NO_AIGROUP)		m_iSpawnGroup								= pClassInfo->getSpawnGroup();
	if (getDungeonType()									== NO_DUNGEON)		m_iDungeonType								= pClassInfo->getDungeonType();
	if (getSpawnUnitCiv()                                   == NO_CIVILIZATION) m_iSpawnUnitCiv								= pClassInfo->getSpawnUnitCiv();
	if (getNativePlane()                                    == NO_PLANE)        m_iNativePlane                              = pClassInfo->getNativePlane();  
	if (isDefaultBuildableAllCivs()                         == false)           m_bDefaultBuildableAllCivs                  = pClassInfo->isDefaultBuildableAllCivs();

	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_piPrereqNatureYield[i]						== 0)				m_piPrereqNatureYield[i]					= pClassInfo->getPrereqNatureYield(i);
		if (m_piYieldChange[i]								== 0)				m_piYieldChange[i]							= pClassInfo->getYieldChange(i);
		if (m_piRiverSideYieldChange[i]						== 0)				m_piRiverSideYieldChange[i]					= pClassInfo->getRiverSideYieldChange(i);
		if (m_piHillsYieldChange[i]							== 0)				m_piHillsYieldChange[i]						= pClassInfo->getHillsYieldChange(i);
		if (m_piIrrigatedChange[i]							== 0)				m_piIrrigatedChange[i]						= pClassInfo->getIrrigatedYieldChange(i);
		if (m_piYieldCost[i]								== 0)				m_piYieldCost[i]							= pClassInfo->getYieldCost(i);
	}
	for (int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (m_pbTerrainMakesValid[i]						== false)			m_pbTerrainMakesValid[i]					= pClassInfo->getTerrainMakesValid(i);
	}
	for (int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if (m_pbFeatureMakesValid[i]						== false)			m_pbFeatureMakesValid[i]					= pClassInfo->getFeatureMakesValid(i);
	}
	for (int i = 0; i < GC.getNumBonusInfos(); i++)
	{
		if (m_paImprovementBonus[i].m_bBonusMakesValid		== false)			m_paImprovementBonus[i].m_bBonusMakesValid	= pClassInfo->isImprovementBonusMakesValid(i);
		if (m_paImprovementBonus[i].m_bBonusTrade			== false)			m_paImprovementBonus[i].m_bBonusTrade		= pClassInfo->isImprovementBonusTrade(i);
		if (m_paImprovementBonus[i].m_iDiscoverRand			== 0)				m_paImprovementBonus[i].m_iDiscoverRand		= pClassInfo->getImprovementBonusDiscoverRand(i);
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_paImprovementBonus[i].m_piYieldChange[j]	== 0)				m_paImprovementBonus[i].m_piYieldChange[j]	= pClassInfo->getImprovementBonusYield(i,j);
		}
	}
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiTechYieldChanges[i][j]					== 0)				m_ppiTechYieldChanges[i][j]					= pClassInfo->getTechYieldChanges(i, j);
		}
	}
	for (int i = 0; i < GC.getNumRouteInfos(); i++)
	{
		for (int j = 0; j < NUM_YIELD_TYPES; j++)
		{
			if (m_ppiRouteYieldChanges[i][j]				== 0)				m_ppiRouteYieldChanges[i][j]				= pClassInfo->getRouteYieldChanges(i, j);
		}
	}

	for ( int i = 0; i < GC.getNumTechInfos(); i++)
	{
		if(getAppearanceTechs(i)			== false)			m_piAppearanceTechs[i]				= pClassInfo->getAppearanceTechs(i);
	}

	//Readpass2 stuff
	if (m_iImprovementPillage								== -1)				m_iImprovementPillage						= pClassInfo->getImprovementPillage();
	if (m_iImprovementUpgrade								== -1)				m_iImprovementUpgrade						= pClassInfo->getImprovementUpgrade();

}

void CvImprovementInfo::copyNonDefaultsReadPass2(CvImprovementInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getImprovementPillage()		!= -1)				m_iImprovementPillage						= pClassInfo->getImprovementPillage();
	if (bOver || pClassInfo->getImprovementUpgrade()		!= -1)				m_iImprovementUpgrade						= pClassInfo->getImprovementUpgrade();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvBonusClassInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBonusClassInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBonusClassInfo::CvBonusClassInfo() :
m_iUniqueRange(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBonusClassInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBonusClassInfo::~CvBonusClassInfo()
{
}

int CvBonusClassInfo::getUniqueRange() const
{
	return m_iUniqueRange;
}

bool CvBonusClassInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iUniqueRange, "iUnique");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBonusClassInfo::copyNonDefaults(CvBonusClassInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getUniqueRange()	== 0)	m_iUniqueRange	= pClassInfo->getUniqueRange();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvBonusInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvBonusInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvBonusInfo::CvBonusInfo() :
m_iBonusClassType(NO_BONUSCLASS),
m_iChar(0),
m_iTechReveal(0),
m_iTechCityTrade(0),
m_iTechObsolete(0),
m_iTechDiscover(0),
m_iAITradeModifier(0),
m_iAIObjective(0),
m_iHealth(0),
m_iHappiness(0),
m_iMinAreaSize(0),
m_iMinLatitude(0),
m_iMaxLatitude(90),
m_iPlacementOrder(0),
m_iConstAppearance(0),
m_iRandAppearance1(0),
m_iRandAppearance2(0),
m_iRandAppearance3(0),
m_iRandAppearance4(0),
m_iPercentPerPlayer(0),
m_iTilesPer(0),
m_iMinLandPercent(0),
m_iUniqueRange(0),
m_iGroupRange(0),
m_iGroupRand(0),
m_bOneArea(false),
m_bHills(false),
m_bFlatlands(false),
m_bNoRiverSide(false),
m_bNoTrade(false),
m_bNormalize(false),
m_piYieldChange(NULL),
m_piImprovementChange(NULL),
m_pbTerrain(NULL),
m_pbFeature(NULL),
m_pbFeatureTerrain(NULL),

//FfH: Added by Kael 08/16/2007
m_bModifierPerBonus(false),
m_iBadAttitude(0),
m_iDamageType(NO_DAMAGE),
m_iDiscoverRandModifier(0),
m_iFreePromotion(NO_PROMOTION),
m_iGreatPeopleRateModifier(0),
m_iHealChange(0),
m_iHealChangeEnemy(0),
m_iMaintenanceModifier(0),
m_iMutateChance(0),
m_iResearchModifier(0),
//FfH: End Add
m_iCityYieldModifierType(-1),
m_iCityCommerceModifierType(-1),
m_iCityBonusModifier(0),
m_iEnchantedWeaponBonus(0),
m_iMinWilderness(0),
m_iMaxWilderness(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvBonusInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvBonusInfo::~CvBonusInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piImprovementChange);
	SAFE_DELETE_ARRAY(m_pbTerrain);
	SAFE_DELETE_ARRAY(m_pbFeature);
	SAFE_DELETE_ARRAY(m_pbFeatureTerrain);	// free memory - MT
}

int CvBonusInfo::getBonusClassType() const
{
	return m_iBonusClassType;
}

int CvBonusInfo::getChar() const
{
	return m_iChar;
}

void CvBonusInfo::setChar(int i)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iChar = i;
/**								----  End Original Code  ----									**/
	m_iChar = i + 125;
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvBonusInfo::getTechReveal() const
{
	return m_iTechReveal;
}

int CvBonusInfo::getTechCityTrade() const
{
	return m_iTechCityTrade;
}

int CvBonusInfo::getTechObsolete() const
{
	return m_iTechObsolete;
}

int CvBonusInfo::getTechDiscover() const
{
	return m_iTechDiscover;
}

int CvBonusInfo::getAITradeModifier() const
{
	return m_iAITradeModifier;
}

int CvBonusInfo::getAIObjective() const
{
	return m_iAIObjective;
}

int CvBonusInfo::getHealth() const
{
	return m_iHealth;
}

int CvBonusInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvBonusInfo::getMinAreaSize() const
{
	return m_iMinAreaSize;
}

int CvBonusInfo::getMinLatitude() const
{
	return m_iMinLatitude;
}

int CvBonusInfo::getMaxLatitude() const
{
	return m_iMaxLatitude;
}

int CvBonusInfo::getPlacementOrder() const
{
	return m_iPlacementOrder;
}

int CvBonusInfo::getConstAppearance() const
{
	return m_iConstAppearance;
}

int CvBonusInfo::getRandAppearance1() const
{
	return m_iRandAppearance1;
}

int CvBonusInfo::getRandAppearance2() const
{
	return m_iRandAppearance2;
}

int CvBonusInfo::getRandAppearance3() const
{
	return m_iRandAppearance3;
}

int CvBonusInfo::getRandAppearance4() const
{
	return m_iRandAppearance4;
}

int CvBonusInfo::getPercentPerPlayer() const
{
	return m_iPercentPerPlayer;
}

int CvBonusInfo::getTilesPer() const
{
	return m_iTilesPer;
}

int CvBonusInfo::getMinLandPercent() const
{
	return m_iMinLandPercent;
}

int CvBonusInfo::getUniqueRange() const
{
	return m_iUniqueRange;
}

int CvBonusInfo::getGroupRange() const
{
	return m_iGroupRange;
}

int CvBonusInfo::getGroupRand() const
{
	return m_iGroupRand;
}

bool CvBonusInfo::isOneArea() const
{
	return m_bOneArea;
}

bool CvBonusInfo::isHills() const
{
	return m_bHills;
}

bool CvBonusInfo::isFlatlands() const
{
	return m_bFlatlands;
}

bool CvBonusInfo::isNoRiverSide() const
{
	return m_bNoRiverSide;
}

bool CvBonusInfo::isNoTrade() const
{
	return m_bNoTrade;
}

bool CvBonusInfo::isNormalize() const
{
	return m_bNormalize;
}

const TCHAR* CvBonusInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvBonusInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

//FfH: Added by Kael 08/16/2007
bool CvBonusInfo::isModifierPerBonus() const
{
	return m_bModifierPerBonus;
}

int CvBonusInfo::getBadAttitude() const
{
	return m_iBadAttitude;
}

int CvBonusInfo::getDamageType() const
{
	return m_iDamageType;
}

int CvBonusInfo::getDiscoverRandModifier() const
{
	return m_iDiscoverRandModifier;
}

int CvBonusInfo::getFreePromotion() const
{
	return m_iFreePromotion;
}

int CvBonusInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvBonusInfo::getHealChange() const
{
	return m_iHealChange;
}

int CvBonusInfo::getHealChangeEnemy() const
{
	return m_iHealChangeEnemy;
}

int CvBonusInfo::getMaintenanceModifier() const
{
	return m_iMaintenanceModifier;
}

int CvBonusInfo::getMutateChance() const
{
	return m_iMutateChance;
}

int CvBonusInfo::getResearchModifier() const
{
	return m_iResearchModifier;
}
//FfH: End Add
int CvBonusInfo::getEnchantedWeaponBonus() const
{
	return m_iEnchantedWeaponBonus;
}

int CvBonusInfo::getCityYieldModifierType() const
{
	return m_iCityYieldModifierType;
}

int CvBonusInfo::getCityCommerceModifierType() const
{
	return m_iCityCommerceModifierType;
}

int CvBonusInfo::getCityBonusModifier() const
{
	return m_iCityBonusModifier;
}

int CvBonusInfo::getMinWilderness() const
{
	return m_iMinWilderness;
}

int CvBonusInfo::getMaxWilderness() const
{
	return m_iMaxWilderness;
}

// Arrays

int CvBonusInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int* CvBonusInfo::getYieldChangeArray()
{
	return m_piYieldChange;
}

int CvBonusInfo::getImprovementChange(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piImprovementChange ? m_piImprovementChange[i] : -1;
}

bool CvBonusInfo::isTerrain(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrain ?	m_pbTerrain[i] : false;
}

bool CvBonusInfo::isFeature(int i) const
{
	FAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeature ? m_pbFeature[i] : false;
}

bool CvBonusInfo::isFeatureTerrain(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbFeatureTerrain ?	m_pbFeatureTerrain[i] : false;
}

const TCHAR* CvBonusInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoBonus * pBonusArtInfo;
	pBonusArtInfo = getArtInfo();
	if (pBonusArtInfo != NULL)
	{
		return pBonusArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

void CvBonusInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iBonusClassType);
	stream->Read(&m_iChar);
	stream->Read(&m_iTechReveal);
	stream->Read(&m_iTechCityTrade);
	stream->Read(&m_iTechObsolete);
	stream->Read(&m_iTechDiscover);
	stream->Read(&m_iAITradeModifier);
	stream->Read(&m_iAIObjective);
	stream->Read(&m_iHealth);
	stream->Read(&m_iHappiness);
	stream->Read(&m_iMinAreaSize);
	stream->Read(&m_iMinLatitude);
	stream->Read(&m_iMaxLatitude);
	stream->Read(&m_iPlacementOrder);
	stream->Read(&m_iConstAppearance);
	stream->Read(&m_iRandAppearance1);
	stream->Read(&m_iRandAppearance2);
	stream->Read(&m_iRandAppearance3);
	stream->Read(&m_iRandAppearance4);
	stream->Read(&m_iPercentPerPlayer);
	stream->Read(&m_iTilesPer);
	stream->Read(&m_iMinLandPercent);
	stream->Read(&m_iUniqueRange);
	stream->Read(&m_iGroupRange);
	stream->Read(&m_iGroupRand);

	stream->Read(&m_bOneArea);
	stream->Read(&m_bHills);
	stream->Read(&m_bFlatlands);
	stream->Read(&m_bNoRiverSide);
	stream->Read(&m_bNormalize);

	stream->ReadString(m_szArtDefineTag);

//FfH: Added by Kael 08/16/2007
	stream->Read(&m_bModifierPerBonus);
	stream->Read(&m_iBadAttitude);
	stream->Read(&m_iDamageType);
	stream->Read(&m_iDiscoverRandModifier);
	stream->Read(&m_iFreePromotion);
	stream->Read(&m_iGreatPeopleRateModifier);
	stream->Read(&m_iHealChange);
	stream->Read(&m_iHealChangeEnemy);
	stream->Read(&m_iMaintenanceModifier);
	stream->Read(&m_iMutateChance);
	stream->Read(&m_iResearchModifier);
//FfH: End Add

	// Arrays

	SAFE_DELETE_ARRAY(m_piYieldChange);
	m_piYieldChange = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piYieldChange);

	SAFE_DELETE_ARRAY(m_piImprovementChange);
	m_piImprovementChange = new int[GC.getNumImprovementInfos()];
	stream->Read(GC.getNumImprovementInfos(), m_piImprovementChange);

	SAFE_DELETE_ARRAY(m_pbTerrain);
	m_pbTerrain = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbTerrain);

	SAFE_DELETE_ARRAY(m_pbFeature);
	m_pbFeature = new bool[GC.getNumFeatureInfos()];
	stream->Read(GC.getNumFeatureInfos(), m_pbFeature);

	SAFE_DELETE_ARRAY(m_pbFeatureTerrain);
	m_pbFeatureTerrain = new bool[GC.getNumTerrainInfos()];
	stream->Read(GC.getNumTerrainInfos(), m_pbFeatureTerrain);
}

void CvBonusInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iBonusClassType);
	stream->Write(m_iChar);
	stream->Write(m_iTechReveal);
	stream->Write(m_iTechCityTrade);
	stream->Write(m_iTechObsolete);
	stream->Write(m_iTechDiscover);
	stream->Write(m_iAITradeModifier);
	stream->Write(m_iAIObjective);
	stream->Write(m_iHealth);
	stream->Write(m_iHappiness);
	stream->Write(m_iMinAreaSize);
	stream->Write(m_iMinLatitude);
	stream->Write(m_iMaxLatitude);
	stream->Write(m_iPlacementOrder);
	stream->Write(m_iConstAppearance);
	stream->Write(m_iRandAppearance1);
	stream->Write(m_iRandAppearance2);
	stream->Write(m_iRandAppearance3);
	stream->Write(m_iRandAppearance4);
	stream->Write(m_iPercentPerPlayer);
	stream->Write(m_iTilesPer);
	stream->Write(m_iMinLandPercent);
	stream->Write(m_iUniqueRange);
	stream->Write(m_iGroupRange);
	stream->Write(m_iGroupRand);

	stream->Write(m_bOneArea);
	stream->Write(m_bHills);
	stream->Write(m_bFlatlands);
	stream->Write(m_bNoRiverSide);
	stream->Write(m_bNormalize);

	stream->WriteString(m_szArtDefineTag);

//FfH: Added by Kael 08/16/2007
	stream->Write(m_bModifierPerBonus);
	stream->Write(m_iBadAttitude);
	stream->Write(m_iDamageType);
	stream->Write(m_iDiscoverRandModifier);
	stream->Write(m_iFreePromotion);
	stream->Write(m_iGreatPeopleRateModifier);
	stream->Write(m_iHealChange);
	stream->Write(m_iHealChangeEnemy);
	stream->Write(m_iMaintenanceModifier);
	stream->Write(m_iMutateChance);
	stream->Write(m_iResearchModifier);
//FfH: End Add

	// Arrays

	stream->Write(NUM_YIELD_TYPES, m_piYieldChange);
	stream->Write(GC.getNumImprovementInfos(), m_piImprovementChange);
	stream->Write(GC.getNumTerrainInfos(), m_pbTerrain);
	stream->Write(GC.getNumFeatureInfos(), m_pbFeature);
	stream->Write(GC.getNumTerrainInfos(), m_pbFeatureTerrain);
}

bool CvBonusInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName( szTextVal, "BonusClassType");
	m_iBonusClassType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "TechReveal");
	m_iTechReveal = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "TechCityTrade");
	m_iTechCityTrade = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "TechObsolete");
	m_iTechObsolete = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechDiscover");
	m_iTechDiscover = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	pXML->GetChildXmlValByName(&m_iAITradeModifier, "iAITradeModifier");
	pXML->GetChildXmlValByName(&m_iAIObjective, "iAIObjective");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iMinAreaSize, "iMinAreaSize");
	pXML->GetChildXmlValByName(&m_iMinLatitude, "iMinLatitude");
	pXML->GetChildXmlValByName(&m_iMaxLatitude, "iMaxLatitude", 90);
	pXML->GetChildXmlValByName(&m_iPlacementOrder, "iPlacementOrder");
	pXML->GetChildXmlValByName(&m_iConstAppearance, "iConstAppearance");

	// if we can set the current xml node to it's next sibling
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Rands"))
	{
		pXML->GetChildXmlValByName(&m_iRandAppearance1, "iRandApp1");
		pXML->GetChildXmlValByName(&m_iRandAppearance2, "iRandApp2");
		pXML->GetChildXmlValByName(&m_iRandAppearance3, "iRandApp3");
		pXML->GetChildXmlValByName(&m_iRandAppearance4, "iRandApp4");

		// set the current xml node to it's parent node
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(&m_iPercentPerPlayer, "iPlayer");
	pXML->GetChildXmlValByName(&m_iTilesPer, "iTilesPer");
	pXML->GetChildXmlValByName(&m_iMinLandPercent, "iMinLandPercent");
	pXML->GetChildXmlValByName(&m_iUniqueRange, "iUnique");
	pXML->GetChildXmlValByName(&m_iGroupRange, "iGroupRange");
	pXML->GetChildXmlValByName(&m_iGroupRand, "iGroupRand");
	pXML->GetChildXmlValByName(&m_bOneArea, "bArea");
	pXML->GetChildXmlValByName(&m_bHills, "bHills");
	pXML->GetChildXmlValByName(&m_bFlatlands, "bFlatlands");
	pXML->GetChildXmlValByName(&m_bNoRiverSide, "bNoRiverSide");
	pXML->GetChildXmlValByName(&m_bNormalize, "bNormalize");
	pXML->GetChildXmlValByName(&m_bNoTrade, "bNoTrade");

	pXML->SetVariableListTagPair(&m_pbTerrain, "TerrainBooleans", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());
	pXML->SetVariableListTagPair(&m_pbFeature, "FeatureBooleans", sizeof(GC.getFeatureInfo((FeatureTypes)0)), GC.getNumFeatureInfos());
	pXML->SetVariableListTagPair(&m_pbFeatureTerrain, "FeatureTerrainBooleans", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());

//FfH: Added by Kael 08/16/2007
	pXML->GetChildXmlValByName(&m_bModifierPerBonus, "bModifierPerBonus");
	pXML->GetChildXmlValByName(&m_iBadAttitude, "iBadAttitude");
	pXML->GetChildXmlValByName(&m_iDiscoverRandModifier, "iDiscoverRandModifier");
	pXML->GetChildXmlValByName(szTextVal, "FreePromotion");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iHealChange, "iHealChange");
	pXML->GetChildXmlValByName(&m_iHealChangeEnemy, "iHealChangeEnemy");
	pXML->GetChildXmlValByName(&m_iMaintenanceModifier, "iMaintenanceModifier");
	pXML->GetChildXmlValByName(&m_iMutateChance, "iMutateChance");
	pXML->GetChildXmlValByName(&m_iResearchModifier, "iResearchModifier");
	pXML->GetChildXmlValByName( szTextVal, "DamageType");
	m_iDamageType = pXML->FindInInfoClass(szTextVal);
//FfH: End Add
	pXML->GetChildXmlValByName( szTextVal, "CityYieldModifierType");
	m_iCityYieldModifierType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName( szTextVal, "CityCommerceModifierType");
	m_iCityCommerceModifierType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iCityBonusModifier, "iCityBonusModifier");
	pXML->GetChildXmlValByName(&m_iEnchantedWeaponBonus, "iEnchantedWeaponBonus");
	pXML->GetChildXmlValByName(&m_iMinWilderness, "iMinWilderness");
	pXML->GetChildXmlValByName(&m_iMaxWilderness, "iMaxWilderness",MAX_INT);

	return true;
}

//FfH: Added by Kael 08/09/2007
bool CvBonusInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iFreePromotion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iFreePromotion = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvBonusInfo::copyNonDefaults(CvBonusInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()			== cDefault)		setArtDefineTag(		pClassInfo->getArtDefineTag());
	//Must do Art Define before Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isOneArea()					== false)			m_bOneArea					= pClassInfo->isOneArea();
	if (isHills()					== false)			m_bHills					= pClassInfo->isHills();
	if (isFlatlands()				== false)			m_bFlatlands				= pClassInfo->isFlatlands();
	if (isNoRiverSide()				== false)			m_bNoRiverSide				= pClassInfo->isNoRiverSide();
	if (isNoTrade()					== false)			m_bNoTrade					= pClassInfo->isNoTrade();
	if (isNormalize()				== false)			m_bNormalize				= pClassInfo->isNormalize();
	if (isModifierPerBonus()		== false)			m_bModifierPerBonus			= pClassInfo->isModifierPerBonus();
	if (getBadAttitude()			== 0)				m_iBadAttitude				= pClassInfo->getBadAttitude();
	if (getDiscoverRandModifier()	== 0)				m_iDiscoverRandModifier		= pClassInfo->getDiscoverRandModifier();
	if (getGreatPeopleRateModifier()== 0)				m_iGreatPeopleRateModifier	= pClassInfo->getGreatPeopleRateModifier();
	if (getHealChange()				== 0)				m_iHealChange				= pClassInfo->getHealChange();
	if (getHealChangeEnemy()		== 0)				m_iHealChangeEnemy			= pClassInfo->getHealChangeEnemy();
	if (getMaintenanceModifier()	== 0)				m_iMaintenanceModifier		= pClassInfo->getMaintenanceModifier();
	if (getMutateChance()			== 0)				m_iMutateChance				= pClassInfo->getMutateChance();
	if (getResearchModifier()		== 0)				m_iResearchModifier			= pClassInfo->getResearchModifier();
	if (getCityYieldModifierType()	== NO_YIELD)		m_iCityYieldModifierType	= pClassInfo->getCityYieldModifierType();
	if (getCityBonusModifier()		== 0)				m_iCityBonusModifier		= pClassInfo->getCityBonusModifier();
	if (getCityCommerceModifierType() == NO_COMMERCE)	m_iCityCommerceModifierType	= pClassInfo->getCityCommerceModifierType();
	if (getEnchantedWeaponBonus()	== 0)				m_iEnchantedWeaponBonus		= pClassInfo->getEnchantedWeaponBonus();
	if (getMinWilderness()			== 0)				m_iMinWilderness			= pClassInfo->getMinWilderness();
	if (getMaxWilderness()			== MAX_INT)			m_iMaxWilderness			= pClassInfo->getMaxWilderness();
	if (getAITradeModifier()		== 0)				m_iAITradeModifier			= pClassInfo->getAITradeModifier();
	if (getAIObjective()			== 0)				m_iAIObjective				= pClassInfo->getAIObjective();
	if (getHealth()					== 0)				m_iHealth					= pClassInfo->getHealth();
	if (getHappiness()				== 0)				m_iHappiness				= pClassInfo->getHappiness();
	if (getMinAreaSize()			== 0)				m_iMinAreaSize				= pClassInfo->getMinAreaSize();
	if (getMinLatitude()			== 0)				m_iMinLatitude				= pClassInfo->getMinLatitude();
	if (getPlacementOrder()			== 0)				m_iPlacementOrder			= pClassInfo->getPlacementOrder();
	if (getConstAppearance()		== 0)				m_iConstAppearance			= pClassInfo->getConstAppearance();
	if (getRandAppearance1()		== 0)				m_iRandAppearance1			= pClassInfo->getRandAppearance1();
	if (getRandAppearance2()		== 0)				m_iRandAppearance2			= pClassInfo->getRandAppearance2();
	if (getRandAppearance3()		== 0)				m_iRandAppearance3			= pClassInfo->getRandAppearance3();
	if (getRandAppearance4()		== 0)				m_iRandAppearance4			= pClassInfo->getRandAppearance4();
	if (getPercentPerPlayer()		== 0)				m_iPercentPerPlayer			= pClassInfo->getPercentPerPlayer();
	if (getTilesPer()				== 0)				m_iTilesPer					= pClassInfo->getTilesPer();
	if (getMinLandPercent()			== 0)				m_iMinLandPercent			= pClassInfo->getMinLandPercent();
	if (getUniqueRange()			== 0)				m_iUniqueRange				= pClassInfo->getUniqueRange();
	if (getGroupRange()				== 0)				m_iGroupRange				= pClassInfo->getGroupRange();
	if (getGroupRand()				== 0)				m_iGroupRand				= pClassInfo->getGroupRand();
	if (getMaxLatitude()			== 90)				m_iMaxLatitude				= pClassInfo->getMaxLatitude();
	if (getTechReveal()				== NO_TECH)			m_iTechReveal				= pClassInfo->getTechReveal();
	if (getTechCityTrade()			== NO_TECH)			m_iTechCityTrade			= pClassInfo->getTechCityTrade();
	if (getTechObsolete()			== NO_TECH)			m_iTechObsolete				= pClassInfo->getTechObsolete();
	if (getTechDiscover()			== NO_TECH)			m_iTechDiscover				= pClassInfo->getTechDiscover();
	if (getDamageType()				== NO_DAMAGE)		m_iDamageType				= pClassInfo->getDamageType();
	if (getBonusClassType()			== NO_BONUSCLASS)	m_iBonusClassType			= pClassInfo->getBonusClassType();
	if (getFreePromotion()			== NO_PROMOTION)	m_iFreePromotion			= pClassInfo->getFreePromotion();
	for ( int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_piYieldChange[i]		== 0)				m_piYieldChange[i]			= pClassInfo->getYieldChange(i);
	}
	for ( int i = 0; i < GC.getNumTerrainInfos(); i++)
	{
		if (m_pbTerrain[i]			== false)			m_pbTerrain[i]				= pClassInfo->isTerrain(i);
		if (m_pbFeatureTerrain[i]	== false)			m_pbFeatureTerrain[i]		= pClassInfo->isFeatureTerrain(i);
	}
	for ( int i = 0; i < GC.getNumFeatureInfos(); i++)
	{
		if (m_pbFeature[i]			== false)			m_pbFeature[i]				= pClassInfo->isFeature(i);
	}

	// Readpass3 stuff
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvFeatureInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvFeatureInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvFeatureInfo::CvFeatureInfo() :
m_iFeatureClass(NO_FEATURECLASS),
m_iMovementCost(0),
m_iSeeThroughChange(0),
m_iHealthPercent(0),
m_iAppearanceProbability(0),
m_iDisappearanceProbability(0),
m_iGrowthProbability(0),
m_iDefenseModifier(0),
m_iAdvancedStartRemoveCost(0),
m_iTurnDamage(0),
m_bNoCoast(false),
m_bNoRiver(false),
m_bNoAdjacent(false),
m_bRequiresFlatlands(false),
m_bRequiresRiver(false),
m_bAddsFreshWater(false),
m_bImpassable(false),
m_bNoCity(false),
m_bNoImprovement(false),
m_bVisibleAlways(false),
m_bNukeImmune(false),
m_iWorldSoundscapeScriptId(0),
m_iEffectProbability(0),

//FfH: Added by Kael 03/20/2008
m_bFlammable(false),
m_iFeatureUpgrade(NO_FEATURE),
m_iPrereqStateReligion(NO_RELIGION),
m_iRequireResist(NO_DAMAGE),
//FfH: End Add

m_bRandomTerraform(false),

m_piYieldChange(NULL),
m_piRiverYieldChange(NULL),
m_piHillsYieldChange(NULL),
m_pi3DAudioScriptFootstepIndex(NULL),
m_pbTerrain(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvFeatureInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvFeatureInfo::~CvFeatureInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldChange);
	SAFE_DELETE_ARRAY(m_piRiverYieldChange);
	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	SAFE_DELETE_ARRAY(m_pi3DAudioScriptFootstepIndex);
	SAFE_DELETE_ARRAY(m_pbTerrain);
}

int CvFeatureInfo::getMovementCost() const
{
	return m_iMovementCost;
}

int CvFeatureInfo::getFeatureClass() const
{
	return m_iFeatureClass;
}

int CvFeatureInfo::getSeeThroughChange() const
{
	return m_iSeeThroughChange;
}

int CvFeatureInfo::getHealthPercent() const
{
	return m_iHealthPercent;
}

int CvFeatureInfo::getAppearanceProbability() const
{
	return m_iAppearanceProbability;
}

int CvFeatureInfo::getDisappearanceProbability() const
{
	return m_iDisappearanceProbability;
}

int CvFeatureInfo::getGrowthProbability() const
{
	return m_iGrowthProbability;
}

int CvFeatureInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

int CvFeatureInfo::getAdvancedStartRemoveCost() const
{
	return m_iAdvancedStartRemoveCost;
}

int CvFeatureInfo::getTurnDamage() const
{
	return m_iTurnDamage;
}

bool CvFeatureInfo::isNoCoast() const
{
	return m_bNoCoast;
}

bool CvFeatureInfo::isNoRiver() const
{
	return m_bNoRiver;
}

bool CvFeatureInfo::isNoAdjacent() const
{
	return m_bNoAdjacent;
}

bool CvFeatureInfo::isRequiresFlatlands() const
{
	return m_bRequiresFlatlands;
}

bool CvFeatureInfo::isRequiresRiver() const
{
	return m_bRequiresRiver;
}

bool CvFeatureInfo::isAddsFreshWater() const
{
	return m_bAddsFreshWater;
}

bool CvFeatureInfo::isImpassable() const
{
	return m_bImpassable;
}

bool CvFeatureInfo::isNoCity() const
{
	return m_bNoCity;
}

bool CvFeatureInfo::isNoImprovement() const
{
	return m_bNoImprovement;
}

bool CvFeatureInfo::isVisibleAlways() const
{
	return m_bVisibleAlways;
}

bool CvFeatureInfo::isNukeImmune() const
{
	return m_bNukeImmune;
}

const TCHAR* CvFeatureInfo::getOnUnitChangeTo() const
{
	return m_szOnUnitChangeTo;
}

const TCHAR* CvFeatureInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvFeatureInfo::setArtDefineTag(const TCHAR* szTag)
{
	m_szArtDefineTag = szTag;
}

int CvFeatureInfo::getWorldSoundscapeScriptId() const
{
	return m_iWorldSoundscapeScriptId;
}

const TCHAR* CvFeatureInfo::getEffectType() const
{
	return m_szEffectType;
}

int CvFeatureInfo::getEffectProbability() const
{
	return m_iEffectProbability;
}

//FfH: Added by Kael 08/26/2007
bool CvFeatureInfo::isFlammable() const
{
	return m_bFlammable;
}

bool CvFeatureInfo::isRandomTerraform() const
{
	return m_bRandomTerraform;
}


int CvFeatureInfo::getFeatureUpgrade() const
{
	return m_iFeatureUpgrade;
}

int CvFeatureInfo::getPrereqStateReligion() const
{
	return m_iPrereqStateReligion;
}

const TCHAR *CvFeatureInfo::getPythonOnMove() const
{
	return m_szPythonOnMove;
}

int CvFeatureInfo::getRequireResist() const
{
	return m_iRequireResist;
}
//FfH: End Add

// Arrays

int CvFeatureInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldChange ? m_piYieldChange[i] : -1;
}

int CvFeatureInfo::getRiverYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;
}

int CvFeatureInfo::getHillsYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;
}

int CvFeatureInfo::get3DAudioScriptFootstepIndex(int i) const
{
	//	FAssertMsg(i < ?, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;
}

bool CvFeatureInfo::isTerrain(int i) const
{
	FAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTerrain ? m_pbTerrain[i] : false;
}

int CvFeatureInfo::getNumVarieties() const
{
	return getArtInfo()->getNumVarieties();
}

const TCHAR* CvFeatureInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoFeature * pFeatureArtInfo;
	pFeatureArtInfo = getArtInfo();
	if (pFeatureArtInfo != NULL)
	{
		return pFeatureArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

const CvArtInfoFeature* CvFeatureInfo::getArtInfo() const
{
	return ARTFILEMGR.getFeatureArtInfo( getArtDefineTag());
}

bool CvFeatureInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName( szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldChanges"))
	{
		pXML->SetYields(&m_piYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverYieldChange"))
	{
		pXML->SetYields(&m_piRiverYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HillsYieldChange"))
	{
		pXML->SetYields(&m_piHillsYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piHillsYieldChange, NUM_YIELD_TYPES);
	}

	pXML->GetChildXmlValByName(szTextVal, "FeatureClass");
	m_iFeatureClass = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(&m_iMovementCost, "iMovement");
	pXML->GetChildXmlValByName(&m_iSeeThroughChange, "iSeeThrough");
	pXML->GetChildXmlValByName(&m_iHealthPercent, "iHealthPercent");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefense");
	pXML->GetChildXmlValByName(&m_iAdvancedStartRemoveCost, "iAdvancedStartRemoveCost");
	pXML->GetChildXmlValByName(&m_iTurnDamage, "iTurnDamage");
	pXML->GetChildXmlValByName(&m_iAppearanceProbability, "iAppearance");
	pXML->GetChildXmlValByName(&m_iDisappearanceProbability, "iDisappearance");
	pXML->GetChildXmlValByName(&m_iGrowthProbability, "iGrowth");
	pXML->GetChildXmlValByName(&m_bNoCoast, "bNoCoast");
	pXML->GetChildXmlValByName(&m_bNoRiver, "bNoRiver");
	pXML->GetChildXmlValByName(&m_bNoAdjacent, "bNoAdjacent");
	pXML->GetChildXmlValByName(&m_bRequiresFlatlands, "bRequiresFlatlands");
	pXML->GetChildXmlValByName(&m_bRequiresRiver, "bRequiresRiver");
	pXML->GetChildXmlValByName(&m_bAddsFreshWater, "bAddsFreshWater");
	pXML->GetChildXmlValByName(&m_bImpassable, "bImpassable");
	pXML->GetChildXmlValByName(&m_bNoCity, "bNoCity");
	pXML->GetChildXmlValByName(&m_bNoImprovement, "bNoImprovement");
	pXML->GetChildXmlValByName(&m_bVisibleAlways, "bVisibleAlways");
	pXML->GetChildXmlValByName(&m_bNukeImmune, "bNukeImmune");
	pXML->GetChildXmlValByName(m_szOnUnitChangeTo, "OnUnitChangeTo");

	pXML->SetVariableListTagPairForAudioScripts(&m_pi3DAudioScriptFootstepIndex, "FootstepSounds", GC.getFootstepAudioTypes(), GC.getNumFootstepAudioTypes());

	pXML->GetChildXmlValByName(szTextVal, "WorldSoundscapeAudioScript");
	if ( szTextVal.GetLength() > 0 )
	{
		m_iWorldSoundscapeScriptId = gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_SOUNDSCAPE );
	}
	else
	{
		m_iWorldSoundscapeScriptId = -1;
	}

	pXML->GetChildXmlValByName(m_szEffectType, "EffectType");
	pXML->GetChildXmlValByName(&m_iEffectProbability, "iEffectProbability");

	pXML->SetVariableListTagPair(&m_pbTerrain, "TerrainBooleans", sizeof(GC.getTerrainInfo((TerrainTypes)0)), GC.getNumTerrainInfos());

//FfH: Added by Kael 09/02/2007
	pXML->GetChildXmlValByName(&m_bFlammable, "bFlammable");
	pXML->GetChildXmlValByName(&m_bRandomTerraform, "bRandomTerraform");
	pXML->GetChildXmlValByName(szTextVal, "PrereqStateReligion");
	m_iPrereqStateReligion = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(m_szPythonOnMove, "PythonOnMove");
	pXML->GetChildXmlValByName(szTextVal, "RequireResist");
	m_iRequireResist = GC.getInfoTypeForString(szTextVal);
//FfH: End Add

	return true;
}

//FfH: Added by Kael 08/26/2007
bool CvFeatureInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "FeatureUpgrade");
	m_iFeatureUpgrade = GC.getInfoTypeForString(szTextVal);

	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvFeatureInfo::copyNonDefaults(CvFeatureInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()							== cDefault)	setArtDefineTag(					pClassInfo->getArtDefineTag());
	//Must do Art Define before Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isNoCoast()									== false)		m_bNoCoast							= pClassInfo->isNoCoast();
	if (isNoRiver()									== false)		m_bNoRiver							= pClassInfo->isNoRiver();
	if (isNoAdjacent()								== false)		m_bNoAdjacent						= pClassInfo->isNoAdjacent();
	if (isRequiresFlatlands()						== false)		m_bRequiresFlatlands				= pClassInfo->isRequiresFlatlands();
	if (isRequiresRiver()							== false)		m_bRequiresRiver					= pClassInfo->isRequiresRiver();
	if (isAddsFreshWater()							== false)		m_bAddsFreshWater					= pClassInfo->isAddsFreshWater();
	if (isImpassable()								== false)		m_bImpassable						= pClassInfo->isImpassable();
	if (isNoCity()									== false)		m_bNoCity							= pClassInfo->isNoCity();
	if (isNoImprovement()							== false)		m_bNoImprovement					= pClassInfo->isNoImprovement();
	if (isVisibleAlways()							== false)		m_bVisibleAlways					= pClassInfo->isVisibleAlways();
	if (isNukeImmune()								== false)		m_bNukeImmune						= pClassInfo->isNukeImmune();
	if (isFlammable()								== false)		m_bFlammable						= pClassInfo->isFlammable();
	if (isRandomTerraform()							== false)		m_bRandomTerraform					= pClassInfo->isRandomTerraform();
	if (getFeatureClass()				== NO_FEATURECLASS)			m_iFeatureClass						= pClassInfo->getFeatureClass();
	if (getSeeThroughChange()						== 0)			m_iSeeThroughChange					= pClassInfo->getSeeThroughChange();
	if (getHealthPercent()							== 0)			m_iHealthPercent					= pClassInfo->getHealthPercent();
	if (getDefenseModifier()						== 0)			m_iDefenseModifier					= pClassInfo->getDefenseModifier();
	if (getAdvancedStartRemoveCost()				== 0)			m_iAdvancedStartRemoveCost			= pClassInfo->getAdvancedStartRemoveCost();
	if (getTurnDamage()								== 0)			m_iTurnDamage						= pClassInfo->getTurnDamage();
	if (getAppearanceProbability()					== 0)			m_iAppearanceProbability			= pClassInfo->getAppearanceProbability();
	if (getDisappearanceProbability()				== 0)			m_iDisappearanceProbability			= pClassInfo->getDisappearanceProbability();
	if (getGrowthProbability()						== 0)			m_iGrowthProbability				= pClassInfo->getGrowthProbability();
	if (getEffectProbability()						== 0)			m_iEffectProbability				= pClassInfo->getEffectProbability();
	if (getWorldSoundscapeScriptId()				== -1)			m_iWorldSoundscapeScriptId			= pClassInfo->getWorldSoundscapeScriptId();
	if (getOnUnitChangeTo()							== cDefault)	m_szOnUnitChangeTo					= pClassInfo->getOnUnitChangeTo();
	if (getEffectType()								== cDefault)	m_szEffectType						= pClassInfo->getEffectType();
	if (getPythonOnMove()							== cDefault)	m_szPythonOnMove					= pClassInfo->getPythonOnMove();
	if (getRequireResist()							== NO_DAMAGE)	m_iRequireResist					= pClassInfo->getRequireResist();
	if (getPrereqStateReligion()					== NO_RELIGION)	m_iPrereqStateReligion				= pClassInfo->getPrereqStateReligion();
	for (int i = 0; i < GC.getNumFootstepAudioTypes(); i++)
	{
		if (m_pi3DAudioScriptFootstepIndex[i]		== 0)			m_pi3DAudioScriptFootstepIndex[i]	= pClassInfo->get3DAudioScriptFootstepIndex(i);
	}
	for ( int i = 0; i < GC.getNumTerrainInfos(); i++ )
	{
		if (m_pbTerrain[i]							== false)		m_pbTerrain[i]						= pClassInfo->isTerrain(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_piYieldChange[i]						== 0)			m_piYieldChange[i]					= pClassInfo->getYieldChange(i);
		if (m_piRiverYieldChange[i]					== 0)			m_piRiverYieldChange[i]				= pClassInfo->getRiverYieldChange(i);
		if (m_piHillsYieldChange[i]					== 0)			m_piHillsYieldChange[i]				= pClassInfo->getHillsYieldChange(i);
	}

	//Readpass2 stuff
	if (m_iFeatureUpgrade							== -1)			m_iFeatureUpgrade					= pClassInfo->getFeatureUpgrade();
}
void CvFeatureInfo::copyNonDefaultsReadPass2(CvFeatureInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getFeatureUpgrade()	!= -1)			m_iFeatureUpgrade					= pClassInfo->getFeatureUpgrade();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCommerceInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCommerceInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCommerceInfo::CvCommerceInfo() :
m_iChar(0),
m_iInitialPercent(0),
m_iInitialHappiness(0),
m_iAIWeightPercent(0),
m_bFlexiblePercent(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCommerceInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCommerceInfo::~CvCommerceInfo()
{
}

int CvCommerceInfo::getChar() const
{
	return m_iChar;
}

void CvCommerceInfo::setChar(int i)
{
	m_iChar = i;
}

int CvCommerceInfo::getInitialPercent() const
{
	return m_iInitialPercent;
}

int CvCommerceInfo::getInitialHappiness() const
{
	return m_iInitialHappiness;
}

int CvCommerceInfo::getAIWeightPercent() const
{
	return m_iAIWeightPercent;
}

bool CvCommerceInfo::isFlexiblePercent() const
{
	return m_bFlexiblePercent;
}

bool CvCommerceInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iInitialPercent, "iInitialPercent");
	pXML->GetChildXmlValByName(&m_iInitialHappiness, "iInitialHappiness");
	pXML->GetChildXmlValByName(&m_iAIWeightPercent, "iAIWeightPercent");
	pXML->GetChildXmlValByName(&m_bFlexiblePercent, "bFlexiblePercent");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCommerceInfo::copyNonDefaults(CvCommerceInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getInitialPercent()		== 0)		m_iInitialPercent	= pClassInfo->getInitialPercent();
	if (getInitialHappiness()	== 0)		m_iInitialHappiness	= pClassInfo->getInitialHappiness();
	if (getAIWeightPercent()	== 0)		m_iAIWeightPercent	= pClassInfo->getAIWeightPercent();
	if (isFlexiblePercent()		== false)	m_bFlexiblePercent	= pClassInfo->isFlexiblePercent();

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvYieldInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvYieldInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvYieldInfo::CvYieldInfo() :
m_iChar(0),
m_iHillsChange(0),
m_iPeakChange(0),
m_iLakeChange(0),
m_iCityChange(0),
m_iPopulationChangeOffset(0),
m_iPopulationChangeDivisor(0),
m_iMinCity(0),
m_iTradeModifier(0),
m_iGoldenAgeYield(0),
m_iGoldenAgeYieldThreshold(0),
m_iAIWeightPercent(0),
m_iColorType(NO_COLOR),
m_paszSymbolPath(NULL)
{
}


//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvYieldInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvYieldInfo::~CvYieldInfo()
{
	SAFE_DELETE_ARRAY(m_paszSymbolPath);
}

int CvYieldInfo::getChar() const
{
	return m_iChar;
}

void CvYieldInfo::setChar(int i)
{
	m_iChar = i;
}

int CvYieldInfo::getHillsChange() const
{
	return m_iHillsChange;
}

int CvYieldInfo::getPeakChange() const
{
	return m_iPeakChange;
}

int CvYieldInfo::getLakeChange() const
{
	return m_iLakeChange;
}

int CvYieldInfo::getCityChange() const
{
	return m_iCityChange;
}

int CvYieldInfo::getPopulationChangeOffset() const
{
	return m_iPopulationChangeOffset;
}

int CvYieldInfo::getPopulationChangeDivisor() const
{
	return m_iPopulationChangeDivisor;
}

int CvYieldInfo::getMinCity() const
{
	return m_iMinCity;
}

int CvYieldInfo::getTradeModifier() const
{
	return m_iTradeModifier;
}

int CvYieldInfo::getGoldenAgeYield() const
{
	return m_iGoldenAgeYield;
}

int CvYieldInfo::getGoldenAgeYieldThreshold() const
{
	return m_iGoldenAgeYieldThreshold;
}

int CvYieldInfo::getAIWeightPercent() const
{
	return m_iAIWeightPercent;
}

int CvYieldInfo::getColorType() const
{
	return m_iColorType;
}

// Arrays

const TCHAR* CvYieldInfo::getSymbolPath(int i) const
{
	FAssertMsg(i < GC.getDefineINT("MAX_YIELD_STACK"), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paszSymbolPath ? m_paszSymbolPath[i] : -1;
}

bool CvYieldInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int iNumSibs, j;

	pXML->GetChildXmlValByName(&m_iHillsChange, "iHillsChange");
	pXML->GetChildXmlValByName(&m_iPeakChange, "iPeakChange");
	pXML->GetChildXmlValByName(&m_iLakeChange, "iLakeChange");
	pXML->GetChildXmlValByName(&m_iCityChange, "iCityChange");
	pXML->GetChildXmlValByName(&m_iPopulationChangeOffset, "iPopulationChangeOffset");
	pXML->GetChildXmlValByName(&m_iPopulationChangeDivisor, "iPopulationChangeDivisor");
	pXML->GetChildXmlValByName(&m_iMinCity, "iMinCity");
	pXML->GetChildXmlValByName(&m_iTradeModifier, "iTradeModifier");
	pXML->GetChildXmlValByName(&m_iGoldenAgeYield, "iGoldenAgeYield");
	pXML->GetChildXmlValByName(&m_iGoldenAgeYieldThreshold, "iGoldenAgeYieldThreshold");
	pXML->GetChildXmlValByName(&m_iAIWeightPercent, "iAIWeightPercent");

	pXML->GetChildXmlValByName(szTextVal, "ColorType");
	m_iColorType = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "SymbolPaths"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg((0 < GC.getDefineINT("MAX_YIELD_STACK")) ,"Allocating zero or less memory in SetGlobalYieldInfo");
			m_paszSymbolPath = new CvString[GC.getDefineINT("MAX_YIELD_STACK")];

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getDefineINT("MAX_YIELD_STACK")) ,"There are more siblings than memory allocated for them in SetGlobalYieldInfo");
					for (j=0;j<iNumSibs;j++)
					{
						m_paszSymbolPath[j] = szTextVal;
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		CvString cDefault = CvString::format("").GetCString();
		m_paszSymbolPath = new CvString[GC.getDefineINT("MAX_YIELD_STACK")];
		for ( int i = 0; i < GC.getDefineINT("MAX_YIELD_STACK"); i++)
		{
			m_paszSymbolPath[i] = cDefault;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvYieldInfo::copyNonDefaults(CvYieldInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getHillsChange()				== 0)			m_iHillsChange				= pClassInfo->getHillsChange();
	if (getPeakChange()					== 0)			m_iPeakChange				= pClassInfo->getPeakChange();
	if (getLakeChange()					== 0)			m_iLakeChange				= pClassInfo->getLakeChange();
	if (getCityChange()					== 0)			m_iCityChange				= pClassInfo->getCityChange();
	if (getPopulationChangeOffset()		== 0)			m_iPopulationChangeOffset	= pClassInfo->getPopulationChangeOffset();
	if (getPopulationChangeDivisor()	== 0)			m_iPopulationChangeDivisor	= pClassInfo->getPopulationChangeDivisor();
	if (getMinCity()					== 0)			m_iMinCity					= pClassInfo->getMinCity();
	if (getTradeModifier()				== 0)			m_iTradeModifier			= pClassInfo->getTradeModifier();
	if (getGoldenAgeYield()				== 0)			m_iGoldenAgeYield			= pClassInfo->getGoldenAgeYield();
	if (getGoldenAgeYieldThreshold()	== 0)			m_iGoldenAgeYieldThreshold	= pClassInfo->getGoldenAgeYieldThreshold();
	if (getAIWeightPercent()			== 0)			m_iAIWeightPercent			= pClassInfo->getAIWeightPercent();
	if (getColorType()					== NO_COLOR)	m_iColorType				= pClassInfo->getColorType();
	for ( int i = 0; i < GC.getDefineINT("MAX_YIELD_STACK"); i++)
	{
		if ( m_paszSymbolPath[i]		== cDefault)	m_paszSymbolPath[i]			= pClassInfo->getSymbolPath(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvTerrainInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTerrainInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTerrainInfo::CvTerrainInfo() :
m_iTerrainClassType(NO_TERRAINCLASS),
m_iMovementCost(0),
m_iSeeFromLevel(0),
m_iSeeThroughLevel(0),
m_iBuildModifier(0),
m_iDefenseModifier(0),
m_bWater(false),
m_bImpassable(false),
m_bFound(false),
m_bFoundCoast(false),
m_bFoundFreshWater(false),
m_iWorldSoundscapeScriptId(0),
m_piYields(NULL),
m_piRiverYieldChange(NULL),
m_piHillsYieldChange(NULL),
m_pi3DAudioScriptFootstepIndex(NULL),

//FfH: Added By Kael 08/02/2007
m_bNormalize(false),
m_iCivilizationYieldType(NO_CIVILIZATION),
m_iPlotCounterDown(-1),
m_iTerrainDown(NO_TERRAIN),
m_iPlotCounterUp(-1),
m_iTerrainUp(NO_TERRAIN),
//FfH: End Add
m_bRandomTerraform(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTerrainInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTerrainInfo::~CvTerrainInfo()
{
	SAFE_DELETE_ARRAY(m_piYields);
	SAFE_DELETE_ARRAY(m_piRiverYieldChange);
	SAFE_DELETE_ARRAY(m_piHillsYieldChange);
	SAFE_DELETE_ARRAY(m_pi3DAudioScriptFootstepIndex);

//FfH: Added by Kael 09/18/2008
	SAFE_DELETE_ARRAY(m_piCivilizationYieldChange);
//FfH: End Add

}

int CvTerrainInfo::getTerrainClassType() const
{
	return m_iTerrainClassType;
}

int CvTerrainInfo::getMovementCost() const
{
	return m_iMovementCost;
}

int CvTerrainInfo::getSeeFromLevel() const
{
	return m_iSeeFromLevel;
}

int CvTerrainInfo::getSeeThroughLevel() const
{
	return m_iSeeThroughLevel;
}

int CvTerrainInfo::getBuildModifier() const
{
	return m_iBuildModifier;
}

int CvTerrainInfo::getDefenseModifier() const
{
	return m_iDefenseModifier;
}

bool CvTerrainInfo::isWater() const
{
	return m_bWater;
}

bool CvTerrainInfo::isImpassable() const
{
	return m_bImpassable;
}

bool CvTerrainInfo::isFound() const
{
	return m_bFound;
}

bool CvTerrainInfo::isFoundCoast() const
{
	return m_bFoundCoast;
}

bool CvTerrainInfo::isFoundFreshWater() const
{
	return m_bFoundFreshWater;
}

const TCHAR* CvTerrainInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvTerrainInfo::setArtDefineTag(const TCHAR* szTag)
{
	m_szArtDefineTag = szTag;
}

int CvTerrainInfo::getWorldSoundscapeScriptId() const
{
	return m_iWorldSoundscapeScriptId;
}

//FfH: Added by Kael 08/02/2007
bool CvTerrainInfo::isNormalize() const
{
	return m_bNormalize;
}

int CvTerrainInfo::getCivilizationYieldType() const
{
	return m_iCivilizationYieldType;
}

int CvTerrainInfo::getCivilizationYieldChange(int i) const
{
	return m_piCivilizationYieldChange ? m_piCivilizationYieldChange[i] : -1;
}

int CvTerrainInfo::getPlotCounterDown() const
{
	return m_iPlotCounterDown;
}

int CvTerrainInfo::getTerrainDown() const
{
	return m_iTerrainDown;
}

int CvTerrainInfo::getPlotCounterUp() const
{
	return m_iPlotCounterUp;
}

int CvTerrainInfo::getTerrainUp() const
{
	return m_iTerrainUp;
}
//FfH: End Add

bool CvTerrainInfo::isRandomTerraform() const
{
	return m_bRandomTerraform;
}

// Arrays

int CvTerrainInfo::getYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYields ? m_piYields[i] : -1;
}

int CvTerrainInfo::getRiverYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;
}

int CvTerrainInfo::getHillsYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;
}

int CvTerrainInfo::get3DAudioScriptFootstepIndex(int i) const
{
//	FAssertMsg(i < ?, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;
}

bool CvTerrainInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "TerrainClassType");
	m_iTerrainClassType = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName( szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Yields"))
	{
		pXML->SetYields(&m_piYields);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYields, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RiverYieldChange"))
	{
		pXML->SetYields(&m_piRiverYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piRiverYieldChange, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HillsYieldChange"))
	{
		pXML->SetYields(&m_piHillsYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piHillsYieldChange, NUM_YIELD_TYPES);
	}

	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(&m_bImpassable, "bImpassable");
	pXML->GetChildXmlValByName(&m_bFound, "bFound");
	pXML->GetChildXmlValByName(&m_bFoundCoast, "bFoundCoast");
	pXML->GetChildXmlValByName(&m_bFoundFreshWater, "bFoundFreshWater");

	pXML->GetChildXmlValByName(&m_iMovementCost, "iMovement");
	pXML->GetChildXmlValByName(&m_iSeeFromLevel, "iSeeFrom");
	pXML->GetChildXmlValByName(&m_iSeeThroughLevel, "iSeeThrough");
	pXML->GetChildXmlValByName(&m_iBuildModifier, "iBuildModifier");
	pXML->GetChildXmlValByName(&m_iDefenseModifier, "iDefense");

	pXML->SetVariableListTagPairForAudioScripts(&m_pi3DAudioScriptFootstepIndex, "FootstepSounds", GC.getFootstepAudioTypes(), GC.getNumFootstepAudioTypes());

	pXML->GetChildXmlValByName(szTextVal, "WorldSoundscapeAudioScript");
	if ( szTextVal.GetLength() > 0 )
		m_iWorldSoundscapeScriptId = gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_SOUNDSCAPE );
	else
		m_iWorldSoundscapeScriptId = -1;

//FfH: Added by Kael 08/02/2007
	pXML->GetChildXmlValByName(&m_bNormalize, "bNormalize");
	pXML->GetChildXmlValByName(&m_bRandomTerraform, "bRandomTerraform");
	pXML->GetChildXmlValByName(&m_iPlotCounterDown, "iPlotCounterDown");
	pXML->GetChildXmlValByName(&m_iPlotCounterUp, "iPlotCounterUp");
	pXML->GetChildXmlValByName(szTextVal, "CivilizationYieldType");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CivilizationYieldChange"))
	{
		pXML->SetYields(&m_piCivilizationYieldChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCivilizationYieldChange, NUM_YIELD_TYPES);
	}
//FfH: End Add

	return true;
}

//FfH: Added by Kael 08/15/2007
bool CvTerrainInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "TerrainDown");
	m_iTerrainDown = GC.getInfoTypeForString(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainUp");
	m_iTerrainUp = GC.getInfoTypeForString(szTextVal);

	return true;
}

bool CvTerrainInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		return false;
	}
	m_iCivilizationYieldType = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_aszExtraXMLforPass3.clear();
	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTerrainInfo::copyNonDefaults(CvTerrainInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()						== cDefault)	setArtDefineTag(					pClassInfo->getArtDefineTag());
	//Must do Art Define before the Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTerrainClassType()			  == NO_TERRAINCLASS)		m_iTerrainClassType						= pClassInfo->getTerrainClassType();
	if (isWater()								== false)		m_bWater							= pClassInfo->isWater();
	if (isImpassable()							== false)		m_bImpassable						= pClassInfo->isImpassable();
	if (isFound()								== false)		m_bFound							= pClassInfo->isFound();
	if (isFoundCoast()							== false)		m_bFoundCoast						= pClassInfo->isFoundCoast();
	if (isFoundFreshWater()						== false)		m_bFoundFreshWater					= pClassInfo->isFoundFreshWater();
	if (isNormalize()							== false)		m_bNormalize						= pClassInfo->isNormalize();
	if (getMovementCost()						== 0)			m_iMovementCost						= pClassInfo->getMovementCost();
	if (getSeeFromLevel()						== 0)			m_iSeeFromLevel						= pClassInfo->getSeeFromLevel();
	if (getSeeThroughLevel()					== 0)			m_iSeeThroughLevel					= pClassInfo->getSeeThroughLevel();
	if (getBuildModifier()						== 0)			m_iBuildModifier					= pClassInfo->getBuildModifier();
	if (getDefenseModifier()					== 0)			m_iDefenseModifier					= pClassInfo->getDefenseModifier();
	if (getPlotCounterDown()					== 0)			m_iPlotCounterDown					= pClassInfo->getPlotCounterDown();
	if (getPlotCounterUp()						== 0)			m_iPlotCounterUp					= pClassInfo->getPlotCounterUp();
	if (getWorldSoundscapeScriptId()			== -1)			m_iWorldSoundscapeScriptId			= pClassInfo->getWorldSoundscapeScriptId();
	for (int i = 0; i < GC.getNumFootstepAudioTypes(); i++)
	{
        if (m_pi3DAudioScriptFootstepIndex[i]	== 0)			m_pi3DAudioScriptFootstepIndex[i]	= pClassInfo->get3DAudioScriptFootstepIndex(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++)
	{
        if (m_piYields[i]						== 0)			m_piYields[i]						= pClassInfo->getYield(i);
		if (m_piRiverYieldChange[i]				== 0)			m_piRiverYieldChange[i]				= pClassInfo->getRiverYieldChange(i);
		if (m_piHillsYieldChange[i]				== 0)			m_piHillsYieldChange[i]				= pClassInfo->getHillsYieldChange(i);
	}

	if (isRandomTerraform()                     == false)		m_bRandomTerraform					= pClassInfo->isRandomTerraform(); 

	//Readpass2 stuff
	if (m_iTerrainDown							== NO_TERRAIN)	m_iTerrainDown						= pClassInfo->getTerrainDown();
	if (m_iTerrainUp							== NO_TERRAIN)	m_iTerrainUp						= pClassInfo->getTerrainUp();
}
void CvTerrainInfo::copyNonDefaultsReadPass2(CvTerrainInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (bOver || pClassInfo->getTerrainDown()	!= NO_TERRAIN)	m_iTerrainDown						= pClassInfo->getTerrainDown();
	if (bOver || pClassInfo->getTerrainUp()		!= NO_TERRAIN)	m_iTerrainUp						= pClassInfo->getTerrainUp();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

const TCHAR* CvTerrainInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoTerrain * pTerrainArtInfo;
	pTerrainArtInfo = getArtInfo();
	if (pTerrainArtInfo != NULL)
	{
		return pTerrainArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

const CvArtInfoTerrain* CvTerrainInfo::getArtInfo() const
{
	return ARTFILEMGR.getTerrainArtInfo( getArtDefineTag());
}

//======================================================================================================
//					CvInterfaceModeInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvInterfaceModeInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvInterfaceModeInfo::CvInterfaceModeInfo() :
m_iCursorIndex(NO_CURSOR),
m_iMissionType(NO_MISSION),
m_bVisible(false),
m_bGotoPlot(false),
m_bHighlightPlot(false),
m_bSelectType(false),
m_bSelectAll(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvInterfaceModeInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvInterfaceModeInfo::~CvInterfaceModeInfo()
{
}

int CvInterfaceModeInfo::getCursorIndex() const
{
	return m_iCursorIndex;
}

int CvInterfaceModeInfo::getMissionType() const
{
	return m_iMissionType;
}

bool CvInterfaceModeInfo::getVisible() const
{
	return m_bVisible;
}

bool CvInterfaceModeInfo::getGotoPlot() const
{
	return m_bGotoPlot;
}

bool CvInterfaceModeInfo::getHighlightPlot() const
{
	return m_bHighlightPlot;
}

bool CvInterfaceModeInfo::getSelectType() const
{
	return m_bSelectType;
}

bool CvInterfaceModeInfo::getSelectAll() const
{
	return m_bSelectAll;
}

bool CvInterfaceModeInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "CursorType");
	m_iCursorIndex = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Mission");
	m_iMissionType = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");
	pXML->GetChildXmlValByName(&m_bGotoPlot, "bGotoPlot");
	pXML->GetChildXmlValByName(&m_bHighlightPlot, "bHighlightPlot");
	pXML->GetChildXmlValByName(&m_bSelectType, "bSelectType");
	pXML->GetChildXmlValByName(&m_bSelectAll, "bSelectAll");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvInterfaceModeInfo::copyNonDefaults(CvInterfaceModeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getCursorIndex()	== NO_CURSOR)	m_iCursorIndex		= pClassInfo->getCursorIndex();
	if (getMissionType()	== NO_MISSION)	m_iMissionType		= pClassInfo->getMissionType();
	if (getVisible()		== false)		m_bVisible			= pClassInfo->getVisible();
	if (getGotoPlot()		== false)		m_bGotoPlot			= pClassInfo->getGotoPlot();
	if (getHighlightPlot()	== false)		m_bHighlightPlot	= pClassInfo->getHighlightPlot();
	if (getSelectType()		== false)		m_bSelectType		= pClassInfo->getSelectType();
	if (getSelectAll()		== false)		m_bSelectAll		= pClassInfo->getSelectAll();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAdvisorInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAdvisorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAdvisorInfo::CvAdvisorInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAdvisorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAdvisorInfo::~CvAdvisorInfo()
{
}

const TCHAR* CvAdvisorInfo::getTexture() const
{
	return m_szTexture;
}

void CvAdvisorInfo::setTexture(const TCHAR* szVal)
{
	m_szTexture = szVal;
}

int CvAdvisorInfo::getNumCodes() const
{
	return m_vctEnableDisableCodes.size();
}

int CvAdvisorInfo::getEnableCode(uint uiCode) const
{
	FAssert( uiCode < m_vctEnableDisableCodes.size() );
	return m_vctEnableDisableCodes[uiCode].first;
}

int CvAdvisorInfo::getDisableCode(uint uiCode) const
{
	FAssert( uiCode < m_vctEnableDisableCodes.size() );
	return m_vctEnableDisableCodes[uiCode].second;
}

bool CvAdvisorInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Texture");
	setTexture( szTextVal );

	gDLL->getXMLIFace()->SetToChild( pXML->GetXML() );
	while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "EventCodes"))
	{
		int iEnableCode, iDisableCode;
		pXML->GetChildXmlValByName(&iEnableCode, "iEnableCode");
		pXML->GetChildXmlValByName(&iDisableCode, "iDisableCode");
		m_vctEnableDisableCodes.push_back( std::make_pair( iEnableCode, iDisableCode ));
	}
	gDLL->getXMLIFace()->SetToParent( pXML->GetXML() );

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAdvisorInfo::copyNonDefaults(CvAdvisorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTexture()	== cDefault)	setTexture(			pClassInfo->getTexture());

	if (getNumCodes()	== 0)  //Only copy old values if the new doesn't hold a tag
	{
		for (int iI = 0; iI < pClassInfo->getNumCodes(); iI++)
		{
			int iEnableCode, iDisableCode;
			iEnableCode =									pClassInfo->getEnableCode(iI);
			iDisableCode =									pClassInfo->getDisableCode(iI);
										m_vctEnableDisableCodes.push_back( std::make_pair( iEnableCode, iDisableCode ));
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvLeaderHeadInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvLeaderHeadInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderHeadInfo::CvLeaderHeadInfo() :
m_iWonderConstructRand(0),
m_iBaseAttitude(0),
m_iBasePeaceWeight(0),
m_iPeaceWeightRand(0),
m_iWarmongerRespect(0),
m_iEspionageWeight(0),
m_iRefuseToTalkWarThreshold(0),
m_iNoTechTradeThreshold(0),
m_iTechTradeKnownPercent(0),
m_iMaxGoldTradePercent(0),
m_iMaxGoldPerTurnTradePercent(0),
m_iMaxWarRand(0),
m_iMaxWarNearbyPowerRatio(0),
m_iMaxWarDistantPowerRatio(0),
m_iMaxWarMinAdjacentLandPercent(0),
m_iLimitedWarRand(0),
m_iLimitedWarPowerRatio(0),
m_iDogpileWarRand(0),
m_iMakePeaceRand(0),
m_iDeclareWarTradeRand(0),
m_iDemandRebukedSneakProb(0),
m_iDemandRebukedWarProb(0),
m_iRazeCityProb(0),
m_iBuildUnitProb(0),
m_iBaseAttackOddsChange(0),
m_iAttackOddsChangeRand(0),
m_iWorseRankDifferenceAttitudeChange(0),
m_iBetterRankDifferenceAttitudeChange(0),
m_iCloseBordersAttitudeChange(0),
m_iLostWarAttitudeChange(0),
m_iAtWarAttitudeDivisor(0),
m_iAtWarAttitudeChangeLimit(0),
m_iAtPeaceAttitudeDivisor(0),
m_iAtPeaceAttitudeChangeLimit(0),
m_iSameReligionAttitudeChange(0),
m_iSameReligionAttitudeDivisor(0),
m_iSameReligionAttitudeChangeLimit(0),
m_iDifferentReligionAttitudeChange(0),
m_iDifferentReligionAttitudeDivisor(0),
m_iDifferentReligionAttitudeChangeLimit(0),
m_iBonusTradeAttitudeDivisor(0),
m_iBonusTradeAttitudeChangeLimit(0),
m_iOpenBordersAttitudeDivisor(0),
m_iOpenBordersAttitudeChangeLimit(0),
m_iDefensivePactAttitudeDivisor(0),
m_iDefensivePactAttitudeChangeLimit(0),
m_iShareWarAttitudeChange(0),
m_iShareWarAttitudeDivisor(0),
m_iShareWarAttitudeChangeLimit(0),
m_iFavoriteCivicAttitudeChange(0),
m_iFavoriteCivicAttitudeDivisor(0),
m_iFavoriteCivicAttitudeChangeLimit(0),
m_iDemandTributeAttitudeThreshold(NO_ATTITUDE),
m_iNoGiveHelpAttitudeThreshold(NO_ATTITUDE),
m_iTechRefuseAttitudeThreshold(NO_ATTITUDE),
m_iStrategicBonusRefuseAttitudeThreshold(NO_ATTITUDE),
m_iHappinessBonusRefuseAttitudeThreshold(NO_ATTITUDE),
m_iHealthBonusRefuseAttitudeThreshold(NO_ATTITUDE),
m_iMapRefuseAttitudeThreshold(NO_ATTITUDE),
m_iDeclareWarRefuseAttitudeThreshold(NO_ATTITUDE),
m_iDeclareWarThemRefuseAttitudeThreshold(NO_ATTITUDE),
m_iStopTradingRefuseAttitudeThreshold(NO_ATTITUDE),
m_iStopTradingThemRefuseAttitudeThreshold(NO_ATTITUDE),
m_iAdoptCivicRefuseAttitudeThreshold(NO_ATTITUDE),
m_iConvertReligionRefuseAttitudeThreshold(NO_ATTITUDE),
m_iOpenBordersRefuseAttitudeThreshold(NO_ATTITUDE),
m_iDefensivePactRefuseAttitudeThreshold(NO_ATTITUDE),
m_iPermanentAllianceRefuseAttitudeThreshold(NO_ATTITUDE),
m_iVassalRefuseAttitudeThreshold(NO_ATTITUDE),
m_iVassalPowerModifier(0),
m_iFreedomAppreciation(0),
m_iFavoriteCivic(NO_CIVIC),
m_iFavoriteReligion(NO_RELIGION),
m_pbTraits(NULL),
m_piFlavorValue(NULL),
m_piContactRand(NULL),
m_piContactDelay(NULL),
m_piMemoryDecayRand(NULL),
m_piMemoryAttitudePercent(NULL),
m_piNoWarAttitudeProb(NULL),
m_piUnitAIWeightModifier(NULL),
m_piImprovementWeightModifier(NULL),
m_piDiploPeaceIntroMusicScriptIds(NULL),
m_piDiploPeaceMusicScriptIds(NULL),
m_piDiploWarIntroMusicScriptIds(NULL),
m_piDiploWarMusicScriptIds(NULL),

//FfH: Added by Kael 08/07/2007
m_piReligionWeightModifier(NULL),
m_bFemale(false),
m_iAlignment(NO_ALIGNMENT),
m_iAttitudeBadBonus(0),
m_iAttitudeFromFemales(0),
m_iAttitudeFromMales(0),
m_iAttitudeToFemales(0),
m_iAttitudeToMales(0),

//FfH Card Game: Added by Sto 08/08/2008
m_iSomniumAggressiveness(0),
//FfH: End Add

m_iFavoriteTech(NO_TECH),
m_iFavoriteUnitCombat(NO_UNITCOMBAT),
m_iFavoriteWonder(NO_BUILDING),
m_iPermanentTrait(NO_TRAIT)
//FfH: End Add
/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
,m_bAltarVictory(false)
,m_bArcaneTowerVictory(false)
,m_bCultureVictory(false)
,m_bReligionVictory(false)

,m_bReligionOpportunist(false)
,m_iAIPatrolGroupSize(0)
,m_iAIPatrolGroupMage(0)
,m_iAIValueDefense(0)
,m_iAIValueMage(0)
,m_iEconomyTechValue(0)
,m_iFavoriteEarlyReligion(NO_RELIGION)
,m_iFavoriteEarlyMilTech(NO_TECH)
,m_iFavoriteEarlyTech1(NO_TECH)
,m_iFavoriteEarlyTech2(NO_TECH)
,m_iFavoriteEarlyTech3(NO_TECH)
,m_iFavoriteEarlyWonder(NO_BUILDINGCLASS)
,m_iFavoriteLateWonder(NO_BUILDINGCLASS)
,m_iHatedCivicAttitudeChange(0)
,m_iHatedCivicAttitudeDivisor(0)
,m_iHatedCivicAttitudeChangeLimit(0)
,m_iHatedCivic(NO_CIVIC)

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvLeaderHeadInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvLeaderHeadInfo::~CvLeaderHeadInfo()
{
	SAFE_DELETE_ARRAY(m_pbTraits);
	SAFE_DELETE_ARRAY(m_piFlavorValue);
	SAFE_DELETE_ARRAY(m_piContactRand);
	SAFE_DELETE_ARRAY(m_piContactDelay);
	SAFE_DELETE_ARRAY(m_piMemoryDecayRand);
	SAFE_DELETE_ARRAY(m_piMemoryAttitudePercent);
	SAFE_DELETE_ARRAY(m_piNoWarAttitudeProb);
	SAFE_DELETE_ARRAY(m_piUnitAIWeightModifier);
	SAFE_DELETE_ARRAY(m_piImprovementWeightModifier);
	SAFE_DELETE_ARRAY(m_piDiploPeaceIntroMusicScriptIds);
	SAFE_DELETE_ARRAY(m_piDiploPeaceMusicScriptIds);
	SAFE_DELETE_ARRAY(m_piDiploWarIntroMusicScriptIds);
	SAFE_DELETE_ARRAY(m_piDiploWarMusicScriptIds);

//FfH: Added by Kael 09/29/2007
	SAFE_DELETE_ARRAY(m_piReligionWeightModifier);
//FfH: End Add

}

const TCHAR* CvLeaderHeadInfo::getButton() const
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvString cDefault = CvString::format("").GetCString();
	if (getArtDefineTag() == cDefault)
	{
		return NULL;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	const CvArtInfoLeaderhead * pLeaderheadArtInfo;
	pLeaderheadArtInfo = getArtInfo();
	if (pLeaderheadArtInfo != NULL)
	{
		return pLeaderheadArtInfo->getButton();
	}
	else
	{
		return NULL;
	}
}

int CvLeaderHeadInfo::getWonderConstructRand() const
{
	return m_iWonderConstructRand;
}

int CvLeaderHeadInfo::getBaseAttitude() const
{
	return m_iBaseAttitude;
}

int CvLeaderHeadInfo::getBasePeaceWeight() const
{
	return m_iBasePeaceWeight;
}

int CvLeaderHeadInfo::getPeaceWeightRand() const
{
	return m_iPeaceWeightRand;
}

int CvLeaderHeadInfo::getWarmongerRespect() const
{
	return m_iWarmongerRespect;
}

int CvLeaderHeadInfo::getEspionageWeight() const
{
	return m_iEspionageWeight;
}

int CvLeaderHeadInfo::getRefuseToTalkWarThreshold() const
{
	return m_iRefuseToTalkWarThreshold;
}

int CvLeaderHeadInfo::getNoTechTradeThreshold() const
{
	return m_iNoTechTradeThreshold;
}

int CvLeaderHeadInfo::getTechTradeKnownPercent() const
{
	return m_iTechTradeKnownPercent;
}

int CvLeaderHeadInfo::getMaxGoldTradePercent() const
{
	return m_iMaxGoldTradePercent;
}

int CvLeaderHeadInfo::getMaxGoldPerTurnTradePercent() const
{
	return m_iMaxGoldPerTurnTradePercent;
}

int CvLeaderHeadInfo::getMaxWarRand() const
{
	return m_iMaxWarRand;
}

int CvLeaderHeadInfo::getMaxWarNearbyPowerRatio() const
{
	return m_iMaxWarNearbyPowerRatio;
}

int CvLeaderHeadInfo::getMaxWarDistantPowerRatio() const
{
	return m_iMaxWarDistantPowerRatio;
}

int CvLeaderHeadInfo::getMaxWarMinAdjacentLandPercent() const
{
	return m_iMaxWarMinAdjacentLandPercent;
}

int CvLeaderHeadInfo::getLimitedWarRand() const
{
	return m_iLimitedWarRand;
}

int CvLeaderHeadInfo::getLimitedWarPowerRatio() const
{
	return m_iLimitedWarPowerRatio;
}

int CvLeaderHeadInfo::getDogpileWarRand() const
{
	return m_iDogpileWarRand;
}

int CvLeaderHeadInfo::getMakePeaceRand() const
{
	return m_iMakePeaceRand;
}

int CvLeaderHeadInfo::getDeclareWarTradeRand() const
{
	return m_iDeclareWarTradeRand;
}

int CvLeaderHeadInfo::getDemandRebukedSneakProb() const
{
	return m_iDemandRebukedSneakProb;
}

int CvLeaderHeadInfo::getDemandRebukedWarProb() const
{
	return m_iDemandRebukedWarProb;
}

int CvLeaderHeadInfo::getRazeCityProb() const
{
	return m_iRazeCityProb;
}

int CvLeaderHeadInfo::getBuildUnitProb() const
{
	return m_iBuildUnitProb;
}

int CvLeaderHeadInfo::getBaseAttackOddsChange() const
{
	return m_iBaseAttackOddsChange;
}

int CvLeaderHeadInfo::getAttackOddsChangeRand() const
{
	return m_iAttackOddsChangeRand;
}

int CvLeaderHeadInfo::getWorseRankDifferenceAttitudeChange() const
{
	return m_iWorseRankDifferenceAttitudeChange;
}

int CvLeaderHeadInfo::getBetterRankDifferenceAttitudeChange() const
{
	return m_iBetterRankDifferenceAttitudeChange;
}

int CvLeaderHeadInfo::getCloseBordersAttitudeChange() const
{
	return m_iCloseBordersAttitudeChange;
}

int CvLeaderHeadInfo::getLostWarAttitudeChange() const
{
	return m_iLostWarAttitudeChange;
}

int CvLeaderHeadInfo::getAtWarAttitudeDivisor() const
{
	return m_iAtWarAttitudeDivisor;
}

int CvLeaderHeadInfo::getAtWarAttitudeChangeLimit() const
{
	return m_iAtWarAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getAtPeaceAttitudeDivisor() const
{
	return m_iAtPeaceAttitudeDivisor;
}

int CvLeaderHeadInfo::getAtPeaceAttitudeChangeLimit() const
{
	return m_iAtPeaceAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getSameReligionAttitudeChange() const
{
	return m_iSameReligionAttitudeChange;
}

int CvLeaderHeadInfo::getSameReligionAttitudeDivisor() const
{
	return m_iSameReligionAttitudeDivisor;
}

int CvLeaderHeadInfo::getSameReligionAttitudeChangeLimit() const
{
	return m_iSameReligionAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getDifferentReligionAttitudeChange() const
{
	return m_iDifferentReligionAttitudeChange;
}

int CvLeaderHeadInfo::getDifferentReligionAttitudeDivisor() const
{
	return m_iDifferentReligionAttitudeDivisor;
}

int CvLeaderHeadInfo::getDifferentReligionAttitudeChangeLimit() const
{
	return m_iDifferentReligionAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getBonusTradeAttitudeDivisor() const
{
	return m_iBonusTradeAttitudeDivisor;
}

int CvLeaderHeadInfo::getBonusTradeAttitudeChangeLimit() const
{
	return m_iBonusTradeAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getOpenBordersAttitudeDivisor() const
{
	return m_iOpenBordersAttitudeDivisor;
}

int CvLeaderHeadInfo::getOpenBordersAttitudeChangeLimit() const
{
	return m_iOpenBordersAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getDefensivePactAttitudeDivisor() const
{
	return m_iDefensivePactAttitudeDivisor;
}

int CvLeaderHeadInfo::getDefensivePactAttitudeChangeLimit() const
{
	return m_iDefensivePactAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getShareWarAttitudeChange() const
{
	return m_iShareWarAttitudeChange;
}

int CvLeaderHeadInfo::getShareWarAttitudeDivisor() const
{
	return m_iShareWarAttitudeDivisor;
}

int CvLeaderHeadInfo::getShareWarAttitudeChangeLimit() const
{
	return m_iShareWarAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getFavoriteCivicAttitudeChange() const
{
	return m_iFavoriteCivicAttitudeChange;
}

int CvLeaderHeadInfo::getFavoriteCivicAttitudeDivisor() const
{
	return m_iFavoriteCivicAttitudeDivisor;
}

int CvLeaderHeadInfo::getFavoriteCivicAttitudeChangeLimit() const
{
	return m_iFavoriteCivicAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getDemandTributeAttitudeThreshold() const
{
	return m_iDemandTributeAttitudeThreshold;
}

int CvLeaderHeadInfo::getNoGiveHelpAttitudeThreshold() const
{
	return m_iNoGiveHelpAttitudeThreshold;
}

int CvLeaderHeadInfo::getTechRefuseAttitudeThreshold() const
{
	return m_iTechRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getStrategicBonusRefuseAttitudeThreshold() const
{
	return m_iStrategicBonusRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getHappinessBonusRefuseAttitudeThreshold() const
{
	return m_iHappinessBonusRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getHealthBonusRefuseAttitudeThreshold() const
{
	return m_iHealthBonusRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getMapRefuseAttitudeThreshold() const
{
	return m_iMapRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getDeclareWarRefuseAttitudeThreshold() const
{
	return m_iDeclareWarRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getDeclareWarThemRefuseAttitudeThreshold() const
{
	return m_iDeclareWarThemRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getStopTradingRefuseAttitudeThreshold() const
{
	return m_iStopTradingRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getStopTradingThemRefuseAttitudeThreshold() const
{
	return m_iStopTradingThemRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getAdoptCivicRefuseAttitudeThreshold() const
{
	return m_iAdoptCivicRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getConvertReligionRefuseAttitudeThreshold() const
{
	return m_iConvertReligionRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getOpenBordersRefuseAttitudeThreshold() const
{
	return m_iOpenBordersRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getDefensivePactRefuseAttitudeThreshold() const
{
	return m_iDefensivePactRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getPermanentAllianceRefuseAttitudeThreshold() const
{
	return m_iPermanentAllianceRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getVassalRefuseAttitudeThreshold() const
{
	return m_iVassalRefuseAttitudeThreshold;
}

int CvLeaderHeadInfo::getVassalPowerModifier() const
{
	return m_iVassalPowerModifier;
}

int CvLeaderHeadInfo::getFavoriteCivic() const
{
	return m_iFavoriteCivic;
}

int CvLeaderHeadInfo::getFavoriteReligion() const
{
	return m_iFavoriteReligion;
}

int CvLeaderHeadInfo::getFreedomAppreciation() const
{
	return m_iFreedomAppreciation;
}

const TCHAR* CvLeaderHeadInfo::getArtDefineTag() const
{
	return m_szArtDefineTag;
}

void CvLeaderHeadInfo::setArtDefineTag(const TCHAR* szVal)
{
	m_szArtDefineTag = szVal;
}

//FfH: Added by Kael 08/07/2007
int CvLeaderHeadInfo::getAlignment() const
{
	return m_iAlignment;
}

int CvLeaderHeadInfo::getAttitudeBadBonus() const
{
	return m_iAttitudeBadBonus;
}


int CvLeaderHeadInfo::getAttitudeFromFemales() const
{
	return m_iAttitudeFromFemales;
}

int CvLeaderHeadInfo::getAttitudeFromMales() const
{
	return m_iAttitudeFromMales;
}

int CvLeaderHeadInfo::getAttitudeToFemales() const
{
	return m_iAttitudeToFemales;
}

int CvLeaderHeadInfo::getAttitudeToMales() const
{
	return m_iAttitudeToMales;
}

//FfH Card Game: Added by Sto 08/08/2008
int CvLeaderHeadInfo::getSomniumAggressiveness() const
{
	return m_iSomniumAggressiveness;
}
//FfH: End Add

int CvLeaderHeadInfo::getFavoriteTech() const
{
	return m_iFavoriteTech;
}

int CvLeaderHeadInfo::getFavoriteUnitCombat() const
{
	return m_iFavoriteUnitCombat;
}

int CvLeaderHeadInfo::getFavoriteWonder() const
{
	return m_iFavoriteWonder;
}

int CvLeaderHeadInfo::getPermanentTrait() const
{
	return m_iPermanentTrait;
}

int CvLeaderHeadInfo::getReligionWeightModifier(int i) const
{
	FAssertMsg(i < GC.getNumReligionInfos(), "Index out of bounds");
//	FAssertMsg(i > -1, "Index out of bounds");	can be negative modified Sephi
	return m_piReligionWeightModifier ? m_piReligionWeightModifier[i] : -1;
}

bool CvLeaderHeadInfo::isFemale() const
{
    return m_bFemale;
}
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/

bool CvLeaderHeadInfo::isAltarVictory() const
{
    return m_bAltarVictory;
}

bool CvLeaderHeadInfo::isArcaneTowerVictory() const
{
    return m_bArcaneTowerVictory;
}
bool CvLeaderHeadInfo::isCultureVictory() const
{
    return m_bCultureVictory;
}
bool CvLeaderHeadInfo::isReligionVictory() const
{
    return m_bReligionVictory;
}

bool CvLeaderHeadInfo::isReligionOpportunist() const
{
    return m_bReligionOpportunist;
}

int CvLeaderHeadInfo::getAIPatrolGroupSize() const
{
    return m_iAIPatrolGroupSize;
}

int CvLeaderHeadInfo::getAIPatrolGroupMage() const
{
    return m_iAIPatrolGroupMage;
}

int CvLeaderHeadInfo::getAIValueDefense() const
{
    return m_iAIValueDefense;
}
int CvLeaderHeadInfo::getAIValueMage() const
{
    return m_iAIValueMage;
}

int CvLeaderHeadInfo::getEconomyTechValue() const
{
    return m_iEconomyTechValue;
}

int CvLeaderHeadInfo::getFavoriteEarlyReligion() const
{
    return m_iFavoriteEarlyReligion;
}

int CvLeaderHeadInfo::getFavoriteEarlyMilTech() const
{
    return m_iFavoriteEarlyMilTech;
}

int CvLeaderHeadInfo::getFavoriteEarlyTech1() const
{
    return m_iFavoriteEarlyTech1;
}

int CvLeaderHeadInfo::getFavoriteEarlyTech2() const
{
    return m_iFavoriteEarlyTech2;
}

int CvLeaderHeadInfo::getFavoriteEarlyTech3() const
{
    return m_iFavoriteEarlyTech3;
}

int CvLeaderHeadInfo::getFavoriteEarlyWonder() const
{
    return m_iFavoriteEarlyWonder;
}

int CvLeaderHeadInfo::getFavoriteLateWonder() const
{
    return m_iFavoriteLateWonder;
}

int CvLeaderHeadInfo::getHatedCivicAttitudeChange() const
{
    return m_iHatedCivicAttitudeChange;
}

int CvLeaderHeadInfo::getHatedCivicAttitudeDivisor() const
{
    return m_iHatedCivicAttitudeDivisor;
}

int CvLeaderHeadInfo::getHatedCivicAttitudeChangeLimit() const
{
    return m_iHatedCivicAttitudeChangeLimit;
}

int CvLeaderHeadInfo::getHatedCivic() const
{
    return m_iHatedCivic;
}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
// Arrays

bool CvLeaderHeadInfo::hasTrait(int i) const
{
	FAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbTraits ? m_pbTraits[i] : false;
}

int CvLeaderHeadInfo::getFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFlavorValue ? m_piFlavorValue[i] : -1;
}

int CvLeaderHeadInfo::getContactRand(int i) const
{
	FAssertMsg(i < NUM_CONTACT_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piContactRand ? m_piContactRand[i] : -1;
}

int CvLeaderHeadInfo::getContactDelay(int i) const
{
	FAssertMsg(i < NUM_CONTACT_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piContactDelay ? m_piContactDelay[i] : -1;
}

int CvLeaderHeadInfo::getMemoryDecayRand(int i) const
{
	FAssertMsg(i < NUM_MEMORY_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piMemoryDecayRand ? m_piMemoryDecayRand[i] : -1;
}

int CvLeaderHeadInfo::getMemoryAttitudePercent(int i) const
{
	FAssertMsg(i < NUM_MEMORY_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piMemoryAttitudePercent ? m_piMemoryAttitudePercent[i] : -1;
}

int CvLeaderHeadInfo::getNoWarAttitudeProb(int i) const
{
	FAssertMsg(i < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piNoWarAttitudeProb ? m_piNoWarAttitudeProb[i] : -1;
}

int CvLeaderHeadInfo::getUnitAIWeightModifier(int i) const
{
	FAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitAIWeightModifier ? m_piUnitAIWeightModifier[i] : -1;
}

int CvLeaderHeadInfo::getImprovementWeightModifier(int i) const
{
	FAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piImprovementWeightModifier ? m_piImprovementWeightModifier[i] : -1;
}

int CvLeaderHeadInfo::getDiploPeaceIntroMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploPeaceIntroMusicScriptIds ? m_piDiploPeaceIntroMusicScriptIds[i] : -1;
}

int CvLeaderHeadInfo::getDiploPeaceMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploPeaceMusicScriptIds ? m_piDiploPeaceMusicScriptIds[i] : -1;
}

int CvLeaderHeadInfo::getDiploWarIntroMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploWarIntroMusicScriptIds ? m_piDiploWarIntroMusicScriptIds[i] : -1;
}

int CvLeaderHeadInfo::getDiploWarMusicScriptIds(int i) const
{
	FAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piDiploWarMusicScriptIds ? m_piDiploWarMusicScriptIds[i] : -1;
}

const TCHAR* CvLeaderHeadInfo::getLeaderHead() const
{
	const CvArtInfoLeaderhead * pLeaderheadArtInfo;
	pLeaderheadArtInfo = getArtInfo();
	if (pLeaderheadArtInfo != NULL)
	{
		return pLeaderheadArtInfo->getNIF();
	}
	else
	{
		return NULL;
	}
}

void CvLeaderHeadInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iWonderConstructRand);
	stream->Read(&m_iBaseAttitude);
	stream->Read(&m_iBasePeaceWeight);
	stream->Read(&m_iPeaceWeightRand);
	stream->Read(&m_iWarmongerRespect);
	stream->Read(&m_iEspionageWeight);
	stream->Read(&m_iRefuseToTalkWarThreshold);
	stream->Read(&m_iNoTechTradeThreshold);
	stream->Read(&m_iTechTradeKnownPercent);
	stream->Read(&m_iMaxGoldTradePercent);
	stream->Read(&m_iMaxGoldPerTurnTradePercent);
	stream->Read(&m_iMaxWarRand);
	stream->Read(&m_iMaxWarNearbyPowerRatio);
	stream->Read(&m_iMaxWarDistantPowerRatio);
	stream->Read(&m_iMaxWarMinAdjacentLandPercent);
	stream->Read(&m_iLimitedWarRand);
	stream->Read(&m_iLimitedWarPowerRatio);
	stream->Read(&m_iDogpileWarRand);
	stream->Read(&m_iMakePeaceRand);
	stream->Read(&m_iDeclareWarTradeRand);
	stream->Read(&m_iDemandRebukedSneakProb);
	stream->Read(&m_iDemandRebukedWarProb);
	stream->Read(&m_iRazeCityProb);
	stream->Read(&m_iBuildUnitProb);
	stream->Read(&m_iBaseAttackOddsChange);
	stream->Read(&m_iAttackOddsChangeRand);
	stream->Read(&m_iWorseRankDifferenceAttitudeChange);
	stream->Read(&m_iBetterRankDifferenceAttitudeChange);
	stream->Read(&m_iCloseBordersAttitudeChange);
	stream->Read(&m_iLostWarAttitudeChange);
	stream->Read(&m_iAtWarAttitudeDivisor);
	stream->Read(&m_iAtWarAttitudeChangeLimit);
	stream->Read(&m_iAtPeaceAttitudeDivisor);
	stream->Read(&m_iAtPeaceAttitudeChangeLimit);
	stream->Read(&m_iSameReligionAttitudeChange);
	stream->Read(&m_iSameReligionAttitudeDivisor);
	stream->Read(&m_iSameReligionAttitudeChangeLimit);
	stream->Read(&m_iDifferentReligionAttitudeChange);
	stream->Read(&m_iDifferentReligionAttitudeDivisor);
	stream->Read(&m_iDifferentReligionAttitudeChangeLimit);
	stream->Read(&m_iBonusTradeAttitudeDivisor);
	stream->Read(&m_iBonusTradeAttitudeChangeLimit);
	stream->Read(&m_iOpenBordersAttitudeDivisor);
	stream->Read(&m_iOpenBordersAttitudeChangeLimit);
	stream->Read(&m_iDefensivePactAttitudeDivisor);
	stream->Read(&m_iDefensivePactAttitudeChangeLimit);
	stream->Read(&m_iShareWarAttitudeChange);
	stream->Read(&m_iShareWarAttitudeDivisor);
	stream->Read(&m_iShareWarAttitudeChangeLimit);
	stream->Read(&m_iFavoriteCivicAttitudeChange);
	stream->Read(&m_iFavoriteCivicAttitudeDivisor);
	stream->Read(&m_iFavoriteCivicAttitudeChangeLimit);
	stream->Read(&m_iDemandTributeAttitudeThreshold);
	stream->Read(&m_iNoGiveHelpAttitudeThreshold);
	stream->Read(&m_iTechRefuseAttitudeThreshold);
	stream->Read(&m_iStrategicBonusRefuseAttitudeThreshold);
	stream->Read(&m_iHappinessBonusRefuseAttitudeThreshold);
	stream->Read(&m_iHealthBonusRefuseAttitudeThreshold);
	stream->Read(&m_iMapRefuseAttitudeThreshold);
	stream->Read(&m_iDeclareWarRefuseAttitudeThreshold);
	stream->Read(&m_iDeclareWarThemRefuseAttitudeThreshold);
	stream->Read(&m_iStopTradingRefuseAttitudeThreshold);
	stream->Read(&m_iStopTradingThemRefuseAttitudeThreshold);
	stream->Read(&m_iAdoptCivicRefuseAttitudeThreshold);
	stream->Read(&m_iConvertReligionRefuseAttitudeThreshold);
	stream->Read(&m_iOpenBordersRefuseAttitudeThreshold);
	stream->Read(&m_iDefensivePactRefuseAttitudeThreshold);
	stream->Read(&m_iPermanentAllianceRefuseAttitudeThreshold);
	stream->Read(&m_iVassalRefuseAttitudeThreshold);
	stream->Read(&m_iVassalPowerModifier);
	stream->Read(&m_iFreedomAppreciation);
	stream->Read(&m_iFavoriteCivic);
	stream->Read(&m_iFavoriteReligion);

	stream->ReadString(m_szArtDefineTag);

//FfH: Added by Kael 08/07/2007
	stream->Read(&m_bFemale);
	stream->Read(&m_iAlignment);
	stream->Read(&m_iAttitudeBadBonus);
	stream->Read(&m_iAttitudeFromFemales);
	stream->Read(&m_iAttitudeFromMales);
	stream->Read(&m_iAttitudeToFemales);
	stream->Read(&m_iAttitudeToMales);

//FfH Card Game: Added by Sto 08/08/2008
	stream->Read(&m_iSomniumAggressiveness);
//FfH: End Add

	stream->Read(&m_iFavoriteTech);
	stream->Read(&m_iFavoriteUnitCombat);
	stream->Read(&m_iFavoriteWonder);
	stream->Read(&m_iPermanentTrait);

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    stream->Read(&m_bAltarVictory);
    stream->Read(&m_bArcaneTowerVictory);
    stream->Read(&m_bCultureVictory);
    stream->Read(&m_bReligionVictory);

    stream->Read(&m_bReligionOpportunist);
    stream->Read(&m_iAIPatrolGroupSize);
    stream->Read(&m_iAIPatrolGroupMage);
    stream->Read(&m_iAIValueDefense);
    stream->Read(&m_iAIValueMage);
    stream->Read(&m_iEconomyTechValue);
    stream->Read(&m_iFavoriteEarlyReligion);
    stream->Read(&m_iFavoriteEarlyMilTech);
    stream->Read(&m_iFavoriteEarlyTech1);
    stream->Read(&m_iFavoriteEarlyTech2);
    stream->Read(&m_iFavoriteEarlyTech3);
    stream->Read(&m_iFavoriteEarlyWonder);
    stream->Read(&m_iFavoriteLateWonder);
	stream->Read(&m_iHatedCivicAttitudeChange);
	stream->Read(&m_iHatedCivicAttitudeDivisor);
	stream->Read(&m_iHatedCivicAttitudeChangeLimit);
	stream->Read(&m_iHatedCivic);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/


	SAFE_DELETE_ARRAY(m_piReligionWeightModifier);
	m_piReligionWeightModifier = new int[GC.getNumReligionInfos()];
	stream->Read(GC.getNumReligionInfos(), m_piReligionWeightModifier);
//FfH: End Add

	// Arrays

	SAFE_DELETE_ARRAY(m_pbTraits);
	m_pbTraits = new bool[GC.getNumTraitInfos()];
	stream->Read(GC.getNumTraitInfos(), m_pbTraits);

	SAFE_DELETE_ARRAY(m_piFlavorValue);
	m_piFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piFlavorValue);

	SAFE_DELETE_ARRAY(m_piContactRand);
	m_piContactRand = new int[NUM_CONTACT_TYPES];
	stream->Read(NUM_CONTACT_TYPES, m_piContactRand);

	SAFE_DELETE_ARRAY(m_piContactDelay);
	m_piContactDelay = new int[NUM_CONTACT_TYPES];
	stream->Read(NUM_CONTACT_TYPES, m_piContactDelay);

	SAFE_DELETE_ARRAY(m_piMemoryDecayRand);
	m_piMemoryDecayRand = new int[NUM_MEMORY_TYPES];
	stream->Read(NUM_MEMORY_TYPES, m_piMemoryDecayRand);

	SAFE_DELETE_ARRAY(m_piMemoryAttitudePercent);
	m_piMemoryAttitudePercent = new int[NUM_MEMORY_TYPES];
	stream->Read(NUM_MEMORY_TYPES, m_piMemoryAttitudePercent);

	SAFE_DELETE_ARRAY(m_piNoWarAttitudeProb);
	m_piNoWarAttitudeProb = new int[NUM_ATTITUDE_TYPES];
	stream->Read(NUM_ATTITUDE_TYPES, m_piNoWarAttitudeProb);

	SAFE_DELETE_ARRAY(m_piUnitAIWeightModifier);
	m_piUnitAIWeightModifier = new int[NUM_UNITAI_TYPES];
	stream->Read(NUM_UNITAI_TYPES, m_piUnitAIWeightModifier);

	SAFE_DELETE_ARRAY(m_piImprovementWeightModifier);
	m_piImprovementWeightModifier = new int[GC.getNumImprovementInfos()];
	stream->Read(GC.getNumImprovementInfos(), m_piImprovementWeightModifier);

	SAFE_DELETE_ARRAY(m_piDiploPeaceIntroMusicScriptIds);
	m_piDiploPeaceIntroMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploPeaceIntroMusicScriptIds);

	SAFE_DELETE_ARRAY(m_piDiploPeaceMusicScriptIds);
	m_piDiploPeaceMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploPeaceMusicScriptIds);

	SAFE_DELETE_ARRAY(m_piDiploWarIntroMusicScriptIds);
	m_piDiploWarIntroMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploWarIntroMusicScriptIds);

	SAFE_DELETE_ARRAY(m_piDiploWarMusicScriptIds);
	m_piDiploWarMusicScriptIds = new int[GC.getNumEraInfos()];
	stream->Read(GC.getNumEraInfos(), m_piDiploWarMusicScriptIds);
}

void CvLeaderHeadInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iWonderConstructRand);
	stream->Write(m_iBaseAttitude);
	stream->Write(m_iBasePeaceWeight);
	stream->Write(m_iPeaceWeightRand);
	stream->Write(m_iWarmongerRespect);
	stream->Write(m_iEspionageWeight);
	stream->Write(m_iRefuseToTalkWarThreshold);
	stream->Write(m_iNoTechTradeThreshold);
	stream->Write(m_iTechTradeKnownPercent);
	stream->Write(m_iMaxGoldTradePercent);
	stream->Write(m_iMaxGoldPerTurnTradePercent);
	stream->Write(m_iMaxWarRand);
	stream->Write(m_iMaxWarNearbyPowerRatio);
	stream->Write(m_iMaxWarDistantPowerRatio);
	stream->Write(m_iMaxWarMinAdjacentLandPercent);
	stream->Write(m_iLimitedWarRand);
	stream->Write(m_iLimitedWarPowerRatio);
	stream->Write(m_iDogpileWarRand);
	stream->Write(m_iMakePeaceRand);
	stream->Write(m_iDeclareWarTradeRand);
	stream->Write(m_iDemandRebukedSneakProb);
	stream->Write(m_iDemandRebukedWarProb);
	stream->Write(m_iRazeCityProb);
	stream->Write(m_iBuildUnitProb);
	stream->Write(m_iBaseAttackOddsChange);
	stream->Write(m_iAttackOddsChangeRand);
	stream->Write(m_iWorseRankDifferenceAttitudeChange);
	stream->Write(m_iBetterRankDifferenceAttitudeChange);
	stream->Write(m_iCloseBordersAttitudeChange);
	stream->Write(m_iLostWarAttitudeChange);
	stream->Write(m_iAtWarAttitudeDivisor);
	stream->Write(m_iAtWarAttitudeChangeLimit);
	stream->Write(m_iAtPeaceAttitudeDivisor);
	stream->Write(m_iAtPeaceAttitudeChangeLimit);
	stream->Write(m_iSameReligionAttitudeChange);
	stream->Write(m_iSameReligionAttitudeDivisor);
	stream->Write(m_iSameReligionAttitudeChangeLimit);
	stream->Write(m_iDifferentReligionAttitudeChange);
	stream->Write(m_iDifferentReligionAttitudeDivisor);
	stream->Write(m_iDifferentReligionAttitudeChangeLimit);
	stream->Write(m_iBonusTradeAttitudeDivisor);
	stream->Write(m_iBonusTradeAttitudeChangeLimit);
	stream->Write(m_iOpenBordersAttitudeDivisor);
	stream->Write(m_iOpenBordersAttitudeChangeLimit);
	stream->Write(m_iDefensivePactAttitudeDivisor);
	stream->Write(m_iDefensivePactAttitudeChangeLimit);
	stream->Write(m_iShareWarAttitudeChange);
	stream->Write(m_iShareWarAttitudeDivisor);
	stream->Write(m_iShareWarAttitudeChangeLimit);
	stream->Write(m_iFavoriteCivicAttitudeChange);
	stream->Write(m_iFavoriteCivicAttitudeDivisor);
	stream->Write(m_iFavoriteCivicAttitudeChangeLimit);
	stream->Write(m_iDemandTributeAttitudeThreshold);
	stream->Write(m_iNoGiveHelpAttitudeThreshold);
	stream->Write(m_iTechRefuseAttitudeThreshold);
	stream->Write(m_iStrategicBonusRefuseAttitudeThreshold);
	stream->Write(m_iHappinessBonusRefuseAttitudeThreshold);
	stream->Write(m_iHealthBonusRefuseAttitudeThreshold);
	stream->Write(m_iMapRefuseAttitudeThreshold);
	stream->Write(m_iDeclareWarRefuseAttitudeThreshold);
	stream->Write(m_iDeclareWarThemRefuseAttitudeThreshold);
	stream->Write(m_iStopTradingRefuseAttitudeThreshold);
	stream->Write(m_iStopTradingThemRefuseAttitudeThreshold);
	stream->Write(m_iAdoptCivicRefuseAttitudeThreshold);
	stream->Write(m_iConvertReligionRefuseAttitudeThreshold);
	stream->Write(m_iOpenBordersRefuseAttitudeThreshold);
	stream->Write(m_iDefensivePactRefuseAttitudeThreshold);
	stream->Write(m_iPermanentAllianceRefuseAttitudeThreshold);
	stream->Write(m_iVassalRefuseAttitudeThreshold);
	stream->Write(m_iVassalPowerModifier);
	stream->Write(m_iFreedomAppreciation);
	stream->Write(m_iFavoriteCivic);
	stream->Write(m_iFavoriteReligion);

	stream->WriteString(m_szArtDefineTag);

//FfH: Added by Kael 08/07/2007
	stream->Write(m_bFemale);
	stream->Write(m_iAlignment);
	stream->Write(m_iAttitudeBadBonus);
	stream->Write(m_iAttitudeFromFemales);
	stream->Write(m_iAttitudeFromMales);
	stream->Write(m_iAttitudeToFemales);
	stream->Write(m_iAttitudeToMales);

//FfH Card Game: Added by Sto 08/08/2008
	stream->Write(m_iSomniumAggressiveness);
//FfH: End Add

	stream->Write(m_iFavoriteTech);
	stream->Write(m_iFavoriteUnitCombat);
	stream->Write(m_iFavoriteWonder);
	stream->Write(m_iPermanentTrait);

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    stream->Write(m_bAltarVictory);
    stream->Write(m_bArcaneTowerVictory);
    stream->Write(m_bCultureVictory);
    stream->Write(m_bReligionVictory);

	stream->Write(m_bReligionOpportunist);
    stream->Write(m_iAIPatrolGroupSize);
    stream->Write(m_iAIPatrolGroupMage);
    stream->Write(m_iAIValueDefense);
    stream->Write(m_iAIValueMage);
    stream->Write(m_iEconomyTechValue);
    stream->Write(m_iFavoriteEarlyReligion);
    stream->Write(m_iFavoriteEarlyMilTech);
    stream->Write(m_iFavoriteEarlyTech1);
    stream->Write(m_iFavoriteEarlyTech2);
    stream->Write(m_iFavoriteEarlyTech3);
    stream->Write(m_iFavoriteEarlyWonder);
    stream->Write(m_iFavoriteLateWonder);
	stream->Write(m_iHatedCivicAttitudeChange);
	stream->Write(m_iHatedCivicAttitudeDivisor);
	stream->Write(m_iHatedCivicAttitudeChangeLimit);
	stream->Write(m_iHatedCivic);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

    stream->Write(GC.getNumReligionInfos(), m_piReligionWeightModifier);
//FfH: End Add

	// Arrays

	stream->Write(GC.getNumTraitInfos(), m_pbTraits);

	stream->Write(GC.getNumFlavorTypes(), m_piFlavorValue);
	stream->Write(NUM_CONTACT_TYPES, m_piContactRand);
	stream->Write(NUM_CONTACT_TYPES, m_piContactDelay);
	stream->Write(NUM_MEMORY_TYPES, m_piMemoryDecayRand);
	stream->Write(NUM_MEMORY_TYPES, m_piMemoryAttitudePercent);
	stream->Write(NUM_ATTITUDE_TYPES, m_piNoWarAttitudeProb);
	stream->Write(NUM_UNITAI_TYPES, m_piUnitAIWeightModifier);
	stream->Write(GC.getNumImprovementInfos(), m_piImprovementWeightModifier);
	stream->Write(GC.getNumEraInfos(), m_piDiploPeaceIntroMusicScriptIds);
	stream->Write(GC.getNumEraInfos(), m_piDiploPeaceMusicScriptIds);
	stream->Write(GC.getNumEraInfos(), m_piDiploWarIntroMusicScriptIds);
	stream->Write(GC.getNumEraInfos(), m_piDiploWarMusicScriptIds);

}

const CvArtInfoLeaderhead* CvLeaderHeadInfo::getArtInfo() const
{
	return ARTFILEMGR.getLeaderheadArtInfo( getArtDefineTag());
}

bool CvLeaderHeadInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ArtDefineTag");
	setArtDefineTag(szTextVal);

	pXML->GetChildXmlValByName(&m_iWonderConstructRand, "iWonderConstructRand",0);
	pXML->GetChildXmlValByName(&m_iBaseAttitude, "iBaseAttitude");
	pXML->GetChildXmlValByName(&m_iBasePeaceWeight, "iBasePeaceWeight");
	pXML->GetChildXmlValByName(&m_iPeaceWeightRand, "iPeaceWeightRand");
	pXML->GetChildXmlValByName(&m_iWarmongerRespect, "iWarmongerRespect");
	pXML->GetChildXmlValByName(&m_iEspionageWeight, "iEspionageWeight",0);
	pXML->GetChildXmlValByName(&m_iRefuseToTalkWarThreshold, "iRefuseToTalkWarThreshold");
	pXML->GetChildXmlValByName(&m_iNoTechTradeThreshold, "iNoTechTradeThreshold");
	pXML->GetChildXmlValByName(&m_iTechTradeKnownPercent, "iTechTradeKnownPercent");
	pXML->GetChildXmlValByName(&m_iMaxGoldTradePercent, "iMaxGoldTradePercent");
	pXML->GetChildXmlValByName(&m_iMaxGoldPerTurnTradePercent, "iMaxGoldPerTurnTradePercent");
	pXML->GetChildXmlValByName(&m_iMaxWarRand, "iMaxWarRand",50);
	pXML->GetChildXmlValByName(&m_iMaxWarNearbyPowerRatio, "iMaxWarNearbyPowerRatio");
	pXML->GetChildXmlValByName(&m_iMaxWarDistantPowerRatio, "iMaxWarDistantPowerRatio");
	pXML->GetChildXmlValByName(&m_iMaxWarMinAdjacentLandPercent, "iMaxWarMinAdjacentLandPercent");
	pXML->GetChildXmlValByName(&m_iLimitedWarRand, "iLimitedWarRand");
	pXML->GetChildXmlValByName(&m_iLimitedWarPowerRatio, "iLimitedWarPowerRatio");
	pXML->GetChildXmlValByName(&m_iDogpileWarRand, "iDogpileWarRand");
	pXML->GetChildXmlValByName(&m_iMakePeaceRand, "iMakePeaceRand");
	pXML->GetChildXmlValByName(&m_iDeclareWarTradeRand, "iDeclareWarTradeRand");
	pXML->GetChildXmlValByName(&m_iDemandRebukedSneakProb, "iDemandRebukedSneakProb");
	pXML->GetChildXmlValByName(&m_iDemandRebukedWarProb, "iDemandRebukedWarProb");
	pXML->GetChildXmlValByName(&m_iRazeCityProb, "iRazeCityProb",0);
	pXML->GetChildXmlValByName(&m_iBuildUnitProb, "iBuildUnitProb",25);
	pXML->GetChildXmlValByName(&m_iBaseAttackOddsChange, "iBaseAttackOddsChange",0);
	pXML->GetChildXmlValByName(&m_iAttackOddsChangeRand, "iAttackOddsChangeRand",0);
	pXML->GetChildXmlValByName(&m_iWorseRankDifferenceAttitudeChange, "iWorseRankDifferenceAttitudeChange");
	pXML->GetChildXmlValByName(&m_iBetterRankDifferenceAttitudeChange, "iBetterRankDifferenceAttitudeChange");
	pXML->GetChildXmlValByName(&m_iCloseBordersAttitudeChange, "iCloseBordersAttitudeChange");
	pXML->GetChildXmlValByName(&m_iLostWarAttitudeChange, "iLostWarAttitudeChange");
	pXML->GetChildXmlValByName(&m_iAtWarAttitudeDivisor, "iAtWarAttitudeDivisor",10);
	pXML->GetChildXmlValByName(&m_iAtWarAttitudeChangeLimit, "iAtWarAttitudeChangeLimit");
	pXML->GetChildXmlValByName(&m_iAtPeaceAttitudeDivisor, "iAtPeaceAttitudeDivisor",50);
	pXML->GetChildXmlValByName(&m_iAtPeaceAttitudeChangeLimit, "iAtPeaceAttitudeChangeLimit",5);
	pXML->GetChildXmlValByName(&m_iSameReligionAttitudeChange, "iSameReligionAttitudeChange",0);
	pXML->GetChildXmlValByName(&m_iSameReligionAttitudeDivisor, "iSameReligionAttitudeDivisor", 30);
	pXML->GetChildXmlValByName(&m_iSameReligionAttitudeChangeLimit, "iSameReligionAttitudeChangeLimit",5);
	pXML->GetChildXmlValByName(&m_iDifferentReligionAttitudeChange, "iDifferentReligionAttitudeChange",0);
	pXML->GetChildXmlValByName(&m_iDifferentReligionAttitudeDivisor, "iDifferentReligionAttitudeDivisor",-30);
	pXML->GetChildXmlValByName(&m_iDifferentReligionAttitudeChangeLimit, "iDifferentReligionAttitudeChangeLimit",-5);
	pXML->GetChildXmlValByName(&m_iBonusTradeAttitudeDivisor, "iBonusTradeAttitudeDivisor",30);
	pXML->GetChildXmlValByName(&m_iBonusTradeAttitudeChangeLimit, "iBonusTradeAttitudeChangeLimit",1);
	pXML->GetChildXmlValByName(&m_iOpenBordersAttitudeDivisor, "iOpenBordersAttitudeDivisor",30);
	pXML->GetChildXmlValByName(&m_iOpenBordersAttitudeChangeLimit, "iOpenBordersAttitudeChangeLimit",1);
	pXML->GetChildXmlValByName(&m_iDefensivePactAttitudeDivisor, "iDefensivePactAttitudeDivisor",50);
	pXML->GetChildXmlValByName(&m_iDefensivePactAttitudeChangeLimit, "iDefensivePactAttitudeChangeLimit",2);
	pXML->GetChildXmlValByName(&m_iShareWarAttitudeChange, "iShareWarAttitudeChange",2);
	pXML->GetChildXmlValByName(&m_iShareWarAttitudeDivisor, "iShareWarAttitudeDivisor",10);
	pXML->GetChildXmlValByName(&m_iShareWarAttitudeChangeLimit, "iShareWarAttitudeChangeLimit",2);
	pXML->GetChildXmlValByName(&m_iFavoriteCivicAttitudeChange, "iFavoriteCivicAttitudeChange",2);
	pXML->GetChildXmlValByName(&m_iFavoriteCivicAttitudeDivisor, "iFavoriteCivicAttitudeDivisor",30);
	pXML->GetChildXmlValByName(&m_iFavoriteCivicAttitudeChangeLimit, "iFavoriteCivicAttitudeChangeLimit",2);
	pXML->GetChildXmlValByName(&m_iVassalPowerModifier, "iVassalPowerModifier");
	pXML->GetChildXmlValByName(&m_iFreedomAppreciation, "iFreedomAppreciation");

	pXML->GetChildXmlValByName(szTextVal, "DemandTributeAttitudeThreshold","ATTITUDE_ANNOYED");
	m_iDemandTributeAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "NoGiveHelpAttitudeThreshold","ATTITUDE_PLEASED");
	m_iNoGiveHelpAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iTechRefuseAttitudeThreshold = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StrategicBonusRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iStrategicBonusRefuseAttitudeThreshold = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "HappinessBonusRefuseAttitudeThreshold","ATTITUDE_CAUTIOUS");
	m_iHappinessBonusRefuseAttitudeThreshold = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "HealthBonusRefuseAttitudeThreshold","ATTITUDE_CAUTIOUS");
	m_iHealthBonusRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MapRefuseAttitudeThreshold","ATTITUDE_CAUTIOUS");
	m_iMapRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DeclareWarRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iDeclareWarRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DeclareWarThemRefuseAttitudeThreshold","ATTITUDE_CAUTIOUS");
	m_iDeclareWarThemRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StopTradingRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iStopTradingRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "StopTradingThemRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iStopTradingThemRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "AdoptCivicRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iAdoptCivicRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ConvertReligionRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iConvertReligionRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "OpenBordersRefuseAttitudeThreshold","ATTITUDE_ANNOYED");
	m_iOpenBordersRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "DefensivePactRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iDefensivePactRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PermanentAllianceRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iPermanentAllianceRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "VassalRefuseAttitudeThreshold","ATTITUDE_PLEASED");
	m_iVassalRefuseAttitudeThreshold = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FavoriteCivic");
	m_iFavoriteCivic = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FavoriteReligion");
	m_iFavoriteReligion = pXML->FindInInfoClass(szTextVal);

	pXML->SetVariableListTagPair(&m_pbTraits, "Traits", sizeof(GC.getTraitInfo((TraitTypes)0)), GC.getNumTraitInfos());

	pXML->SetVariableListTagPair(&m_piFlavorValue, "Flavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());
	pXML->SetVariableListTagPair(&m_piContactRand, "ContactRands", GC.getContactTypes(), NUM_CONTACT_TYPES);
/*************************************************************************************************/
/**	ADDON (Default Values for ContactRands) Sephi                           					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/

    if(NUM_CONTACT_TYPES==14)
    {
/** if you care about open borders, ask for them! **/
        if (m_iOpenBordersAttitudeChangeLimit>3)
        {
            m_piContactRand[CONTACT_OPEN_BORDERS]=1;
        }
/** if you care about bonuses, ask for them! **/
        if (m_iBonusTradeAttitudeChangeLimit>2)
        {
            m_piContactRand[CONTACT_TRADE_BONUS]=1;
        }
    }
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piContactDelay, "ContactDelays", GC.getContactTypes(), NUM_CONTACT_TYPES);
	pXML->SetVariableListTagPair(&m_piMemoryDecayRand, "MemoryDecays", sizeof(GC.getMemoryInfo((MemoryTypes)0)), NUM_MEMORY_TYPES);
	pXML->SetVariableListTagPair(&m_piMemoryAttitudePercent, "MemoryAttitudePercents", sizeof(GC.getMemoryInfo((MemoryTypes)0)), NUM_MEMORY_TYPES);
/*************************************************************************************************/
/**	ADDON (Default Values for MemoryAttitudes) Sephi                           					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
/** temporarily moved to the DLL to see what good default Values could be **/
    if(NUM_MEMORY_TYPES==37)
    {
        m_piMemoryAttitudePercent[0]=-300;
        m_piMemoryAttitudePercent[1]=-200;
        m_piMemoryAttitudePercent[2]=-100;
        m_piMemoryAttitudePercent[3]=0;
        m_piMemoryAttitudePercent[4]=0;        //nuked friend
        m_piMemoryAttitudePercent[5]=-100;
        m_piMemoryAttitudePercent[6]=-200;
        m_piMemoryAttitudePercent[7]=0;
        m_piMemoryAttitudePercent[8]=200;
        m_piMemoryAttitudePercent[9]=-200;
        m_piMemoryAttitudePercent[10]=200;		//accept demand
        m_piMemoryAttitudePercent[11]=-200;
        m_piMemoryAttitudePercent[12]=200;
        m_piMemoryAttitudePercent[13]=-200;
        m_piMemoryAttitudePercent[14]=200;
        m_piMemoryAttitudePercent[15]=-200;
        m_piMemoryAttitudePercent[16]=200;
        m_piMemoryAttitudePercent[17]=-200;		// DENIED_JOIN_WAR
        m_piMemoryAttitudePercent[18]=200;
        m_piMemoryAttitudePercent[19]=-200;
        m_piMemoryAttitudePercent[20]=-100;
        m_piMemoryAttitudePercent[21]=-200;		//STOPPED_TRADING_RECENT_TRADING_RECENT
        m_piMemoryAttitudePercent[22]=0;
        m_piMemoryAttitudePercent[23]=-200;
        m_piMemoryAttitudePercent[24]=0;
        m_piMemoryAttitudePercent[25]=-100;
        m_piMemoryAttitudePercent[26]=10;        //MEMORY_TRADED_TECH_TO_US
        m_piMemoryAttitudePercent[27]=0;		//RECEIVED_TECH_FROM_ANY
        m_piMemoryAttitudePercent[28]=-300;
        m_piMemoryAttitudePercent[29]=300;
        m_piMemoryAttitudePercent[30]=0;
        m_piMemoryAttitudePercent[31]=0;
        m_piMemoryAttitudePercent[32]=200;
        m_piMemoryAttitudePercent[33]=100;        // Somnium
        m_piMemoryAttitudePercent[34]=-100;
        m_piMemoryAttitudePercent[35]=0;
        m_piMemoryAttitudePercent[36]=1;
    }
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piNoWarAttitudeProb, "NoWarAttitudeProbs", sizeof(GC.getAttitudeInfo((AttitudeTypes)0)), NUM_ATTITUDE_TYPES);
	pXML->SetVariableListTagPair(&m_piUnitAIWeightModifier, "UnitAIWeightModifiers", sizeof(GC.getUnitAIInfo((UnitAITypes)0)), NUM_UNITAI_TYPES);
	pXML->SetVariableListTagPair(&m_piImprovementWeightModifier, "ImprovementWeightModifiers", sizeof(GC.getImprovementInfo((ImprovementTypes)0)), GC.getNumImprovementInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploPeaceIntroMusicScriptIds, "DiplomacyIntroMusicPeace", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploPeaceMusicScriptIds, "DiplomacyMusicPeace", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploWarIntroMusicScriptIds, "DiplomacyIntroMusicWar", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());
	pXML->SetVariableListTagPairForAudioScripts(&m_piDiploWarMusicScriptIds, "DiplomacyMusicWar", sizeof(GC.getEraInfo((EraTypes)0)), GC.getNumEraInfos());

//FfH: Added by Kael 08/07/2007
	pXML->GetChildXmlValByName(&m_bFemale, "bFemale");
	pXML->GetChildXmlValByName(szTextVal, "Alignment");
	m_iAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iAttitudeBadBonus, "iAttitudeBadBonus");
	pXML->GetChildXmlValByName(&m_iAttitudeFromFemales, "iAttitudeFromFemales");
	pXML->GetChildXmlValByName(&m_iAttitudeFromMales, "iAttitudeFromMales");
	pXML->GetChildXmlValByName(&m_iAttitudeToFemales, "iAttitudeToFemales");
	pXML->GetChildXmlValByName(&m_iAttitudeToMales, "iAttitudeToMales");

//FfH Card Game: Added by Sto 08/08/2008
	pXML->GetChildXmlValByName(&m_iSomniumAggressiveness, "iSomniumAggressiveness");
//FfH: End Add

	pXML->GetChildXmlValByName(szTextVal, "FavoriteTech");
	m_iFavoriteTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FavoriteUnitCombat");
	m_iFavoriteUnitCombat = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FavoriteWonder");
	m_iFavoriteWonder = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PermanentTrait");
	m_iPermanentTrait = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bAltarVictory, "bAltarVictory",0);
	pXML->GetChildXmlValByName(&m_bArcaneTowerVictory, "bArcaneTowerVictory",0);
	pXML->GetChildXmlValByName(&m_bCultureVictory, "bCultureVictory",0);
	pXML->GetChildXmlValByName(&m_bReligionVictory, "bReligionVictory",0);

	pXML->GetChildXmlValByName(&m_bReligionOpportunist, "bReligionOpportunist",0);
    pXML->GetChildXmlValByName(&m_iAIPatrolGroupMage, "iAIPatrolGroupMage",100);
    pXML->GetChildXmlValByName(&m_iAIPatrolGroupSize, "iAIPatrolGroupSize",100);
    pXML->GetChildXmlValByName(&m_iAIValueDefense, "iAIValueDefense",100);
    pXML->GetChildXmlValByName(&m_iAIValueMage, "iAIValueMage",100);

    pXML->GetChildXmlValByName(&m_iEconomyTechValue, "iEconomyTechValue",100);
	pXML->GetChildXmlValByName(szTextVal, "iFavoriteEarlyReligion");
	m_iFavoriteEarlyReligion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "iFavoriteEarlyMilTech");
	m_iFavoriteEarlyMilTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "iFavoriteEarlyTech1");
	m_iFavoriteEarlyTech1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "iFavoriteEarlyTech2");
	m_iFavoriteEarlyTech2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "iFavoriteEarlyTech3");
	m_iFavoriteEarlyTech3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "iFavoriteEarlyWonder");
	m_iFavoriteEarlyWonder = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "iFavoriteLateWonder");
	m_iFavoriteLateWonder = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iHatedCivicAttitudeChange, "iHatedCivicAttitudeChange",-2);
	pXML->GetChildXmlValByName(&m_iHatedCivicAttitudeDivisor, "iHatedCivicAttitudeDivisor", 30);
	pXML->GetChildXmlValByName(&m_iHatedCivicAttitudeChangeLimit, "iHatedCivicAttitudeChangeLimit",-2);
	pXML->GetChildXmlValByName(szTextVal, "HatedCivic");
	m_iHatedCivic = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	pXML->SetVariableListTagPair(&m_piReligionWeightModifier, "ReligionWeightModifiers", sizeof(GC.getReligionInfo((ReligionTypes)0)), GC.getNumReligionInfos());
//FfH: End Add

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(LeaderInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvLeaderHeadInfo::copyNonDefaults(CvLeaderHeadInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if (getArtDefineTag()								== cDefault)		setArtDefineTag(								pClassInfo->getArtDefineTag());
	//Must do Art Define before Info Base to get the right button
	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isFemale()										== false)			m_bFemale										= pClassInfo->isFemale();
	if (getWonderConstructRand()						== 0)				m_iWonderConstructRand							= pClassInfo->getWonderConstructRand();
	if (getBaseAttitude()								== 0)				m_iBaseAttitude									= pClassInfo->getBaseAttitude();
	if (getBasePeaceWeight()							== 0)				m_iBasePeaceWeight								= pClassInfo->getBasePeaceWeight();
	if (getPeaceWeightRand()							== 0)				m_iPeaceWeightRand								= pClassInfo->getPeaceWeightRand();
	if (getWarmongerRespect()							== 0)				m_iWarmongerRespect								= pClassInfo->getWarmongerRespect();
	if (getEspionageWeight()							== 0)				m_iEspionageWeight								= pClassInfo->getEspionageWeight();
	if (getRefuseToTalkWarThreshold()					== 0)				m_iRefuseToTalkWarThreshold						= pClassInfo->getRefuseToTalkWarThreshold();
	if (getNoTechTradeThreshold()						== 0)				m_iNoTechTradeThreshold							= pClassInfo->getNoTechTradeThreshold();
	if (getTechTradeKnownPercent()						== 0)				m_iTechTradeKnownPercent						= pClassInfo->getTechTradeKnownPercent();
	if (getMaxGoldTradePercent()						== 0)				m_iMaxGoldTradePercent							= pClassInfo->getMaxGoldTradePercent();
	if (getMaxGoldPerTurnTradePercent()					== 0)				m_iMaxGoldPerTurnTradePercent					= pClassInfo->getMaxGoldPerTurnTradePercent();
	if (getMaxWarRand()									== 50)				m_iMaxWarRand									= pClassInfo->getMaxWarRand();
	if (getMaxWarNearbyPowerRatio()						== 0)				m_iMaxWarNearbyPowerRatio						= pClassInfo->getMaxWarNearbyPowerRatio();
	if (getMaxWarDistantPowerRatio()					== 0)				m_iMaxWarDistantPowerRatio						= pClassInfo->getMaxWarDistantPowerRatio();
	if (getMaxWarMinAdjacentLandPercent()				== 0)				m_iMaxWarMinAdjacentLandPercent					= pClassInfo->getMaxWarMinAdjacentLandPercent();
	if (getLimitedWarRand()								== 0)				m_iLimitedWarRand								= pClassInfo->getLimitedWarRand();
	if (getLimitedWarPowerRatio()						== 0)				m_iLimitedWarPowerRatio							= pClassInfo->getLimitedWarPowerRatio();
	if (getDogpileWarRand()								== 0)				m_iDogpileWarRand								= pClassInfo->getDogpileWarRand();
	if (getMakePeaceRand()								== 0)				m_iMakePeaceRand								= pClassInfo->getMakePeaceRand();
	if (getDeclareWarTradeRand()						== 0)				m_iDeclareWarTradeRand							= pClassInfo->getDeclareWarTradeRand();
	if (getDemandRebukedSneakProb()						== 0)				m_iDemandRebukedSneakProb						= pClassInfo->getDemandRebukedSneakProb();
	if (getDemandRebukedWarProb()						== 0)				m_iDemandRebukedWarProb							= pClassInfo->getDemandRebukedWarProb();
	if (getRazeCityProb()								== 0)				m_iRazeCityProb									= pClassInfo->getRazeCityProb();
	if (getBuildUnitProb()								== 25)				m_iBuildUnitProb								= pClassInfo->getBuildUnitProb();
	if (getBaseAttackOddsChange()						== 0)				m_iBaseAttackOddsChange							= pClassInfo->getBaseAttackOddsChange();
	if (getAttackOddsChangeRand()						== 0)				m_iAttackOddsChangeRand							= pClassInfo->getAttackOddsChangeRand();
	if (getWorseRankDifferenceAttitudeChange()			== 0)				m_iWorseRankDifferenceAttitudeChange			= pClassInfo->getWorseRankDifferenceAttitudeChange();
	if (getBetterRankDifferenceAttitudeChange()			== 0)				m_iBetterRankDifferenceAttitudeChange			= pClassInfo->getBetterRankDifferenceAttitudeChange();
	if (getCloseBordersAttitudeChange()					== 0)				m_iCloseBordersAttitudeChange					= pClassInfo->getCloseBordersAttitudeChange();
	if (getLostWarAttitudeChange()						== 0)				m_iLostWarAttitudeChange						= pClassInfo->getLostWarAttitudeChange();
	if (getAtWarAttitudeDivisor()						== 10)				m_iAtWarAttitudeDivisor							= pClassInfo->getAtWarAttitudeDivisor();
	if (getAtWarAttitudeChangeLimit()					== 0)				m_iAtWarAttitudeChangeLimit						= pClassInfo->getAtWarAttitudeChangeLimit();
	if (getAtPeaceAttitudeDivisor()						== 50)				m_iAtPeaceAttitudeDivisor						= pClassInfo->getAtPeaceAttitudeDivisor();
	if (getAtPeaceAttitudeChangeLimit()					== 5)				m_iAtPeaceAttitudeChangeLimit					= pClassInfo->getAtPeaceAttitudeChangeLimit();
	if (getSameReligionAttitudeChange()					== 0)				m_iSameReligionAttitudeChange					= pClassInfo->getSameReligionAttitudeChange();
	if (getSameReligionAttitudeDivisor()				== 30)				m_iSameReligionAttitudeDivisor					= pClassInfo->getSameReligionAttitudeDivisor();
	if (getSameReligionAttitudeChangeLimit()			== 5)				m_iSameReligionAttitudeChangeLimit				= pClassInfo->getSameReligionAttitudeChangeLimit();
	if (getDifferentReligionAttitudeChange()			== 0)				m_iDifferentReligionAttitudeChange				= pClassInfo->getDifferentReligionAttitudeChange();
	if (getDifferentReligionAttitudeDivisor()			== -30)				m_iDifferentReligionAttitudeDivisor				= pClassInfo->getDifferentReligionAttitudeDivisor();
	if (getDifferentReligionAttitudeChangeLimit()		== -5)				m_iDifferentReligionAttitudeChangeLimit			= pClassInfo->getDifferentReligionAttitudeChangeLimit();
	if (getBonusTradeAttitudeDivisor()					== 30)				m_iBonusTradeAttitudeDivisor					= pClassInfo->getBonusTradeAttitudeDivisor();
	if (getBonusTradeAttitudeChangeLimit()				== 1)				m_iBonusTradeAttitudeChangeLimit				= pClassInfo->getBonusTradeAttitudeChangeLimit();
	if (getOpenBordersAttitudeDivisor()					== 30)				m_iOpenBordersAttitudeDivisor					= pClassInfo->getOpenBordersAttitudeDivisor();
	if (getOpenBordersAttitudeChangeLimit()				== 1)				m_iOpenBordersAttitudeChangeLimit				= pClassInfo->getOpenBordersAttitudeChangeLimit();
	if (getDefensivePactAttitudeDivisor()				== 50)				m_iDefensivePactAttitudeDivisor					= pClassInfo->getDefensivePactAttitudeDivisor();
	if (getDefensivePactAttitudeChangeLimit()			== 2)				m_iDefensivePactAttitudeChangeLimit				= pClassInfo->getDefensivePactAttitudeChangeLimit();
	if (getShareWarAttitudeChange()						== 2)				m_iShareWarAttitudeChange						= pClassInfo->getShareWarAttitudeChange();
	if (getShareWarAttitudeDivisor()					== 10)				m_iShareWarAttitudeDivisor						= pClassInfo->getShareWarAttitudeDivisor();
	if (getShareWarAttitudeChangeLimit()				== 2)				m_iShareWarAttitudeChangeLimit					= pClassInfo->getShareWarAttitudeChangeLimit();
	if (getFavoriteCivicAttitudeChange()				== 2)				m_iFavoriteCivicAttitudeChange					= pClassInfo->getFavoriteCivicAttitudeChange();
	if (getFavoriteCivicAttitudeDivisor()				== 30)				m_iFavoriteCivicAttitudeDivisor					= pClassInfo->getFavoriteCivicAttitudeDivisor();
	if (getFavoriteCivicAttitudeChangeLimit()			== 2)				m_iFavoriteCivicAttitudeChangeLimit				= pClassInfo->getFavoriteCivicAttitudeChangeLimit();
	if (getVassalPowerModifier()						== 0)				m_iVassalPowerModifier							= pClassInfo->getVassalPowerModifier();
	if (getFreedomAppreciation()						== 0)				m_iFreedomAppreciation							= pClassInfo->getFreedomAppreciation();
	if (getAttitudeBadBonus()							== 0)				m_iAttitudeBadBonus								= pClassInfo->getAttitudeBadBonus();
	if (getAttitudeFromFemales()						== 0)				m_iAttitudeFromFemales							= pClassInfo->getAttitudeFromFemales();
	if (getAttitudeFromMales()							== 0)				m_iAttitudeFromMales							= pClassInfo->getAttitudeFromMales();
	if (getAttitudeToFemales()							== 0)				m_iAttitudeToFemales							= pClassInfo->getAttitudeToFemales();
	if (getAttitudeToMales()							== 0)				m_iAttitudeToMales								= pClassInfo->getAttitudeToMales();
	if (getSomniumAggressiveness()						== 0)				m_iSomniumAggressiveness						= pClassInfo->getSomniumAggressiveness();
	if (getPermanentTrait()								== NO_TRAIT)		m_iPermanentTrait								= pClassInfo->getPermanentTrait();
	if (getFavoriteTech()								== NO_TECH)			m_iFavoriteTech									= pClassInfo->getFavoriteTech();
	if (getFavoriteCivic()								== NO_CIVIC)		m_iFavoriteCivic								= pClassInfo->getFavoriteCivic();
	if (getFavoriteWonder()								== NO_BUILDING)		m_iFavoriteWonder								= pClassInfo->getFavoriteWonder();
	if (getDemandTributeAttitudeThreshold()				== NO_ATTITUDE)		m_iDemandTributeAttitudeThreshold				= pClassInfo->getDemandTributeAttitudeThreshold();
	if (getNoGiveHelpAttitudeThreshold()				== NO_ATTITUDE)		m_iNoGiveHelpAttitudeThreshold					= pClassInfo->getNoGiveHelpAttitudeThreshold();
	if (getTechRefuseAttitudeThreshold()				== NO_ATTITUDE)		m_iTechRefuseAttitudeThreshold					= pClassInfo->getTechRefuseAttitudeThreshold();
	if (getStrategicBonusRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iStrategicBonusRefuseAttitudeThreshold		= pClassInfo->getStrategicBonusRefuseAttitudeThreshold();
	if (getHappinessBonusRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iHappinessBonusRefuseAttitudeThreshold		= pClassInfo->getHappinessBonusRefuseAttitudeThreshold();
	if (getHealthBonusRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iHealthBonusRefuseAttitudeThreshold			= pClassInfo->getHealthBonusRefuseAttitudeThreshold();
	if (getMapRefuseAttitudeThreshold()					== NO_ATTITUDE)		m_iMapRefuseAttitudeThreshold					= pClassInfo->getMapRefuseAttitudeThreshold();
	if (getDeclareWarRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iDeclareWarRefuseAttitudeThreshold			= pClassInfo->getDeclareWarRefuseAttitudeThreshold();
	if (getDeclareWarThemRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iDeclareWarThemRefuseAttitudeThreshold		= pClassInfo->getDeclareWarThemRefuseAttitudeThreshold();
	if (getStopTradingRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iStopTradingRefuseAttitudeThreshold			= pClassInfo->getStopTradingRefuseAttitudeThreshold();
	if (getStopTradingThemRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iStopTradingThemRefuseAttitudeThreshold		= pClassInfo->getStopTradingThemRefuseAttitudeThreshold();
	if (getAdoptCivicRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iAdoptCivicRefuseAttitudeThreshold			= pClassInfo->getAdoptCivicRefuseAttitudeThreshold();
	if (getConvertReligionRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iConvertReligionRefuseAttitudeThreshold		= pClassInfo->getConvertReligionRefuseAttitudeThreshold();
	if (getOpenBordersRefuseAttitudeThreshold()			== NO_ATTITUDE)		m_iOpenBordersRefuseAttitudeThreshold			= pClassInfo->getOpenBordersRefuseAttitudeThreshold();
	if (getDefensivePactRefuseAttitudeThreshold()		== NO_ATTITUDE)		m_iDefensivePactRefuseAttitudeThreshold			= pClassInfo->getDefensivePactRefuseAttitudeThreshold();
	if (getPermanentAllianceRefuseAttitudeThreshold()	== NO_ATTITUDE)		m_iPermanentAllianceRefuseAttitudeThreshold		= pClassInfo->getPermanentAllianceRefuseAttitudeThreshold();
	if (getVassalRefuseAttitudeThreshold()				== NO_ATTITUDE)		m_iVassalRefuseAttitudeThreshold				= pClassInfo->getVassalRefuseAttitudeThreshold();
	if (getFavoriteReligion()							== NO_RELIGION)		m_iFavoriteReligion								= pClassInfo->getFavoriteReligion();
	if (getAlignment()									== NO_ALIGNMENT)	m_iAlignment									= pClassInfo->getAlignment();
	if (getFavoriteUnitCombat()							== NO_UNITCOMBAT)	m_iFavoriteUnitCombat							= pClassInfo->getFavoriteUnitCombat();
	for (int j = 0; j < GC.getNumTraitInfos(); j++)
	{
		if (hasTrait(j)									== false)			m_pbTraits[j]									= pClassInfo->hasTrait(j);
	}
	for (int j = 0; j < GC.getNumFlavorTypes(); j++)
	{
		if (getFlavorValue(j)							== 0)				m_piFlavorValue[j]								= pClassInfo->getFlavorValue(j);
	}
	for (int j = 0; j < NUM_CONTACT_TYPES; j++)
	{
		if (getContactRand(j)							== 0)				m_piContactRand[j]								= pClassInfo->getContactRand(j);
		if (getContactDelay(j)							== 0)				m_piContactDelay[j]								= pClassInfo->getContactDelay(j);
	}
	for (int j = 0; j < NUM_MEMORY_TYPES; j++)
	{
		if (getMemoryDecayRand(j)						== 0)				m_piMemoryDecayRand[j]							= pClassInfo->getMemoryDecayRand(j);
		if (getMemoryAttitudePercent(j)					== 0)				m_piMemoryAttitudePercent[j]					= pClassInfo->getMemoryAttitudePercent(j);
	}
	for (int j = 0; j < NUM_ATTITUDE_TYPES; j++)
	{
		if (getNoWarAttitudeProb(j)						== 0)				m_piNoWarAttitudeProb[j]						= pClassInfo->getNoWarAttitudeProb(j);
	}
	for (int j = 0; j < NUM_UNITAI_TYPES; j++)
	{
		if (getUnitAIWeightModifier(j)					== 0)				m_piUnitAIWeightModifier[j]						= pClassInfo->getUnitAIWeightModifier(j);
	}
	for (int j = 0; j < GC.getNumImprovementInfos(); j++)
	{
		if (getImprovementWeightModifier(j)				== 0)				m_piImprovementWeightModifier[j]				= pClassInfo->getImprovementWeightModifier(j);
	}
	for (int j = 0; j < GC.getNumEraInfos(); j++)
	{
		if (getDiploPeaceIntroMusicScriptIds(j)			== -1)				m_piDiploPeaceIntroMusicScriptIds[j]			= pClassInfo->getDiploPeaceIntroMusicScriptIds(j);
		if (getDiploPeaceMusicScriptIds(j)				== -1)				m_piDiploPeaceMusicScriptIds[j]					= pClassInfo->getDiploPeaceMusicScriptIds(j);
		if (getDiploWarIntroMusicScriptIds(j)			== -1)				m_piDiploWarIntroMusicScriptIds[j]				= pClassInfo->getDiploWarIntroMusicScriptIds(j);
		if (getDiploWarMusicScriptIds(j)				== -1)				m_piDiploWarMusicScriptIds[j]					= pClassInfo->getDiploWarMusicScriptIds(j);
	}
	for (int j = 0; j < GC.getNumReligionInfos(); j++)
	{
		if (getReligionWeightModifier(j)				== 0)				m_piReligionWeightModifier[j]			= pClassInfo->getReligionWeightModifier(j);
	}

    if (isAltarVictory()              == false)           m_bAltarVictory       = pClassInfo->isAltarVictory();
    if (isArcaneTowerVictory()              == false)           m_bArcaneTowerVictory       = pClassInfo->isArcaneTowerVictory();
    if (isCultureVictory()              == false)           m_bCultureVictory       = pClassInfo->isCultureVictory();
    if (isReligionVictory()              == false)           m_bReligionVictory       = pClassInfo->isReligionVictory();
    if (isReligionOpportunist()             == false)           m_bReligionOpportunist      = pClassInfo->isReligionOpportunist();
    if (getAIPatrolGroupSize()              == 100)             m_iAIPatrolGroupSize        = pClassInfo->getAIPatrolGroupSize();
    if (getAIPatrolGroupMage()              == 100)             m_iAIPatrolGroupMage        = pClassInfo->getAIPatrolGroupMage();
    if (getAIValueDefense()                 == 100)             m_iAIValueDefense           = pClassInfo->getAIValueDefense();
    if (getAIValueMage()                    == 100)             m_iAIValueMage              = pClassInfo->getAIValueMage();
    if (getEconomyTechValue()               == 100)             m_iEconomyTechValue         = pClassInfo->getEconomyTechValue();
    if (getFavoriteEarlyReligion()          == NO_RELIGION)     m_iFavoriteEarlyReligion    = pClassInfo->getFavoriteEarlyReligion();
    if (getFavoriteEarlyMilTech()           == NO_TECH)         m_iFavoriteEarlyMilTech     = pClassInfo->getFavoriteEarlyMilTech();
    if (getFavoriteEarlyTech1()             == NO_TECH)         m_iFavoriteEarlyTech1       = pClassInfo->getFavoriteEarlyTech1();
    if (getFavoriteEarlyTech2()             == NO_TECH)         m_iFavoriteEarlyTech2       = pClassInfo->getFavoriteEarlyTech2();
    if (getFavoriteEarlyTech3()             == NO_TECH)         m_iFavoriteEarlyTech3       = pClassInfo->getFavoriteEarlyTech3();
    if (getFavoriteEarlyWonder()            == NO_BUILDINGCLASS)m_iFavoriteEarlyWonder      = pClassInfo->getFavoriteEarlyWonder();
    if (getFavoriteLateWonder()             == NO_BUILDINGCLASS)m_iFavoriteLateWonder       = pClassInfo->getFavoriteLateWonder();
    if (getHatedCivicAttitudeChange()       == 0)               m_iHatedCivicAttitudeChange = pClassInfo->getHatedCivicAttitudeChange();
    if (getHatedCivicAttitudeDivisor()      == 0)               m_iHatedCivicAttitudeDivisor= pClassInfo->getHatedCivicAttitudeDivisor();
    if (getHatedCivicAttitudeChangeLimit()  == 0)               m_iHatedCivicAttitudeChangeLimit  = pClassInfo->getHatedCivicAttitudeChangeLimit();
    if (getHatedCivic()                     == NO_CIVIC)        m_iHatedCivic               = pClassInfo->getHatedCivic();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvWorldInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvWorldInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvWorldInfo::CvWorldInfo() :
m_iDefaultPlayers(0),
m_iUnitNameModifier(0),
m_iTargetNumCities(0),
m_iNumFreeBuildingBonuses(0),
m_iBuildingClassPrereqModifier(0),
m_iMaxConscriptModifier(0),
m_iWarWearinessModifier(0),
m_iGridWidth(0),
m_iGridHeight(0),
m_iTerrainGrainChange(0),
m_iFeatureGrainChange(0),
m_iResearchPercent(0),
m_iTradeProfitPercent(0),
m_iDistanceMaintenancePercent(0),
m_iNumCitiesMaintenancePercent(0),
m_iColonyMaintenancePercent(0),
m_iCorporationMaintenancePercent(0),
m_iNumCitiesAnarchyPercent(0),
m_iAdvancedStartPointsMod(0),

//FfH: Added by Kael 10/01/2007
m_iMaxCitiesMod(0),
m_iUniqueFeatureChance(0)
//FfH: End Add
/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
,m_iAISettlerMove(0)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvWorldInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvWorldInfo::~CvWorldInfo()
{
}

int CvWorldInfo::getDefaultPlayers() const
{
	return m_iDefaultPlayers;
}

int CvWorldInfo::getUnitNameModifier() const
{
	return m_iUnitNameModifier;
}

int CvWorldInfo::getTargetNumCities() const
{
	return m_iTargetNumCities;
}

int CvWorldInfo::getNumFreeBuildingBonuses() const
{
	return m_iNumFreeBuildingBonuses;
}

int CvWorldInfo::getBuildingClassPrereqModifier() const
{
	return m_iBuildingClassPrereqModifier;
}

int CvWorldInfo::getMaxConscriptModifier() const
{
	return m_iMaxConscriptModifier;
}

int CvWorldInfo::getWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

int CvWorldInfo::getGridWidth() const
{
	return m_iGridWidth;
}

int CvWorldInfo::getGridHeight() const
{
	return m_iGridHeight;
}

int CvWorldInfo::getTerrainGrainChange() const
{
	return m_iTerrainGrainChange;
}

int CvWorldInfo::getFeatureGrainChange() const
{
	return m_iFeatureGrainChange;
}

int CvWorldInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvWorldInfo::getTradeProfitPercent() const
{
	return m_iTradeProfitPercent;
}

int CvWorldInfo::getDistanceMaintenancePercent() const
{
	return m_iDistanceMaintenancePercent;
}

int CvWorldInfo::getNumCitiesMaintenancePercent() const
{
	return m_iNumCitiesMaintenancePercent;
}

int CvWorldInfo::getColonyMaintenancePercent() const
{
	return m_iColonyMaintenancePercent;
}

int CvWorldInfo::getCorporationMaintenancePercent() const
{
	return m_iCorporationMaintenancePercent;
}

int CvWorldInfo::getNumCitiesAnarchyPercent() const
{
	return m_iNumCitiesAnarchyPercent;
}

int CvWorldInfo::getAdvancedStartPointsMod() const
{
	return m_iAdvancedStartPointsMod;
}

//FfH: Added by Kael 10/01/2007
int CvWorldInfo::getMaxCitiesMod() const
{
	return m_iMaxCitiesMod;
}

int CvWorldInfo::getUniqueFeatureChance() const
{
	return m_iUniqueFeatureChance;
}
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvWorldInfo::getAISettlerMove() const
{
    return m_iAISettlerMove;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

bool CvWorldInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iDefaultPlayers, "iDefaultPlayers");
	pXML->GetChildXmlValByName(&m_iUnitNameModifier, "iUnitNameModifier");
	pXML->GetChildXmlValByName(&m_iTargetNumCities, "iTargetNumCities");
	pXML->GetChildXmlValByName(&m_iNumFreeBuildingBonuses, "iNumFreeBuildingBonuses");
	pXML->GetChildXmlValByName(&m_iBuildingClassPrereqModifier, "iBuildingClassPrereqModifier");
	pXML->GetChildXmlValByName(&m_iMaxConscriptModifier, "iMaxConscriptModifier");
//	pXML->GetChildXmlValByName(&m_iWarWearinessModifier, "iWarWearinessModifier");	No WarWeariness
	pXML->GetChildXmlValByName(&m_iGridWidth, "iGridWidth");
	pXML->GetChildXmlValByName(&m_iGridHeight, "iGridHeight");
	pXML->GetChildXmlValByName(&m_iTerrainGrainChange, "iTerrainGrainChange");
	pXML->GetChildXmlValByName(&m_iFeatureGrainChange, "iFeatureGrainChange");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iTradeProfitPercent, "iTradeProfitPercent");
	pXML->GetChildXmlValByName(&m_iDistanceMaintenancePercent, "iDistanceMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iNumCitiesMaintenancePercent, "iNumCitiesMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iColonyMaintenancePercent, "iColonyMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iCorporationMaintenancePercent, "iCorporationMaintenancePercent");
	pXML->GetChildXmlValByName(&m_iNumCitiesAnarchyPercent, "iNumCitiesAnarchyPercent");
	pXML->GetChildXmlValByName(&m_iAdvancedStartPointsMod, "iAdvancedStartPointsMod");

//FfH: Added by Kael 10/01/2007
	pXML->GetChildXmlValByName(&m_iMaxCitiesMod, "iMaxCitiesMod");
	pXML->GetChildXmlValByName(&m_iUniqueFeatureChance, "iUniqueFeatureChance");
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    pXML->GetChildXmlValByName(&m_iAISettlerMove, "iAISettlerMove");
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvWorldInfo::copyNonDefaults(CvWorldInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefaultPlayers()					== 0)	m_iDefaultPlayers					= pClassInfo->getDefaultPlayers();
	if (getUnitNameModifier()				== 0)	m_iUnitNameModifier					= pClassInfo->getUnitNameModifier();
	if (getTargetNumCities()				== 0)	m_iTargetNumCities					= pClassInfo->getTargetNumCities();
	if (getNumFreeBuildingBonuses()			== 0)	m_iNumFreeBuildingBonuses			= pClassInfo->getNumFreeBuildingBonuses();
	if (getBuildingClassPrereqModifier()	== 0)	m_iBuildingClassPrereqModifier		= pClassInfo->getBuildingClassPrereqModifier();
	if (getMaxConscriptModifier()			== 0)	m_iMaxConscriptModifier				= pClassInfo->getMaxConscriptModifier();
	if (getWarWearinessModifier()			== 0)	m_iWarWearinessModifier				= pClassInfo->getWarWearinessModifier();
	if (getGridWidth()						== 0)	m_iGridWidth						= pClassInfo->getGridWidth();
	if (getGridHeight()						== 0)	m_iGridHeight						= pClassInfo->getGridHeight();
	if (getTerrainGrainChange()				== 0)	m_iTerrainGrainChange				= pClassInfo->getTerrainGrainChange();
	if (getFeatureGrainChange()				== 0)	m_iFeatureGrainChange				= pClassInfo->getFeatureGrainChange();
	if (getResearchPercent()				== 0)	m_iResearchPercent					= pClassInfo->getResearchPercent();
	if (getTradeProfitPercent()				== 0)	m_iTradeProfitPercent				= pClassInfo->getTradeProfitPercent();
	if (getDistanceMaintenancePercent()		== 0)	m_iDistanceMaintenancePercent		= pClassInfo->getDistanceMaintenancePercent();
	if (getNumCitiesMaintenancePercent()	== 0)	m_iNumCitiesMaintenancePercent		= pClassInfo->getNumCitiesMaintenancePercent();
	if (getColonyMaintenancePercent()		== 0)	m_iColonyMaintenancePercent			= pClassInfo->getColonyMaintenancePercent();
	if (getCorporationMaintenancePercent()	== 0)	m_iCorporationMaintenancePercent	= pClassInfo->getCorporationMaintenancePercent();
	if (getNumCitiesAnarchyPercent()		== 0)	m_iNumCitiesAnarchyPercent			= pClassInfo->getNumCitiesAnarchyPercent();
	if (getAdvancedStartPointsMod()			== 0)	m_iAdvancedStartPointsMod			= pClassInfo->getAdvancedStartPointsMod();
	if (getMaxCitiesMod()					== 0)	m_iMaxCitiesMod						= pClassInfo->getMaxCitiesMod();
	if (getUniqueFeatureChance()			== 0)	m_iUniqueFeatureChance				= pClassInfo->getUniqueFeatureChance();
/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    if (getAISettlerMove() == 0) m_iAISettlerMove = pClassInfo->getAISettlerMove();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvClimateInfo
//======================================================================================================
CvClimateInfo::CvClimateInfo() :
m_iDesertPercentChange(0),
m_iJungleLatitude(0),
m_iHillRange(0),
m_iPeakPercent(0),
m_fSnowLatitudeChange(0.0f),
m_fTundraLatitudeChange(0.0f),
m_fGrassLatitudeChange(0.0f),
m_fDesertBottomLatitudeChange(0.0f),
m_fDesertTopLatitudeChange(0.0f),
m_fIceLatitude(0.0f),
m_fRandIceLatitude(0.0f)
{
}

CvClimateInfo::~CvClimateInfo()
{
}

int CvClimateInfo::getDesertPercentChange() const
{
	return m_iDesertPercentChange;
}

int CvClimateInfo::getJungleLatitude() const
{
	return m_iJungleLatitude;
}

int CvClimateInfo::getHillRange() const
{
	return m_iHillRange;
}

int CvClimateInfo::getPeakPercent() const
{
	return m_iPeakPercent;
}

float CvClimateInfo::getSnowLatitudeChange() const
{
	return m_fSnowLatitudeChange;
}

float CvClimateInfo::getTundraLatitudeChange() const
{
	return m_fTundraLatitudeChange;
}

float CvClimateInfo::getGrassLatitudeChange() const
{
	return m_fGrassLatitudeChange;
}

float CvClimateInfo::getDesertBottomLatitudeChange() const
{
	return m_fDesertBottomLatitudeChange;
}

float CvClimateInfo::getDesertTopLatitudeChange() const
{
	return m_fDesertTopLatitudeChange;
}

float CvClimateInfo::getIceLatitude() const
{
	return m_fIceLatitude;
}

float CvClimateInfo::getRandIceLatitude() const
{
	return m_fRandIceLatitude;
}

bool CvClimateInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iDesertPercentChange, "iDesertPercentChange");
	pXML->GetChildXmlValByName(&m_iJungleLatitude, "iJungleLatitude");
	pXML->GetChildXmlValByName(&m_iHillRange, "iHillRange");
	pXML->GetChildXmlValByName(&m_iPeakPercent, "iPeakPercent");

	pXML->GetChildXmlValByName(&m_fSnowLatitudeChange, "fSnowLatitudeChange");
	pXML->GetChildXmlValByName(&m_fTundraLatitudeChange, "fTundraLatitudeChange");
	pXML->GetChildXmlValByName(&m_fGrassLatitudeChange, "fGrassLatitudeChange");
	pXML->GetChildXmlValByName(&m_fDesertBottomLatitudeChange, "fDesertBottomLatitudeChange");
	pXML->GetChildXmlValByName(&m_fDesertTopLatitudeChange, "fDesertTopLatitudeChange");
	pXML->GetChildXmlValByName(&m_fIceLatitude, "fIceLatitude");
	pXML->GetChildXmlValByName(&m_fRandIceLatitude, "fRandIceLatitude");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvClimateInfo::copyNonDefaults(CvClimateInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDesertPercentChange()			== 0)		m_iDesertPercentChange			= pClassInfo->getDesertPercentChange();
	if (getJungleLatitude()					== 0)		m_iJungleLatitude				= pClassInfo->getJungleLatitude();
	if (getHillRange()						== 0)		m_iHillRange					= pClassInfo->getHillRange();
	if (getPeakPercent()					== 0)		m_iPeakPercent					= pClassInfo->getPeakPercent();

	if (getSnowLatitudeChange()				== 0.0f)	m_fSnowLatitudeChange			= pClassInfo->getSnowLatitudeChange();
	if (getTundraLatitudeChange()			== 0.0f)	m_fTundraLatitudeChange			= pClassInfo->getTundraLatitudeChange();
	if (getGrassLatitudeChange()			== 0.0f)	m_fGrassLatitudeChange			= pClassInfo->getGrassLatitudeChange();
	if (getDesertBottomLatitudeChange()		== 0.0f)	m_fDesertBottomLatitudeChange	= pClassInfo->getDesertBottomLatitudeChange();
	if (getDesertTopLatitudeChange()		== 0.0f)	m_fDesertTopLatitudeChange		= pClassInfo->getDesertTopLatitudeChange();
	if (getIceLatitude()					== 0.0f)	m_fIceLatitude					= pClassInfo->getIceLatitude();
	if (getRandIceLatitude()				== 0.0f)	m_fRandIceLatitude				= pClassInfo->getRandIceLatitude();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSeaLevelInfo
//======================================================================================================
CvSeaLevelInfo::CvSeaLevelInfo() :
m_iSeaLevelChange(0)
{
}

CvSeaLevelInfo::~CvSeaLevelInfo()
{
}

int CvSeaLevelInfo::getSeaLevelChange() const
{
	return m_iSeaLevelChange;
}

bool CvSeaLevelInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iSeaLevelChange, "iSeaLevelChange");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSeaLevelInfo::copyNonDefaults(CvSeaLevelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getSeaLevelChange()		== 0)	m_iSeaLevelChange	= pClassInfo->getSeaLevelChange();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvProcessInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvProcessInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvProcessInfo::CvProcessInfo() :
m_iTechPrereq(NO_TECH),
m_paiProductionToCommerceModifier(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvProcessInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvProcessInfo::~CvProcessInfo()
{
	SAFE_DELETE_ARRAY(m_paiProductionToCommerceModifier);	
}

int CvProcessInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

// Arrays

int CvProcessInfo::getProductionToCommerceModifier(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiProductionToCommerceModifier ? m_paiProductionToCommerceModifier[i] : -1;
}

bool CvProcessInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ProductionToCommerceModifiers"))
	{
		pXML->SetCommerce(&m_paiProductionToCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiProductionToCommerceModifier, NUM_COMMERCE_TYPES);
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvProcessInfo::copyNonDefaults(CvProcessInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getTechPrereq()								== NO_TECH)		m_iTechPrereq							= pClassInfo->getTechPrereq();
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if (m_paiProductionToCommerceModifier[i]	== 0)			m_paiProductionToCommerceModifier[i]	= pClassInfo->getProductionToCommerceModifier(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvVoteInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvVoteInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvVoteInfo::CvVoteInfo() :
m_iPopulationThreshold(0),
m_iStateReligionVotePercent(0),
m_iTradeRoutes(0),
m_iMinVoters(0),
m_bSecretaryGeneral(false),
m_bVictory(false),
m_bFreeTrade(false),
m_bNoNukes(false),
m_bCityVoting(false),
m_bCivVoting(false),
m_bDefensivePact(false),
m_bOpenBorders(false),
m_bForcePeace(false),
m_bForceNoTrade(false),
m_bForceWar(false),
m_bAssignCity(false),
m_pbForceCivic(NULL),
m_abVoteSourceTypes(NULL),

//FfH: Added by Kael 11/14/2007
m_bGamblingRing(false),
m_bNoOutsideTechTrades(false),
m_bSlaveTrade(false),
m_bSmugglingRing(false),
m_iCost(0),
m_iCrime(0),
m_iFreeUnits(0),
m_iFreeUnitClass(NO_UNITCLASS),
m_iNoBonus(NO_BONUS)
//FfH: End Add

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvVoteInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvVoteInfo::~CvVoteInfo()
{
	SAFE_DELETE_ARRAY(m_pbForceCivic);
	SAFE_DELETE_ARRAY(m_abVoteSourceTypes);
}

int CvVoteInfo::getPopulationThreshold() const
{
	return m_iPopulationThreshold;
}

int CvVoteInfo::getStateReligionVotePercent() const
{
	return m_iStateReligionVotePercent;
}

int CvVoteInfo::getTradeRoutes() const
{
	return m_iTradeRoutes;
}

int CvVoteInfo::getMinVoters() const
{
	return m_iMinVoters;
}

bool CvVoteInfo::isSecretaryGeneral() const
{
	return m_bSecretaryGeneral;
}

bool CvVoteInfo::isVictory() const
{
	return m_bVictory;
}

bool CvVoteInfo::isFreeTrade() const
{
	return m_bFreeTrade;
}

bool CvVoteInfo::isNoNukes() const
{
	return m_bNoNukes;
}

bool CvVoteInfo::isCityVoting() const
{
	return m_bCityVoting;
}

bool CvVoteInfo::isCivVoting() const
{
	return m_bCivVoting;
}

bool CvVoteInfo::isDefensivePact() const
{
	return m_bDefensivePact;
}

bool CvVoteInfo::isOpenBorders() const
{
	return m_bOpenBorders;
}

bool CvVoteInfo::isForcePeace() const
{
	return m_bForcePeace;
}

bool CvVoteInfo::isForceNoTrade() const
{
	return m_bForceNoTrade;
}

bool CvVoteInfo::isForceWar() const
{
	return m_bForceWar;
}

bool CvVoteInfo::isAssignCity() const
{
	return m_bAssignCity;
}

//FfH: Added by Kael 11/14/2007
bool CvVoteInfo::isGamblingRing() const
{
	return m_bGamblingRing;
}

bool CvVoteInfo::isNoOutsideTechTrades() const
{
	return m_bNoOutsideTechTrades;
}

bool CvVoteInfo::isSlaveTrade() const
{
	return m_bSlaveTrade;
}

bool CvVoteInfo::isSmugglingRing() const
{
	return m_bSmugglingRing;
}

int CvVoteInfo::getCost() const
{
	return m_iCost;
}

int CvVoteInfo::getCrime() const
{
	return m_iCrime;
}

int CvVoteInfo::getFreeUnitClass() const
{
	return m_iFreeUnitClass;
}

int CvVoteInfo::getFreeUnits() const
{
	return m_iFreeUnits;
}

int CvVoteInfo::getNoBonus() const
{
	return m_iNoBonus;
}

const TCHAR *CvVoteInfo::getPyResult() const
{
	return m_szPyResult;
}
//FfH: End Add

bool CvVoteInfo::isForceCivic(int i) const
{
	FAssertMsg(i < GC.getNumCivicInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pbForceCivic ? m_pbForceCivic[i] : false;
}

bool CvVoteInfo::isVoteSourceType(int i) const
{
	FAssertMsg(i < GC.getNumVoteSourceInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_abVoteSourceTypes ? m_abVoteSourceTypes[i] : false;
}

bool CvVoteInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iPopulationThreshold, "iPopulationThreshold");
	pXML->GetChildXmlValByName(&m_iStateReligionVotePercent, "iStateReligionVotePercent");
	pXML->GetChildXmlValByName(&m_iTradeRoutes, "iTradeRoutes");
	pXML->GetChildXmlValByName(&m_iMinVoters, "iMinVoters");

	pXML->GetChildXmlValByName(&m_bSecretaryGeneral, "bSecretaryGeneral");
	pXML->GetChildXmlValByName(&m_bVictory, "bVictory");
	pXML->GetChildXmlValByName(&m_bFreeTrade, "bFreeTrade");
	pXML->GetChildXmlValByName(&m_bNoNukes, "bNoNukes");
	pXML->GetChildXmlValByName(&m_bCityVoting, "bCityVoting");
	pXML->GetChildXmlValByName(&m_bCivVoting, "bCivVoting");
	pXML->GetChildXmlValByName(&m_bDefensivePact, "bDefensivePact");
	pXML->GetChildXmlValByName(&m_bOpenBorders, "bOpenBorders");
	pXML->GetChildXmlValByName(&m_bForcePeace, "bForcePeace");
	pXML->GetChildXmlValByName(&m_bForceNoTrade, "bForceNoTrade");
	pXML->GetChildXmlValByName(&m_bForceWar, "bForceWar");
	pXML->GetChildXmlValByName(&m_bAssignCity, "bAssignCity");

	pXML->SetVariableListTagPair(&m_pbForceCivic, "ForceCivics", sizeof(GC.getCivicInfo((CivicTypes)0)), GC.getNumCivicInfos());
	pXML->SetVariableListTagPair(&m_abVoteSourceTypes, "DiploVotes", sizeof(GC.getVoteSourceInfo((VoteSourceTypes)0)), GC.getNumVoteSourceInfos());

//FfH: Added by Kael 11/14/2007
	CvString szTextVal;
	pXML->GetChildXmlValByName(&m_bGamblingRing, "bGamblingRing");
	pXML->GetChildXmlValByName(&m_bNoOutsideTechTrades, "bNoOutsideTechTrades");
	pXML->GetChildXmlValByName(&m_bSlaveTrade, "bSlaveTrade");
	pXML->GetChildXmlValByName(&m_bSmugglingRing, "bSmugglingRing");
	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_iCrime, "iCrime");
	pXML->GetChildXmlValByName(&m_iFreeUnits, "iFreeUnits");
	pXML->GetChildXmlValByName(szTextVal, "FreeUnitClass");
	m_iFreeUnitClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "NoBonus");
	m_iNoBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(m_szPyResult, "PyResult");
//FfH: End Add

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvVoteInfo::copyNonDefaults(CvVoteInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isSecretaryGeneral()			== false)			m_bSecretaryGeneral				= pClassInfo->isSecretaryGeneral();
	if (isVictory()						== false)			m_bVictory						= pClassInfo->isVictory();
	if (isFreeTrade()					== false)			m_bFreeTrade					= pClassInfo->isFreeTrade();
	if (isNoNukes()						== false)			m_bNoNukes						= pClassInfo->isNoNukes();
	if (isCityVoting()					== false)			m_bCityVoting					= pClassInfo->isCityVoting();
	if (isCivVoting()					== false)			m_bCivVoting					= pClassInfo->isCivVoting();
	if (isDefensivePact()				== false)			m_bDefensivePact				= pClassInfo->isDefensivePact();
	if (isOpenBorders()					== false)			m_bOpenBorders					= pClassInfo->isOpenBorders();
	if (isForcePeace()					== false)			m_bForcePeace					= pClassInfo->isForcePeace();
	if (isForceNoTrade()				== false)			m_bForceNoTrade					= pClassInfo->isForceNoTrade();
	if (isForceWar()					== false)			m_bForceWar						= pClassInfo->isForceWar();
	if (isAssignCity()					== false)			m_bAssignCity					= pClassInfo->isAssignCity();
	if (isGamblingRing()				== false)			m_bGamblingRing					= pClassInfo->isGamblingRing();
	if (isNoOutsideTechTrades()			== false)			m_bNoOutsideTechTrades			= pClassInfo->isNoOutsideTechTrades();
	if (isSlaveTrade()					== false)			m_bSlaveTrade					= pClassInfo->isSlaveTrade();
	if (isSmugglingRing()				== false)			m_bSmugglingRing				= pClassInfo->isSmugglingRing();
	if (getPopulationThreshold()		== 0)				m_iPopulationThreshold			= pClassInfo->getPopulationThreshold();
	if (getStateReligionVotePercent()	== 0)				m_iStateReligionVotePercent		= pClassInfo->getStateReligionVotePercent();
	if (getTradeRoutes()				== 0)				m_iTradeRoutes					= pClassInfo->getTradeRoutes();
	if (getMinVoters()					== 0)				m_iMinVoters					= pClassInfo->getMinVoters();
	if (getCost()						== 0)				m_iCost							= pClassInfo->getCost();
	if (getCrime()						== 0)				m_iCrime						= pClassInfo->getCrime();
	if (getFreeUnits()					== 0)				m_iFreeUnits					= pClassInfo->getFreeUnits();
	if (getPyResult()					== cDefault)		m_szPyResult					= pClassInfo->getPyResult();
	if (getNoBonus()					== NO_BONUS)		m_iNoBonus						= pClassInfo->getNoBonus();
	if (getFreeUnitClass()				== NO_UNITCLASS)	m_iFreeUnitClass				= pClassInfo->getFreeUnitClass();
	for ( int i = 0; i < GC.getNumCivicInfos(); i++ )
	{
		if (isForceCivic(i)				== false)	m_pbForceCivic[i]				= pClassInfo->isForceCivic(i);
	}

	for ( int i = 0; i < GC.getNumVoteSourceInfos(); i++ )
	{
		if (isVoteSourceType(i)			== false)	m_abVoteSourceTypes[i]			= pClassInfo->isVoteSourceType(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvProjectInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvProjectInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvProjectInfo::CvProjectInfo() :
m_iVictoryPrereq(NO_VICTORY),
m_iTechPrereq(NO_TECH),
m_iAnyoneProjectPrereq(NO_PROJECT),
m_iProjectPrereq(NO_PROJECT),
m_iMaxGlobalInstances(0),
m_iMaxTeamInstances(0),
m_iProductionCost(0),
m_iNukeInterception(0),
m_iTechShare(0),
m_iEveryoneSpecialUnit(NO_SPECIALUNIT),
m_iEveryoneSpecialBuilding(NO_SPECIALBUILDING),
m_iVictoryDelayPercent(0),
m_iSuccessRate(0),
m_bSpaceship(false),
m_bAllowsNukes(false),
m_piBonusProductionModifier(NULL),
m_piVictoryThreshold(NULL),
m_piVictoryMinThreshold(NULL),
m_piProjectsNeeded(NULL),

//FfH: Added by Kael 08/26/2008
m_iAIWeight(0),
m_iModifyGlobalCounter(0),
m_iPrereqCivilization(NO_CIVILIZATION),
m_iPrereqGlobalCounter(0),
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/*************************************************************************************************/
m_iFaithCost(0),
m_iFaithUpkeep(0),
m_iManaCost(0),
m_iManaUpkeep(0),
m_iManaUpkeepPerCityTimes100(0),
m_iManaSchoolType(0),
m_iSummonUnitType(0),
m_iNumTerrainChanges(0),
m_iTerrainType1(NO_TERRAIN),
m_iTerrainType2(NO_TERRAIN),
m_iTerrainType3(NO_TERRAIN),
m_iTerrainType4(NO_TERRAIN),
m_iTerrainType5(NO_TERRAIN),
m_iTerrainToType1(NO_TERRAIN),
m_iTerrainToType2(NO_TERRAIN),
m_iTerrainToType3(NO_TERRAIN),
m_iTerrainToType4(NO_TERRAIN),
m_iTerrainToType5(NO_TERRAIN),
m_iFeatureTypePre(NO_FEATURE),
m_iFeatureTypePost(NO_FEATURE),
m_iFeatureType2Pre(NO_FEATURE),
m_iFeatureType2Post(NO_FEATURE),
m_bCreateFloodPlains(false),
m_bCreateHellTerrain(false),
m_bCreateRandom(false),
m_bCreateHills(false),
m_bCreatePeak(false),
m_bRemovePeak(false),
m_bRemoveHellTerrain(false),
m_bHostileTerraform(false),
m_bTargetedTerraform(false),
m_bWater(false),
m_bCreateRiver(false),
m_bCreateLand(false),
m_bDrownLand(false),
m_bTransmutationManaBonus(false),
m_bGlobalEnchantmentManaBonus(false),
m_iImprovementTypePre(NO_IMPROVEMENT),
m_iImprovementType2Pre(NO_IMPROVEMENT),
m_iImprovementTypePost(NO_IMPROVEMENT),
m_iImprovementType2Post(NO_IMPROVEMENT),
m_bBanish(false),
m_bCallTheVoid(false),
m_bChaosRift(false),
m_bBirth(false),
m_bRessurection(false),
m_bDeathWish(false),
m_bEarthQuake(false),
m_bEffectOnly(false),
m_bGlobalEnchantment(false),
m_bHostile(false),
m_bNatureWrath(false),
m_iAwarenessLevel(0),
m_iLastTurnPossibleBuild(0),
m_iClimateRitual(NO_PROJECT),
m_iDevilSummon(NO_UNIT),
m_iDiploCharmChange(0),
m_iDiploCharmAlignmentPrereq(NO_ALIGNMENT),
m_iDisjunctionPower(0),
m_iDoubleCostOfOtherManaSchools(NO_MANASCHOOL),
m_iBuildingType(NO_BUILDING),
m_iPromotionType(NO_PROMOTION),
m_iReduceManaCreation(0),
m_iResistHostileTerraforming(0),
m_iTemporaryTech(NO_TECH),
m_iCommerceChange(0),
m_iCommerceChangeType(NO_COMMERCE),
m_iYieldChange(0),
m_iYieldChangeType(NO_YIELD),
m_iBonusPerMana(0),
m_iEffect(NO_EFFECT),
m_iPopulationToExperienceRate(0),
m_bAddPromotionToUnits(true),
m_bAddBuildingToCities(true),
m_iCreateUnitFromExperience(0),
m_iUnitType(NO_UNIT),
m_iPrereqReligion(NO_RELIGION),
m_iPrereqAlignment(NO_ALIGNMENT),
m_iBlockedAlignment(NO_ALIGNMENT)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvProjectInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvProjectInfo::~CvProjectInfo()
{
	SAFE_DELETE_ARRAY(m_piBonusProductionModifier);
	SAFE_DELETE_ARRAY(m_piVictoryThreshold);
	SAFE_DELETE_ARRAY(m_piVictoryMinThreshold);
	SAFE_DELETE_ARRAY(m_piProjectsNeeded);
}

int CvProjectInfo::getVictoryPrereq() const
{
	return m_iVictoryPrereq;
}

int CvProjectInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvProjectInfo::getAnyoneProjectPrereq() const
{
	return m_iAnyoneProjectPrereq;
}

void CvProjectInfo::setAnyoneProjectPrereq(int i)
{
	m_iAnyoneProjectPrereq = i;
}

int CvProjectInfo::getProjectPrereq() const
{
	return m_iProjectPrereq;
}

void CvProjectInfo::setProjectPrereq(int i)
{
	m_iProjectPrereq = i;
}

int CvProjectInfo::getMaxGlobalInstances() const
{
	return m_iMaxGlobalInstances;
}

int CvProjectInfo::getMaxTeamInstances() const
{
	return m_iMaxTeamInstances;
}

int CvProjectInfo::getProductionCost() const
{
	return m_iProductionCost;
}

int CvProjectInfo::getNukeInterception() const
{
	return m_iNukeInterception;
}

int CvProjectInfo::getTechShare() const
{
	return m_iTechShare;
}

int CvProjectInfo::getEveryoneSpecialUnit() const
{
	return m_iEveryoneSpecialUnit;
}

int CvProjectInfo::getEveryoneSpecialBuilding() const
{
	return m_iEveryoneSpecialBuilding;
}

int CvProjectInfo::getVictoryDelayPercent() const
{
	return m_iVictoryDelayPercent;
}

int CvProjectInfo::getSuccessRate() const
{
	return m_iSuccessRate;
}

bool CvProjectInfo::isSpaceship() const
{
	return m_bSpaceship;
}

bool CvProjectInfo::isAllowsNukes() const
{
	return m_bAllowsNukes;
}

const char* CvProjectInfo::getMovieArtDef() const
{
	return m_szMovieArtDef;
}

const TCHAR* CvProjectInfo::getCreateSound() const
{
	return m_szCreateSound;
}

void CvProjectInfo::setCreateSound(const TCHAR* szVal)
{
	m_szCreateSound = szVal;
}

//FfH: Added by Kael 08/26/2008
int CvProjectInfo::getAIWeight() const
{
	return m_iAIWeight;
}

int CvProjectInfo::getModifyGlobalCounter() const
{
	return m_iModifyGlobalCounter;
}

int CvProjectInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

int CvProjectInfo::getPrereqGlobalCounter() const
{
	return m_iPrereqGlobalCounter;
}
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/*************************************************************************************************/
int CvProjectInfo::getFaithCost() const
{
    return m_iFaithCost;
}

int CvProjectInfo::getFaithUpkeep() const
{
    return m_iFaithUpkeep;
}

int CvProjectInfo::getManaCost() const
{
    return m_iManaCost;
}

int CvProjectInfo::getManaUpkeep() const
{
    return m_iManaUpkeep;
}

int CvProjectInfo::getManaUpkeepPerCityTimes100() const
{
    return m_iManaUpkeepPerCityTimes100;
}

int CvProjectInfo::getManaSchoolType() const
{
    return m_iManaSchoolType;
}

int CvProjectInfo::getSummonUnitType() const
{
    return m_iSummonUnitType;
}

int CvProjectInfo::getNumTerrainChanges() const { return m_iNumTerrainChanges;}
int CvProjectInfo::getTerrainType1() const { return m_iTerrainType1;}
int CvProjectInfo::getTerrainType2() const { return m_iTerrainType2;}
int CvProjectInfo::getTerrainType3() const { return m_iTerrainType3;}
int CvProjectInfo::getTerrainType4() const { return m_iTerrainType4;}
int CvProjectInfo::getTerrainType5() const { return m_iTerrainType5;}
int CvProjectInfo::getTerrainToType1() const { return m_iTerrainToType1;}
int CvProjectInfo::getTerrainToType2() const { return m_iTerrainToType2;}
int CvProjectInfo::getTerrainToType3() const { return m_iTerrainToType3;}
int CvProjectInfo::getTerrainToType4() const { return m_iTerrainToType4;}
int CvProjectInfo::getTerrainToType5() const { return m_iTerrainToType5;}
int CvProjectInfo::getFeatureTypePre() const { return m_iFeatureTypePre;}
int CvProjectInfo::getFeatureTypePost() const { return m_iFeatureTypePost;}
int CvProjectInfo::getFeatureType2Pre() const { return m_iFeatureType2Pre;}
int CvProjectInfo::getFeatureType2Post() const { return m_iFeatureType2Post;}
bool CvProjectInfo::isCreateFloodPlains() const { return m_bCreateFloodPlains;}
bool CvProjectInfo::isCreateHellTerrain() const { return m_bCreateHellTerrain;}
bool CvProjectInfo::isCreateRandom() const { return m_bCreateRandom;}
bool CvProjectInfo::isCreateHills() const { return m_bCreateHills;}
bool CvProjectInfo::isCreatePeak() const { return m_bCreatePeak;}
bool CvProjectInfo::isRemovePeak() const { return m_bRemovePeak;}
bool CvProjectInfo::isRemoveHellTerrain() const { return m_bRemoveHellTerrain;}
bool CvProjectInfo::isHostileTerraform() const { return m_bHostileTerraform;}
bool CvProjectInfo::isTargetedTerraform() const { return m_bTargetedTerraform;}

bool CvProjectInfo::isWater() const { return m_bWater;}
bool CvProjectInfo::isCreateRiver() const { return m_bCreateRiver;}
bool CvProjectInfo::isCreateLand() const { return m_bCreateLand;}
bool CvProjectInfo::isDrownLand() const { return m_bDrownLand;}
bool CvProjectInfo::isTransmutationManaBonus() const { return m_bTransmutationManaBonus;}
bool CvProjectInfo::isGlobalEnchantmentManaBonus() const { return m_bGlobalEnchantmentManaBonus;}
int CvProjectInfo::getImprovementTypePre() const { return m_iImprovementTypePre;}
int CvProjectInfo::getImprovementType2Pre() const { return m_iImprovementType2Pre;}
int CvProjectInfo::getImprovementTypePost() const { return m_iImprovementTypePost;}
int CvProjectInfo::getImprovementType2Post() const { return m_iImprovementType2Post;}

bool CvProjectInfo::isBanish() const { return m_bBanish;}
bool CvProjectInfo::isCallTheVoid() const { return m_bCallTheVoid;}
bool CvProjectInfo::isChaosRift() const { return m_bChaosRift;}
bool CvProjectInfo::isBirth() const { return m_bBirth;}
bool CvProjectInfo::isRessurection() const { return m_bRessurection;}
bool CvProjectInfo::isDeathWish() const { return m_bDeathWish;}
bool CvProjectInfo::isEarthQuake() const { return m_bEarthQuake;}
bool CvProjectInfo::isEffectOnly() const { return m_bEffectOnly;}
bool CvProjectInfo::isGlobalEnchantment() const { return m_bGlobalEnchantment;}
bool CvProjectInfo::isHostile() const { return m_bHostile;}
bool CvProjectInfo::isNatureWrath() const { return m_bNatureWrath;}

BonusTypes CvProjectInfo::getManaBonusLinked() const
{
	if(getTechPrereq()==NO_TECH)
		return NO_BONUS;
	return (BonusTypes)GC.getTechInfo((TechTypes)getTechPrereq()).getPrereqBonus();
}

int CvProjectInfo::getAwarenessLevel() const { return m_iAwarenessLevel;}
int CvProjectInfo::getLastTurnPossibleBuild() const { return m_iLastTurnPossibleBuild;}
int CvProjectInfo::getClimateRitual() const { return m_iClimateRitual;}
int CvProjectInfo::getDevilSummon() const { return m_iDevilSummon;}
int CvProjectInfo::getDiploCharmChange() const { return m_iDiploCharmChange;}
int CvProjectInfo::getDiploCharmAlignmentPrereq() const { return m_iDiploCharmAlignmentPrereq;}
int CvProjectInfo::getDisjunctionPower() const { return m_iDisjunctionPower;}
int CvProjectInfo::getDoubleCostOfOtherManaSchools() const { return m_iDoubleCostOfOtherManaSchools;}
int CvProjectInfo::getBuildingType() const { return m_iBuildingType;}
int CvProjectInfo::getPromotionType() const { return m_iPromotionType;}
int CvProjectInfo::getReduceManaCreation() const { return m_iReduceManaCreation;}
int CvProjectInfo::getResistHostileTerraforming() const { return m_iResistHostileTerraforming;}
int CvProjectInfo::getTemporaryTech() const { return m_iTemporaryTech;}
int CvProjectInfo::getCommerceChange() const { return m_iCommerceChange;}
int CvProjectInfo::getCommerceChangeType() const { return m_iCommerceChangeType;}
int CvProjectInfo::getYieldChange() const { return m_iYieldChange;}
int CvProjectInfo::getYieldChangeType() const { return m_iYieldChangeType;}
int CvProjectInfo::getBonusPerMana() const { return m_iBonusPerMana;}
int CvProjectInfo::getEffect() const { return m_iEffect;}
int CvProjectInfo::getPopulationToExperienceRate() const { return m_iPopulationToExperienceRate;}
bool CvProjectInfo::isAddPromotionToUnits() const { return m_bAddPromotionToUnits;}
bool CvProjectInfo::isAddBuildingToCities() const { return m_bAddBuildingToCities;}
int CvProjectInfo::getCreateUnitFromExperience() const { return m_iCreateUnitFromExperience;}
int CvProjectInfo::getUnitType() const { return m_iUnitType;}
const TCHAR* CvProjectInfo::getPyResult() const { return m_szPyResult; }
int CvProjectInfo::getPrereqReligion() const { return m_iPrereqReligion;}
int CvProjectInfo::getPrereqAlignment() const { return m_iPrereqAlignment;}
int CvProjectInfo::getBlockedAlignment() const { return m_iBlockedAlignment;}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

// Arrays

int CvProjectInfo::getBonusProductionModifier(int i) const
{
	FAssertMsg(i < GC.getNumBonusInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piBonusProductionModifier ? m_piBonusProductionModifier[i] : -1;
}

int CvProjectInfo::getVictoryThreshold(int i) const
{
	FAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piVictoryThreshold ? m_piVictoryThreshold[i] : -1;
}

int CvProjectInfo::getVictoryMinThreshold(int i) const
{
	FAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	if (m_piVictoryMinThreshold && m_piVictoryMinThreshold[i] != 0)
	{
		return m_piVictoryMinThreshold[i];
	}

	return getVictoryThreshold(i);
}

int CvProjectInfo::getProjectsNeeded(int i) const
{
	FAssertMsg(i < GC.getNumProjectInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piProjectsNeeded ? m_piProjectsNeeded[i] : false;
}

int CvProjectInfo::getProjectsNeededVectorSize()					{return m_aszProjectsNeededforPass3.size();}
CvString CvProjectInfo::getProjectsNeededNamesVectorElement(int i)	{return m_aszProjectsNeededforPass3[i];}
int CvProjectInfo::getProjectsNeededValuesVectorElement(int i)		{return m_aiProjectsNeededforPass3[i];}

bool CvProjectInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "VictoryPrereq","NONE");
	m_iVictoryPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq","NONE");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iMaxGlobalInstances, "iMaxGlobalInstances",-1);
	pXML->GetChildXmlValByName(&m_iMaxTeamInstances, "iMaxTeamInstances",-1);
	pXML->GetChildXmlValByName(&m_iProductionCost, "iCost");
	pXML->GetChildXmlValByName(&m_iNukeInterception, "iNukeInterception",0);
	pXML->GetChildXmlValByName(&m_iTechShare, "iTechShare",0);

	pXML->GetChildXmlValByName(szTextVal, "EveryoneSpecialUnit","NONE");
	m_iEveryoneSpecialUnit = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "EveryoneSpecialBuilding","NONE");
	m_iEveryoneSpecialBuilding = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bSpaceship, "bSpaceship",0);
	pXML->GetChildXmlValByName(&m_bAllowsNukes, "bAllowsNukes",0);
	pXML->GetChildXmlValByName(m_szMovieArtDef, "MovieDefineTag");

	pXML->SetVariableListTagPair(&m_piBonusProductionModifier, "BonusProductionModifiers", sizeof(GC.getBonusInfo((BonusTypes)0)), GC.getNumBonusInfos());
	pXML->SetVariableListTagPair(&m_piVictoryThreshold, "VictoryThresholds", sizeof(GC.getVictoryInfo((VictoryTypes)0)), GC.getNumVictoryInfos());
	pXML->SetVariableListTagPair(&m_piVictoryMinThreshold, "VictoryMinThresholds", sizeof(GC.getVictoryInfo((VictoryTypes)0)), GC.getNumVictoryInfos());
	pXML->GetChildXmlValByName(&m_iVictoryDelayPercent, "iVictoryDelayPercent",0);
	pXML->GetChildXmlValByName(&m_iSuccessRate, "iSuccessRate",0);

	pXML->GetChildXmlValByName(szTextVal, "CreateSound");
	setCreateSound(szTextVal);

//FfH: Added by Kael 08/26/2008
	pXML->GetChildXmlValByName(&m_iAIWeight, "iAIWeight",0);
	pXML->GetChildXmlValByName(&m_iModifyGlobalCounter, "iModifyGlobalCounter",0);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization","NONE");
	m_aszExtraXMLforPass3.push_back(szTextVal);
	pXML->GetChildXmlValByName(&m_iPrereqGlobalCounter, "iPrereqGlobalCounter",0);
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/*************************************************************************************************/
    pXML->GetChildXmlValByName(&m_iFaithCost, "iFaithCost");
    pXML->GetChildXmlValByName(&m_iManaCost, "iManaCost");
    pXML->GetChildXmlValByName(&m_iFaithUpkeep, "iFaithUpkeep");
    pXML->GetChildXmlValByName(&m_iManaUpkeep, "iManaUpkeep");
    pXML->GetChildXmlValByName(&m_iManaUpkeepPerCityTimes100, "iManaUpkeepPerCityTimes100");
	pXML->GetChildXmlValByName(szTextVal, "ManaSchoolType");
	m_iManaSchoolType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "SummonUnitType");
	m_iSummonUnitType = pXML->FindInInfoClass(szTextVal);

    pXML->GetChildXmlValByName(&m_iNumTerrainChanges, "iNumTerrainChanges");
	pXML->GetChildXmlValByName(szTextVal, "TerrainType1");
	m_iTerrainType1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainType2");
	m_iTerrainType2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainType3");
	m_iTerrainType3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainType4");
	m_iTerrainType4 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainType5");
	m_iTerrainType5 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainToType1");
	m_iTerrainToType1 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainToType2");
	m_iTerrainToType2 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainToType3");
	m_iTerrainToType3 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainToType4");
	m_iTerrainToType4 = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TerrainToType5");
	m_iTerrainToType5 = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FeatureTypePre");
	m_iFeatureTypePre = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureTypePost");
	m_iFeatureTypePost = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureType2Pre");
	m_iFeatureType2Pre = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FeatureType2Post");
	m_iFeatureType2Post = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bCreateFloodPlains, "bCreateFloodPlains");
	pXML->GetChildXmlValByName(&m_bCreateHellTerrain, "bCreateHellTerrain");
	pXML->GetChildXmlValByName(&m_bCreateRandom, "bCreateRandom");
	pXML->GetChildXmlValByName(&m_bCreateHills, "bCreateHills");
	pXML->GetChildXmlValByName(&m_bCreatePeak, "bCreatePeak");
	pXML->GetChildXmlValByName(&m_bRemovePeak, "bRemovePeak");
	pXML->GetChildXmlValByName(&m_bRemoveHellTerrain, "bRemoveHellTerrain");
	pXML->GetChildXmlValByName(&m_bHostileTerraform, "bHostileTerraform");
	pXML->GetChildXmlValByName(&m_bTargetedTerraform, "bTargetedTerraform");

	pXML->GetChildXmlValByName(&m_bWater, "bWater");
	pXML->GetChildXmlValByName(&m_bCreateRiver, "bCreateRiver");
	pXML->GetChildXmlValByName(&m_bCreateLand, "bCreateLand");
	pXML->GetChildXmlValByName(&m_bDrownLand, "bDrownLand");
	pXML->GetChildXmlValByName(&m_bTransmutationManaBonus, "bTransmutationManaBonus");
	pXML->GetChildXmlValByName(&m_bGlobalEnchantmentManaBonus, "bGlobalEnchantmentManaBonus");

	pXML->GetChildXmlValByName(szTextVal, "ImprovementTypePre");
	m_iImprovementTypePre = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ImprovementTypePost");
	m_iImprovementTypePost = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ImprovementType2Pre");
	m_iImprovementType2Pre = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ImprovementType2Post");
	m_iImprovementType2Post = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_bBanish, "bBanish");
	pXML->GetChildXmlValByName(&m_bCallTheVoid, "bCallTheVoid");
	pXML->GetChildXmlValByName(&m_bChaosRift, "bChaosRift");
	pXML->GetChildXmlValByName(&m_bBirth, "bBirth");
	pXML->GetChildXmlValByName(&m_bRessurection, "bRessurection");
	pXML->GetChildXmlValByName(&m_bDeathWish, "bDeathWish");
	pXML->GetChildXmlValByName(&m_bEarthQuake, "bEarthQuake");
	pXML->GetChildXmlValByName(&m_bEffectOnly, "bEffectOnly");
	pXML->GetChildXmlValByName(&m_bGlobalEnchantment, "bGlobalEnchantment");
	pXML->GetChildXmlValByName(&m_bHostile, "bHostile");
	pXML->GetChildXmlValByName(&m_bNatureWrath, "bNatureWrath");

    pXML->GetChildXmlValByName(&m_iAwarenessLevel, "iAwarenessLevel");
    pXML->GetChildXmlValByName(&m_iLastTurnPossibleBuild, "iLastTurnPossibleBuild");
    pXML->GetChildXmlValByName(&m_iDiploCharmChange, "iDiploCharmChange");
    pXML->GetChildXmlValByName(&m_iDisjunctionPower, "iDisjunctionPower");
    pXML->GetChildXmlValByName(&m_iReduceManaCreation, "iReduceManaCreation");
    pXML->GetChildXmlValByName(&m_iResistHostileTerraforming, "iResistHostileTerraforming");
	pXML->GetChildXmlValByName(szTextVal, "TemporaryTech");
	m_iTemporaryTech = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iCommerceChange, "iCommerceChange");
	pXML->GetChildXmlValByName(szTextVal, "CommerceChangeType");
	m_iCommerceChangeType = pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iBonusPerMana, "iBonusPerMana");
    pXML->GetChildXmlValByName(&m_iYieldChange, "iYieldChange");
	pXML->GetChildXmlValByName(szTextVal, "YieldChangeType");
	m_iYieldChangeType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "Effect");
	if (szTextVal!= "") m_iEffect= pXML->FindInInfoClass(szTextVal);
    pXML->GetChildXmlValByName(&m_iPopulationToExperienceRate, "iPopulationToExperienceRate");
    pXML->GetChildXmlValByName(&m_bAddPromotionToUnits, "bAddPromotionToUnits", true);
    pXML->GetChildXmlValByName(&m_bAddBuildingToCities, "bAddBuildingToCities", true);
    pXML->GetChildXmlValByName(&m_iCreateUnitFromExperience, "iCreateUnitFromExperience");
	pXML->GetChildXmlValByName(szTextVal, "UnitType");
	m_iUnitType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(m_szPyResult, "PyResult");
	pXML->GetChildXmlValByName(szTextVal, "ClimateRitual");
	m_iClimateRitual = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DevilSummon");
	m_iDevilSummon = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DiploCharmAlignmentPrereq");
	m_iDiploCharmAlignmentPrereq = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BuildingType");
	m_iBuildingType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PromotionType");
	m_iPromotionType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "DoubleCostOfOtherManaSchools");
	m_iDoubleCostOfOtherManaSchools = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "BlockedAlignment");
	m_iBlockedAlignment = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ProjectsNeededValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszProjectsNeededforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiProjectsNeededforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}

bool CvProjectInfo::readPass2(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

// moved to readpass3 Sephi
//	pXML->SetVariableListTagPair(&m_piProjectsNeeded, "PrereqProjects", sizeof(GC.getProjectInfo((ProjectTypes)0)), GC.getNumProjectInfos());

	pXML->GetChildXmlValByName(szTextVal, "AnyonePrereqProject");
	m_iAnyoneProjectPrereq = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "PrereqEnchantment");
	m_iProjectPrereq = GC.getInfoTypeForString(szTextVal);

	return true;
}

//FfH: Added by Kael 08/26/2008
bool CvProjectInfo::readPass3()
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}
	m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iPrereqCivilization = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	m_aszExtraXMLforPass3.clear();

    m_piProjectsNeeded = new int[GC.getNumProjectInfos()];
    for (int iI = 0; iI < GC.getNumProjectInfos(); iI++)
	{
        m_piProjectsNeeded[iI] = 0;
	}
    int iNumLoad = m_aiProjectsNeededforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszProjectsNeededforPass3[iI]) >= 0, "Warning, about to leak memory in CvProjectsInfo::readPass3");
		m_piProjectsNeeded[GC.getInfoTypeForString(m_aszProjectsNeededforPass3[iI])] += m_aiProjectsNeededforPass3[iI];
	}
    m_aszProjectsNeededforPass3.clear();
    m_aiProjectsNeededforPass3.clear();

	return true;
}
//FfH: End Add
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(ProjectInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvProjectInfo::copyNonDefaults(CvProjectInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isSpaceship()						== false)				m_bSpaceship					= pClassInfo->isSpaceship();
	if (isAllowsNukes()						== false)				m_bAllowsNukes					= pClassInfo->isAllowsNukes();
	if (getProductionCost()					== 0)					m_iProductionCost				= pClassInfo->getProductionCost();
	if (getNukeInterception()				== 0)					m_iNukeInterception				= pClassInfo->getNukeInterception();
	if (getTechShare()						== 0)					m_iTechShare					= pClassInfo->getTechShare();
	if (getVictoryDelayPercent()			== 0)					m_iVictoryDelayPercent			= pClassInfo->getVictoryDelayPercent();
	if (getSuccessRate()					== 0)					m_iSuccessRate					= pClassInfo->getSuccessRate();
	if (getPrereqGlobalCounter()			== 0)					m_iPrereqGlobalCounter			= pClassInfo->getPrereqGlobalCounter();
	if (getAIWeight()						== 0)					m_iAIWeight						= pClassInfo->getAIWeight();
	if (getModifyGlobalCounter()			== 0)					m_iModifyGlobalCounter			= pClassInfo->getModifyGlobalCounter();
	if (getMaxGlobalInstances()				== -1)					m_iMaxGlobalInstances			= pClassInfo->getMaxGlobalInstances();
	if (getMaxTeamInstances()				== -1)					m_iMaxTeamInstances				= pClassInfo->getMaxTeamInstances();
	if (getMovieArtDef()					== cDefault)			m_szMovieArtDef					= pClassInfo->getMovieArtDef();
	if (getCreateSound()					== cDefault)			setCreateSound(					pClassInfo->getCreateSound());
	if (getTechPrereq()						== NO_TECH)				m_iTechPrereq					= pClassInfo->getTechPrereq();
	if (getVictoryPrereq()					== NO_VICTORY)			m_iVictoryPrereq				= pClassInfo->getVictoryPrereq();
	if (getEveryoneSpecialUnit()			== NO_SPECIALUNIT)		m_iEveryoneSpecialUnit			= pClassInfo->getEveryoneSpecialUnit();
	if (getEveryoneSpecialBuilding()		== NO_SPECIALBUILDING)	m_iEveryoneSpecialBuilding		= pClassInfo->getEveryoneSpecialBuilding();
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/*************************************************************************************************/
	if (getFaithCost()                      == 0)                   m_iFaithCost                    = pClassInfo->getFaithCost();
	if (getManaCost()                       == 0)                   m_iManaCost                     = pClassInfo->getManaCost();
	if (getFaithUpkeep()                    == 0)                   m_iFaithUpkeep                  = pClassInfo->getFaithUpkeep();
	if (getManaUpkeep()                     == 0)                   m_iManaUpkeep                   = pClassInfo->getManaUpkeep();
	if (getManaUpkeepPerCityTimes100()      == 0)                   m_iManaUpkeepPerCityTimes100    = pClassInfo->getManaUpkeepPerCityTimes100();
	if (getManaSchoolType()                 == NO_MANASCHOOL)       m_iManaSchoolType               = pClassInfo->getManaSchoolType();
	if (getSummonUnitType()                 == NO_UNIT)             m_iSummonUnitType               = pClassInfo->getSummonUnitType();
	if (getNumTerrainChanges()				== 0)					m_iNumTerrainChanges			= pClassInfo->getNumTerrainChanges();
	if (getTerrainType1()			        == NO_TERRAIN)          m_iTerrainType1					= pClassInfo->getTerrainType1();
	if (getTerrainType2()			        == NO_TERRAIN)          m_iTerrainType2					= pClassInfo->getTerrainType2();
	if (getTerrainType3()			        == NO_TERRAIN)          m_iTerrainType3					= pClassInfo->getTerrainType3();
	if (getTerrainType4()			        == NO_TERRAIN)          m_iTerrainType4					= pClassInfo->getTerrainType4();
	if (getTerrainType5()			        == NO_TERRAIN)          m_iTerrainType5					= pClassInfo->getTerrainType5();
	if (getTerrainToType1()			        == NO_TERRAIN)          m_iTerrainToType1				= pClassInfo->getTerrainToType1();
	if (getTerrainToType2()			        == NO_TERRAIN)          m_iTerrainToType2				= pClassInfo->getTerrainToType2();
	if (getTerrainToType3()			        == NO_TERRAIN)          m_iTerrainToType3				= pClassInfo->getTerrainToType3();
	if (getTerrainToType4()			        == NO_TERRAIN)          m_iTerrainToType4				= pClassInfo->getTerrainToType4();
	if (getTerrainToType5()			        == NO_TERRAIN)          m_iTerrainToType5				= pClassInfo->getTerrainToType5();
	if (getFeatureTypePre()			        == NO_FEATURE)          m_iFeatureTypePre				= pClassInfo->getFeatureTypePre();
	if (getFeatureTypePost()			    == NO_FEATURE)          m_iFeatureTypePost				= pClassInfo->getFeatureTypePost();
	if (getFeatureType2Pre()			    == NO_FEATURE)          m_iFeatureType2Pre				= pClassInfo->getFeatureType2Pre();
	if (getFeatureType2Post()			    == NO_FEATURE)          m_iFeatureType2Post				= pClassInfo->getFeatureType2Post();

	if (isCreateFloodPlains()				== false)				m_bCreateFloodPlains			= pClassInfo->isCreateFloodPlains();
	if (isCreateHellTerrain()				== false)				m_bCreateHellTerrain			= pClassInfo->isCreateHellTerrain();
	if (isCreateRandom()					== false)				m_bCreateRandom					= pClassInfo->isCreateRandom();
	if (isCreateHills()						== false)				m_bCreateHills					= pClassInfo->isCreateHills();
	if (isCreatePeak()						== false)				m_bCreatePeak					= pClassInfo->isCreatePeak();
	if (isRemovePeak()						== false)				m_bRemovePeak					= pClassInfo->isRemovePeak();
	if (isRemoveHellTerrain()				== false)				m_bRemoveHellTerrain			= pClassInfo->isRemoveHellTerrain();
	if (isHostileTerraform()				== false)				m_bHostileTerraform				= pClassInfo->isHostileTerraform();
	if (isTargetedTerraform()				== false)				m_bTargetedTerraform			= pClassInfo->isTargetedTerraform();

	if (isWater()							== false)				m_bWater						= pClassInfo->isWater();
	if (isCreateRiver()						== false)				m_bCreateRiver					= pClassInfo->isCreateRiver();
	if (isCreateLand()						== false)				m_bCreateLand					= pClassInfo->isCreateLand();
	if (isDrownLand()						== false)				m_bDrownLand					= pClassInfo->isDrownLand();
	if (isTransmutationManaBonus()			== false)				m_bTransmutationManaBonus		= pClassInfo->isTransmutationManaBonus();
	if (isGlobalEnchantmentManaBonus()		== false)				m_bGlobalEnchantmentManaBonus	= pClassInfo->isGlobalEnchantmentManaBonus();

	if (getImprovementTypePre()			    == NO_IMPROVEMENT)      m_iImprovementTypePre			= pClassInfo->getImprovementTypePre();
	if (getImprovementTypePost()			== NO_IMPROVEMENT)      m_iImprovementTypePost			= pClassInfo->getImprovementTypePost();
	if (getImprovementType2Pre()			== NO_IMPROVEMENT)      m_iImprovementType2Pre			= pClassInfo->getImprovementType2Pre();
	if (getImprovementType2Post()			== NO_IMPROVEMENT)      m_iImprovementType2Post			= pClassInfo->getImprovementType2Post();

	if (isBanish()							== false)				m_bBanish						= pClassInfo->isBanish();
	if (isCallTheVoid()						== false)				m_bCallTheVoid					= pClassInfo->isCallTheVoid();
	if (isChaosRift()						== false)				m_bChaosRift					= pClassInfo->isChaosRift();
	if (isBirth()							== false)				m_bBirth						= pClassInfo->isBirth();
	if (isRessurection()					== false)				m_bRessurection					= pClassInfo->isRessurection();
	if (isDeathWish()						== false)				m_bDeathWish					= pClassInfo->isDeathWish();
	if (isEarthQuake()						== false)				m_bEarthQuake					= pClassInfo->isEarthQuake();
	if (isEffectOnly()						== false)				m_bEffectOnly					= pClassInfo->isEffectOnly();
	if (isGlobalEnchantment()				== false)				m_bGlobalEnchantment			= pClassInfo->isGlobalEnchantment();
	if (isHostile()							== false)				m_bHostile						= pClassInfo->isHostile();
	if (isNatureWrath()						== false)				m_bNatureWrath					= pClassInfo->isNatureWrath();

	if (getAwarenessLevel()                 == 0)                   m_iAwarenessLevel               = pClassInfo->getAwarenessLevel();
	if (getLastTurnPossibleBuild()          == 0)                   m_iLastTurnPossibleBuild        = pClassInfo->getLastTurnPossibleBuild();
	if (getDiploCharmChange()               == 0)                   m_iDiploCharmChange             = pClassInfo->getDiploCharmChange();
	if (getDisjunctionPower()               == 0)                   m_iDisjunctionPower             = pClassInfo->getDisjunctionPower();
	if (getReduceManaCreation()             == 0)                   m_iReduceManaCreation           = pClassInfo->getReduceManaCreation();
	if (getResistHostileTerraforming()      == 0)                   m_iResistHostileTerraforming    = pClassInfo->getResistHostileTerraforming();
	if (getTemporaryTech()				    == NO_TECH)             m_iTemporaryTech			    = pClassInfo->getTemporaryTech();
	if (getCommerceChange()				    == 0)                   m_iCommerceChange				= pClassInfo->getCommerceChange();
	if (getCommerceChangeType()			    == NO_COMMERCE)         m_iCommerceChangeType			= pClassInfo->getCommerceChangeType();
	if (getYieldChange()				    == 0)                   m_iYieldChange				    = pClassInfo->getYieldChange();
	if (getYieldChangeType()			    == NO_YIELD)            m_iYieldChangeType			    = pClassInfo->getYieldChangeType();
	if (getBonusPerMana()					== 0)		            m_iBonusPerMana					= pClassInfo->getBonusPerMana();
	if (getClimateRitual()					== NO_PROJECT)		    m_iClimateRitual				= pClassInfo->getClimateRitual();
	if (getDevilSummon()					== NO_UNIT)				m_iDevilSummon					= pClassInfo->getDevilSummon();
	if (getDiploCharmAlignmentPrereq()		== NO_ALIGNMENT)        m_iDiploCharmAlignmentPrereq	= pClassInfo->getDiploCharmAlignmentPrereq();
	if (getDoubleCostOfOtherManaSchools()   == NO_MANASCHOOL)       m_iDoubleCostOfOtherManaSchools = pClassInfo->getDoubleCostOfOtherManaSchools();
	if (getPromotionType()					== NO_PROMOTION)	    m_iPromotionType				= pClassInfo->getPromotionType();
	if (getBuildingType()					== NO_BUILDING)		    m_iBuildingType					= pClassInfo->getBuildingType();
	if (getEffect()							== NO_EFFECT)		    m_iEffect						= pClassInfo->getEffect();

	if (getUnitType()						== NO_UNIT)				m_iUnitType						= pClassInfo->getUnitType();
	if (getPopulationToExperienceRate()		== 0)                   m_iPopulationToExperienceRate   = pClassInfo->getPopulationToExperienceRate();
	if (getCreateUnitFromExperience()		== 0)                   m_iCreateUnitFromExperience		= pClassInfo->getCreateUnitFromExperience();
	if (isAddPromotionToUnits()				== true)                m_bAddPromotionToUnits			= pClassInfo->isAddPromotionToUnits();
	if (isAddBuildingToCities()				== true)                m_bAddBuildingToCities			= pClassInfo->isAddBuildingToCities();
	if (getPyResult()				== cDefault)			m_szPyResult			= pClassInfo->getPyResult();
	if (getPrereqReligion()					== NO_RELIGION)		    m_iPrereqReligion				= pClassInfo->getPrereqReligion();
	if (getPrereqAlignment()				== NO_ALIGNMENT)		m_iPrereqAlignment				= pClassInfo->getPrereqAlignment();
	if (getBlockedAlignment()				== NO_ALIGNMENT)		m_iBlockedAlignment				= pClassInfo->getBlockedAlignment();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	for (int i = 0; i < GC.getNumBonusInfos(); i++)
	{
		if (m_piBonusProductionModifier[i]	== 0) 					m_piBonusProductionModifier[i]	= pClassInfo->getBonusProductionModifier(i);
	}
	for (int i = 0; i < GC.getNumVictoryInfos(); i++)
	{
		if (m_piVictoryThreshold[i]			== 0) 					m_piVictoryThreshold[i]			= pClassInfo->getVictoryThreshold(i);
		if (m_piVictoryMinThreshold[i]		== 0)					m_piVictoryMinThreshold[i]		= pClassInfo->getVictoryMinThreshold(i);
	}


	// Readpass2 stuff
	if (m_iAnyoneProjectPrereq				== NO_PROJECT)			m_iAnyoneProjectPrereq			= pClassInfo->getAnyoneProjectPrereq();
	if (m_iProjectPrereq					== NO_PROJECT)			m_iProjectPrereq				= pClassInfo->getProjectPrereq();
/** Moved to Readpass3
	if(!m_piProjectsNeeded)											pXML->InitList(&m_piProjectsNeeded, GC.getNumProjectInfos(), 0);
	for (int i = 0; i < GC.getNumProjectInfos(); ++i)
	{
		if(getProjectsNeeded(i)				== 0)					m_piProjectsNeeded[i]			= pClassInfo->getProjectsNeeded(i);
	}
**/
	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getProjectsNeededVectorSize(); i++ )
	{
		m_aszProjectsNeededforPass3.push_back(	pClassInfo->getProjectsNeededNamesVectorElement(i));
		m_aiProjectsNeededforPass3.push_back(	pClassInfo->getProjectsNeededValuesVectorElement(i));
	}
}

void CvProjectInfo::copyNonDefaultsReadPass2(CvProjectInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();
/** moved to Readpass3
	if(!m_piProjectsNeeded)											pXML->InitList(&m_piProjectsNeeded, GC.getNumProjectInfos(), 0);
	for (int i = 0; i < GC.getNumProjectInfos(); ++i)
	{
		if(bOver || pClassInfo->getProjectsNeeded(i)	!= 0)		m_piProjectsNeeded[i]			= pClassInfo->getProjectsNeeded(i);
	}
**/
	if (bOver || pClassInfo->getAnyoneProjectPrereq()	!= -1)		m_iAnyoneProjectPrereq			= pClassInfo->getAnyoneProjectPrereq();
	if (bOver || pClassInfo->getProjectPrereq()	!= -1)				m_iProjectPrereq				= pClassInfo->getProjectPrereq();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvReligionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvReligionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvReligionInfo::CvReligionInfo() :
m_iChar(0),
m_iHolyCityChar(0),
m_iTechPrereq(NO_TECH),
m_iFreeUnitClass(NO_UNITCLASS),
m_iNumFreeUnits(0),
m_iSpreadFactor(0),
m_iMissionType(NO_MISSION),
m_paiGlobalReligionCommerce(NULL),
m_paiHolyCityCommerce(NULL),
m_paiStateReligionCommerce(NULL),
/*************************************************************************************************/
/**	LoadedTGA               				05/15/08								        	**/
/**																								**/
/**										Initial Values											**/
/*************************************************************************************************/
m_iTGAIndex(-1),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Religion: Added by Kael 08/09/2007
m_bHidden(false),
m_bSneakAttack(false),
m_bUpdateSight(false),
m_iGlobalCounterFound(0),
m_iGlobalCounterSpread(0),
m_iAlignment(NO_ALIGNMENT),
m_iAlignmentBest(NO_ALIGNMENT),
m_iAlignmentWorst(NO_ALIGNMENT)
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
,m_eReligionHero1(NO_UNITCLASS)
,m_eReligionHero2(NO_UNITCLASS)
,m_eReligionTech1(NO_TECH)
,m_eReligionTech2(NO_TECH)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
{
	reset();
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvReligionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvReligionInfo::~CvReligionInfo()
{
	SAFE_DELETE_ARRAY(m_paiGlobalReligionCommerce);
	SAFE_DELETE_ARRAY(m_paiHolyCityCommerce);
	SAFE_DELETE_ARRAY(m_paiStateReligionCommerce);
}

int CvReligionInfo::getChar() const
{
	return m_iChar;
}

void CvReligionInfo::setChar(int i)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iChar = i;
/**								----  End Original Code  ----									**/
	m_iChar = 8550 + m_iTGAIndex * 2;
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvReligionInfo::getHolyCityChar() const
{
	return m_iHolyCityChar;
}

void CvReligionInfo::setHolyCityChar(int i)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iHolyCityChar = i;
/**								----  End Original Code  ----									**/
	m_iHolyCityChar = 8551 + m_iTGAIndex * 2;
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvReligionInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvReligionInfo::getFreeUnitClass() const
{
	return m_iFreeUnitClass;
}

int CvReligionInfo::getNumFreeUnits() const
{
	return m_iNumFreeUnits;
}

int CvReligionInfo::getSpreadFactor() const
{
	return m_iSpreadFactor;
}

int CvReligionInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvReligionInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

const TCHAR* CvReligionInfo::getTechButton() const
{
	return m_szTechButton;
}

void CvReligionInfo::setTechButton(const TCHAR* szVal)
{
	m_szTechButton=szVal;
}

const TCHAR* CvReligionInfo::getGenericTechButton() const
{
	return m_szGenericTechButton;
}

void CvReligionInfo::setGenericTechButton(const TCHAR* szVal)
{
	m_szGenericTechButton = szVal;
}

const TCHAR* CvReligionInfo::getMovieFile() const
{
	return m_szMovieFile;
}

void CvReligionInfo::setMovieFile(const TCHAR* szVal)
{
	m_szMovieFile = szVal;
}

const TCHAR* CvReligionInfo::getMovieSound() const
{
	return m_szMovieSound;
}

void CvReligionInfo::setMovieSound(const TCHAR* szVal)
{
	m_szMovieSound = szVal;
}

const TCHAR* CvReligionInfo::getButtonDisabled( void ) const
{
	static TCHAR szDisabled[512];

	szDisabled[0] = '\0';

	if ( getButton() && strlen(getButton()) > 4 )
	{
		strncpy( szDisabled, getButton(), strlen(getButton()) - 4 );
		szDisabled[strlen(getButton()) - 4] = '\0';
		strcat( szDisabled, "_D.dds" );
	}

	return szDisabled;
}

const TCHAR* CvReligionInfo::getSound() const
{
	return m_szSound;
}

void CvReligionInfo::setSound(const TCHAR* szVal)
{
	m_szSound=szVal;
}

void CvReligionInfo::setAdjectiveKey(const TCHAR* szVal)
{
	m_szAdjectiveKey = szVal;
}

const wchar* CvReligionInfo::getAdjectiveKey() const
{
	return m_szAdjectiveKey;
}

// Arrays

int CvReligionInfo::getGlobalReligionCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiGlobalReligionCommerce ? m_paiGlobalReligionCommerce[i] : -1;
}

int* CvReligionInfo::getGlobalReligionCommerceArray() const
{
	return m_paiGlobalReligionCommerce;
}

int CvReligionInfo::getHolyCityCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiHolyCityCommerce ? m_paiHolyCityCommerce[i] : -1;
}

int* CvReligionInfo::getHolyCityCommerceArray() const
{
	return m_paiHolyCityCommerce;
}

int CvReligionInfo::getStateReligionCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiStateReligionCommerce ? m_paiStateReligionCommerce[i] : -1;
}

int* CvReligionInfo::getStateReligionCommerceArray() const
{
	return m_paiStateReligionCommerce;
}

/*************************************************************************************************/
/**	LoadedTGA               				05/15/08								        	**/
/**																								**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
int CvReligionInfo::getTGAIndex() const						{return m_iTGAIndex;}
void CvReligionInfo::setTGAIndex(int i)						{m_iTGAIndex = i;}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/

//FfH Religion: Added by Kael 08/09/2007
bool CvReligionInfo::isHidden() const
{
	return m_bHidden;
}

bool CvReligionInfo::isSneakAttack() const
{
	return m_bSneakAttack;
}

bool CvReligionInfo::isUpdateSight() const
{
	return m_bUpdateSight;
}

int CvReligionInfo::getGlobalCounterFound() const
{
	return m_iGlobalCounterFound;
}

int CvReligionInfo::getGlobalCounterSpread() const
{
	return m_iGlobalCounterSpread;
}

int CvReligionInfo::getAlignment() const
{
	return m_iAlignment;
}

int CvReligionInfo::getAlignmentBest() const
{
	return m_iAlignmentBest;
}

int CvReligionInfo::getAlignmentWorst() const
{
	return m_iAlignmentWorst;
}
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/

UnitClassTypes CvReligionInfo::getReligionHero1() const
{
	return m_eReligionHero1;
}

UnitClassTypes CvReligionInfo::getReligionHero2() const
{
	return m_eReligionHero2;
}

TechTypes CvReligionInfo::getReligionTech1() const
{
	return m_eReligionTech1;
}

TechTypes CvReligionInfo::getReligionTech2() const
{
	return m_eReligionTech2;
}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
//
// read from xml
//
bool CvReligionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeUnitClass");
	m_iFreeUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iNumFreeUnits, "iFreeUnits");
	pXML->GetChildXmlValByName(&m_iSpreadFactor, "iSpreadFactor");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"GlobalReligionCommerces"))
	{
		pXML->SetCommerce(&m_paiGlobalReligionCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiGlobalReligionCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HolyCityCommerces"))
	{
		pXML->SetCommerce(&m_paiHolyCityCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiHolyCityCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"StateReligionCommerces"))
	{
		pXML->SetCommerce(&m_paiStateReligionCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiStateReligionCommerce, NUM_COMMERCE_TYPES);
	}

	pXML->GetChildXmlValByName(szTextVal, "TechButton");
	setTechButton(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "GenericTechButton");
	setGenericTechButton(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieFile");
	setMovieFile(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieSound");
	setMovieSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Adjective");
	setAdjectiveKey(szTextVal);

/*************************************************************************************************/
/**	LoadedTGA               				05/15/08								        	**/
/**																								**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iTGAIndex, "iTGAIndex");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
//FfH Religions: Added by Kael 08/09/2007
	pXML->GetChildXmlValByName(&m_bHidden, "bHidden");
	pXML->GetChildXmlValByName(&m_bSneakAttack, "bSneakAttack");
	pXML->GetChildXmlValByName(&m_bUpdateSight, "bUpdateSight");
	pXML->GetChildXmlValByName(&m_iGlobalCounterFound, "iGlobalCounterFound");
	pXML->GetChildXmlValByName(&m_iGlobalCounterSpread, "iGlobalCounterSpread");
	pXML->GetChildXmlValByName(szTextVal, "Alignment");
	m_iAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AlignmentBest");
	m_iAlignmentBest = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "AlignmentWorst");
	m_iAlignmentWorst = pXML->FindInInfoClass(szTextVal);
//FfH: End Add

/*************************************************************************************************/
/**	BETTER AI (New Functions Definition) Sephi                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "ReligionHero1");
	m_eReligionHero1 = (UnitClassTypes)pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ReligionHero2");
	m_eReligionHero2 = (UnitClassTypes)pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ReligionTech1");
	m_eReligionTech1 = (TechTypes)pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ReligionTech2");
	m_eReligionTech2 = (TechTypes)pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(ReligionInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvReligionInfo::copyNonDefaults(CvReligionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (isHidden()							== false)			m_bHidden								= pClassInfo->isHidden();
	if (isSneakAttack()						== false)			m_bSneakAttack							= pClassInfo->isSneakAttack();
	if (isUpdateSight()						== false)			m_bUpdateSight							= pClassInfo->isUpdateSight();
	if (getNumFreeUnits()					== 0)				m_iNumFreeUnits							= pClassInfo->getNumFreeUnits();
	if (getSpreadFactor()					== 0)				m_iSpreadFactor							= pClassInfo->getSpreadFactor();
	if (getTGAIndex()						== 0)				m_iTGAIndex								= pClassInfo->getTGAIndex();
	if (getGlobalCounterFound()				== 0)				m_iGlobalCounterFound					= pClassInfo->getGlobalCounterFound();
	if (getGlobalCounterSpread()			== 0)				m_iGlobalCounterSpread					= pClassInfo->getGlobalCounterSpread();
	if (getTechButton()						== cDefault)		setTechButton(							pClassInfo->getTechButton());
	if (getGenericTechButton()				== cDefault)		setGenericTechButton(					pClassInfo->getGenericTechButton());
	if (getMovieFile()						== cDefault)		setMovieFile(							pClassInfo->getMovieFile());
	if (getMovieSound()						== cDefault)		setMovieSound(							pClassInfo->getMovieSound());
	if (getSound()							== cDefault)		setSound(								pClassInfo->getSound());
	if (getAdjectiveKey()					== wDefault)		setAdjectiveKey(CvString::format("%s",	pClassInfo->getAdjectiveKey()).GetCString());
	if (getTechPrereq()						== NO_TECH)			m_iTechPrereq							= pClassInfo->getTechPrereq();
	if (getFreeUnitClass()					== NO_UNITCLASS)	m_iFreeUnitClass						= pClassInfo->getFreeUnitClass();
	if (getAlignment()						== NO_ALIGNMENT)	m_iAlignment							= pClassInfo->getAlignment();
	if (getAlignmentBest()					== NO_ALIGNMENT)	m_iAlignmentBest						= pClassInfo->getAlignmentBest();
	if (getAlignmentWorst()					== NO_ALIGNMENT)	m_iAlignmentWorst						= pClassInfo->getAlignmentWorst();
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		if (getGlobalReligionCommerce(i)	== 0)				m_paiGlobalReligionCommerce[i]			= pClassInfo->getGlobalReligionCommerce(i);
		if (getHolyCityCommerce(i)			== 0)				m_paiHolyCityCommerce[i]				= pClassInfo->getHolyCityCommerce(i);
		if (getStateReligionCommerce(i)		== 0)				m_paiStateReligionCommerce[i]			= pClassInfo->getStateReligionCommerce(i);
	}

    if (getReligionHero1() == NO_UNITCLASS)                     m_eReligionHero1      = pClassInfo->getReligionHero1();
    if (getReligionHero2() == NO_UNITCLASS)                     m_eReligionHero2      = pClassInfo->getReligionHero2();
    if (getReligionTech1() == NO_TECH)                          m_eReligionTech1      = pClassInfo->getReligionTech1();
    if (getReligionTech2() == NO_TECH)                          m_eReligionTech2      = pClassInfo->getReligionTech2();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCorporationInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCorporationInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCorporationInfo::CvCorporationInfo() :
m_iChar(0),
/*************************************************************************************************/
/**	LoadedTGA               				05/15/08								        	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
m_iTGAIndex(-1),
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
m_iHeadquarterChar(0),
m_iTechPrereq(NO_TECH),
m_iFreeUnitClass(NO_UNITCLASS),
m_iSpreadFactor(0),
m_iSpreadCost(0),
m_iMaintenance(0),
m_iMissionType(NO_MISSION),
m_iBonusProduced(NO_BONUS),
m_paiPrereqBonuses(NULL),
m_paiHeadquarterCommerce(NULL),
m_paiCommerceProduced(NULL),
m_paiYieldProduced(NULL),
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
m_iBonusTrait(NO_TRAIT)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

{
	reset();
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCorporationInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCorporationInfo::~CvCorporationInfo()
{
	SAFE_DELETE_ARRAY(m_paiPrereqBonuses);
	SAFE_DELETE_ARRAY(m_paiHeadquarterCommerce);
	SAFE_DELETE_ARRAY(m_paiCommerceProduced);
	SAFE_DELETE_ARRAY(m_paiYieldProduced);
}

int CvCorporationInfo::getChar() const
{
	return m_iChar;
}

/*************************************************************************************************/
/**	LoadedTGA               				05/15/08								        	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
int CvCorporationInfo::getTGAIndex() const
{
	return m_iTGAIndex;
}

void CvCorporationInfo::setTGAIndex(int i)
{
	m_iTGAIndex = i;
}
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
void CvCorporationInfo::setChar(int i)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iChar = i;
/**								----  End Original Code  ----									**/
	m_iChar = 8550 + (GC.getDefineINT("GAMEFONT_TGA_RELIGIONS") + m_iTGAIndex) * 2;
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvCorporationInfo::getHeadquarterChar() const
{
	return m_iHeadquarterChar;
}

void CvCorporationInfo::setHeadquarterChar(int i)
{
/*************************************************************************************************/
/**	LoadedTGA								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iHeadquarterChar = i;
/**								----  End Original Code  ----									**/
	m_iHeadquarterChar = 8551 + (GC.getDefineINT("GAMEFONT_TGA_RELIGIONS") + m_iTGAIndex) * 2;
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/
}

int CvCorporationInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvCorporationInfo::getFreeUnitClass() const
{
	return m_iFreeUnitClass;
}

int CvCorporationInfo::getSpreadFactor() const
{
	return m_iSpreadFactor;
}

int CvCorporationInfo::getSpreadCost() const
{
	return m_iSpreadCost;
}

int CvCorporationInfo::getMaintenance() const
{
	return m_iMaintenance;
}

int CvCorporationInfo::getMissionType() const
{
	return m_iMissionType;
}

void CvCorporationInfo::setMissionType(int iNewType)
{
	m_iMissionType = iNewType;
}

int CvCorporationInfo::getBonusProduced() const
{
	return m_iBonusProduced;
}

const TCHAR* CvCorporationInfo::getMovieFile() const
{
	return m_szMovieFile;
}

void CvCorporationInfo::setMovieFile(const TCHAR* szVal)
{
	m_szMovieFile = szVal;
}

const TCHAR* CvCorporationInfo::getMovieSound() const
{
	return m_szMovieSound;
}

void CvCorporationInfo::setMovieSound(const TCHAR* szVal)
{
	m_szMovieSound = szVal;
}


const TCHAR* CvCorporationInfo::getSound() const
{
	return m_szSound;
}

void CvCorporationInfo::setSound(const TCHAR* szVal)
{
	m_szSound =szVal;
}

// Arrays

int CvCorporationInfo::getPrereqBonus(int i) const
{
	FAssertMsg(i < GC.getNUM_CORPORATION_PREREQ_BONUSES(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiPrereqBonuses[i];
}

int CvCorporationInfo::getHeadquarterCommerce(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiHeadquarterCommerce ? m_paiHeadquarterCommerce[i] : -1;
}

int* CvCorporationInfo::getHeadquarterCommerceArray() const
{
	return m_paiHeadquarterCommerce;
}

int CvCorporationInfo::getCommerceProduced(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiCommerceProduced ? m_paiCommerceProduced[i] : -1;
}

int* CvCorporationInfo::getCommerceProducedArray() const
{
	return m_paiCommerceProduced;
}

int CvCorporationInfo::getYieldProduced(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiYieldProduced ? m_paiYieldProduced[i] : -1;
}

int* CvCorporationInfo::getYieldProducedArray() const
{
	return m_paiYieldProduced;
}

/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvCorporationInfo::getBonusTrait() const
{
    return m_iBonusTrait;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

//
// read from xml
//
bool CvCorporationInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvHotkeyInfo::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "FreeUnitClass");
	m_iFreeUnitClass = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iSpreadFactor, "iSpreadFactor");
	pXML->GetChildXmlValByName(&m_iSpreadCost, "iSpreadCost");
	pXML->GetChildXmlValByName(&m_iMaintenance, "iMaintenance");
/*************************************************************************************************/
/**	LoadedTGA               				05/15/08								        	**/
/**																								**/
/**	Modifies how the TGA is handled to allow many more religions/corporations/resources easily	**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_iTGAIndex, "iTGAIndex");
/*************************************************************************************************/
/**	LoadedTGA								END													**/
/*************************************************************************************************/

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"HeadquarterCommerces"))
	{
		pXML->SetCommerce(&m_paiHeadquarterCommerce);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiHeadquarterCommerce, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommercesProduced"))
	{
		pXML->SetCommerce(&m_paiCommerceProduced);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiCommerceProduced, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldsProduced"))
	{
		pXML->SetYields(&m_paiYieldProduced);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiYieldProduced, NUM_YIELD_TYPES);
	}


	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqBonuses"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			FAssertMsg(0 < GC.getNUM_CORPORATION_PREREQ_BONUSES(),"Allocating zero or less memory in CvCorporationInfo::read");
			pXML->InitList(&m_paiPrereqBonuses, GC.getNUM_CORPORATION_PREREQ_BONUSES(), -1);

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					FAssertMsg((iNumSibs <= GC.getNUM_CORPORATION_PREREQ_BONUSES()) , "There are more siblings than memory allocated for them in CvCorporationInfo::read");
					for (int j=0; j<iNumSibs; ++j)
					{
						m_paiPrereqBonuses[j] = pXML->FindInInfoClass(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	else
	{
		pXML->InitList(&m_paiPrereqBonuses, GC.getNUM_CORPORATION_PREREQ_BONUSES(), -1);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "BonusProduced");
	m_iBonusProduced = pXML->FindInInfoClass(szTextVal);

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	pXML->GetChildXmlValByName(szTextVal, "MovieFile");
	setMovieFile(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieSound");
	setMovieSound(szTextVal);
/**								----  End Original Code  ----									**/
	pXML->GetChildXmlValByName(szTextVal, "MovieFile", "NONE");
	setMovieFile(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "MovieSound", "NONE");
	setMovieSound(szTextVal);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	pXML->GetChildXmlValByName(szTextVal, "Sound");
	setSound(szTextVal);

/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(szTextVal, "BonusTrait");
	m_iBonusTrait = pXML->FindInInfoClass(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCorporationInfo::copyNonDefaults(CvCorporationInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvHotkeyInfo::copyNonDefaults(pClassInfo, pXML);

	if (getTechPrereq()						== NO_TECH)			m_iTechPrereq				= pClassInfo->getTechPrereq();
	if (getFreeUnitClass()					== NO_UNITCLASS)	m_iFreeUnitClass			= pClassInfo->getFreeUnitClass();
	if (getSpreadFactor()					== 0)				m_iSpreadFactor				= pClassInfo->getSpreadFactor();
	if (getSpreadCost()						== 0)				m_iSpreadCost				= pClassInfo->getSpreadCost();
	if (getMaintenance()					== 0)				m_iMaintenance				= pClassInfo->getMaintenance();
	if (getTGAIndex()						== 0)				m_iTGAIndex					= pClassInfo->getTGAIndex();
	if (getBonusProduced()					== NO_BONUS)		m_iBonusProduced			= pClassInfo->getBonusProduced();
	if (getMovieFile()						== cDefault)		setMovieFile(				pClassInfo->getMovieFile());
	if (getMovieSound()						== cDefault)		setMovieSound(				pClassInfo->getMovieSound());
	if (getSound()							== cDefault)		setSound(					pClassInfo->getSound());
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if (m_paiHeadquarterCommerce[i]		== 0)				m_paiHeadquarterCommerce[i]	= pClassInfo->getHeadquarterCommerce(i);
		if (m_paiCommerceProduced[i]		== 0)				m_paiCommerceProduced[i]	= pClassInfo->getCommerceProduced(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_paiYieldProduced[i]			== 0)				m_paiYieldProduced[i]		= pClassInfo->getYieldProduced(i);
	}
	for ( int i = 0; i < GC.getNUM_CORPORATION_PREREQ_BONUSES(); i++ )
	{
		if (m_paiPrereqBonuses[i]			== NO_BONUS)		m_paiPrereqBonuses[i]		= pClassInfo->getPrereqBonus(i);
	}

/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    if (getBonusTrait()                     == NO_TRAIT)        m_iBonusTrait               = pClassInfo->getBonusTrait();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//======================================================================================================
//					CvTraitInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvTraitInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvTraitInfo::CvTraitInfo() :
m_iHealth(0),
m_iHappiness(0),
m_iMaxAnarchy(-1),
m_iUpkeepModifier(0),
m_iLevelExperienceModifier(0),
m_iGreatPeopleRateModifier(0),
m_iGreatGeneralRateModifier(0),
m_iDomesticGreatGeneralRateModifier(0),
m_iMaxGlobalBuildingProductionModifier(0),
m_iMaxTeamBuildingProductionModifier(0),
m_iMaxPlayerBuildingProductionModifier(0),

//FfH Trait: Added by Kael 08/02/2007
m_bAdaptive(false),
m_bIgnoreUnHealthFromImprovements(false),
m_bAgnostic(false),
m_bAssimilation(false),
m_bBarbarianAlly(false),
m_bIgnoreFood(false),
m_bInsane(false),
m_bSelectable(false),
m_bSprawling(false),
m_iFreeXPFromCombat(0),
m_iMaxCities(-1),
m_iPillagingGold(0),
m_iStartingGold(0),
m_iSummonCostReduction(0),
m_iTaxesModifier(0),
m_iFoodPerPopulationModifier(0),
m_iUpgradeCostModifier(0),
m_iProductionCostReductionCapitalBuilding(0),
m_iUnitSupportModifier(0),
m_iManaFromImprovement(0),
m_iManaFromImprovementType(NO_IMPROVEMENT),
m_iImprovementUpgradeRateModifier(0),
m_bCultureTrait(false),
m_iPrereqTrait(NO_TRAIT),
m_iExtraImprovementPerCity(0),
m_iExtraManaNodesPercent(0),
m_iReducedHurryCostBuilding(0),
m_iExtraSupportUnitLimit(0),
m_iExtraBuildingCapturedChance(0),

//FfH: End Add

m_paiExtraYieldThreshold(NULL),
m_paiTradeYieldModifier(NULL),
m_paiCommerceChange(NULL),
m_paiCommerceModifier(NULL),
m_pabFreePromotionUnitCombat(NULL),
m_pabFreePromotion(NULL),
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
 m_paiCorporationSupport(NULL),
 m_paiCorporationSupportMod(NULL),
 m_paiIgnoreBuildingGYCost(NULL)
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvTraitInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvTraitInfo::~CvTraitInfo()
{
	SAFE_DELETE_ARRAY(m_paiExtraYieldThreshold);
	SAFE_DELETE_ARRAY(m_paiTradeYieldModifier);
	SAFE_DELETE_ARRAY(m_paiCommerceChange);
	SAFE_DELETE_ARRAY(m_paiCommerceModifier);
	SAFE_DELETE_ARRAY(m_pabFreePromotionUnitCombat);
	SAFE_DELETE_ARRAY(m_pabFreePromotion);
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	SAFE_DELETE_ARRAY(m_paiCorporationSupport);
	SAFE_DELETE_ARRAY(m_paiCorporationSupportMod);
	SAFE_DELETE_ARRAY(m_paiIgnoreBuildingGYCost);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}

int CvTraitInfo::getHealth() const
{
	return m_iHealth;
}

int CvTraitInfo::getHappiness() const
{
	return m_iHappiness;
}

int CvTraitInfo::getMaxAnarchy() const
{
	return m_iMaxAnarchy;
}

int CvTraitInfo::getUpkeepModifier() const
{
	return m_iUpkeepModifier;
}

int CvTraitInfo::getLevelExperienceModifier() const
{
	return m_iLevelExperienceModifier;
}

int CvTraitInfo::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

int CvTraitInfo::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

int CvTraitInfo::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

int CvTraitInfo::getMaxGlobalBuildingProductionModifier() const
{
	return m_iMaxGlobalBuildingProductionModifier;
}

int CvTraitInfo::getMaxTeamBuildingProductionModifier() const
{
	return m_iMaxTeamBuildingProductionModifier;
}

int CvTraitInfo::getMaxPlayerBuildingProductionModifier() const
{
	return m_iMaxPlayerBuildingProductionModifier;
}

const TCHAR* CvTraitInfo::getShortDescription() const
{
	return m_szShortDescription;
}

void CvTraitInfo::setShortDescription(const TCHAR* szVal)
{
	m_szShortDescription = szVal;
}

//FfH Traits: Added by Kael 08/02/2007
bool CvTraitInfo::isAdaptive() const
{
	return m_bAdaptive;
}

bool CvTraitInfo::isIgnoreUnHealthFromImprovements() const
{
	return m_bIgnoreUnHealthFromImprovements;
}

bool CvTraitInfo::isAgnostic() const
{
	return m_bAgnostic;
}

bool CvTraitInfo::isAssimilation() const
{
	return m_bAssimilation;
}

bool CvTraitInfo::isBarbarianAlly() const
{
	return m_bBarbarianAlly;
}

bool CvTraitInfo::isIgnoreFood() const
{
	return m_bIgnoreFood;
}

bool CvTraitInfo::isInsane() const
{
	return m_bInsane;
}

bool CvTraitInfo::isSelectable() const
{
	return m_bSelectable;
}

bool CvTraitInfo::isSprawling() const
{
	return m_bSprawling;
}

int CvTraitInfo::getFreeXPFromCombat() const
{
	return m_iFreeXPFromCombat;
}

int CvTraitInfo::getMaxCities() const
{
	return m_iMaxCities;
}

int CvTraitInfo::getPillagingGold() const
{
	return m_iPillagingGold;
}

int CvTraitInfo::getStartingGold() const
{
	return m_iStartingGold;
}

int CvTraitInfo::getSummonCostReduction() const
{
	return m_iSummonCostReduction;
}

int CvTraitInfo::getTaxesModifier() const
{
	return m_iTaxesModifier;
}

int CvTraitInfo::getFoodPerPopulationModifier() const
{
	return m_iFoodPerPopulationModifier;
}

int CvTraitInfo::getUpgradeCostModifier() const
{
	return m_iUpgradeCostModifier;
}

int CvTraitInfo::getProductionCostReductionCapitalBuilding() const
{
	return m_iProductionCostReductionCapitalBuilding;
}
int CvTraitInfo::getUnitSupportModifier() const
{
	return m_iUnitSupportModifier;
}
//FfH: End Add

int CvTraitInfo::getManaFromImprovement() const
{
	return m_iManaFromImprovement;
}

int CvTraitInfo::getManaFromImprovementType() const
{
	return m_iManaFromImprovementType;
}

int CvTraitInfo::getImprovementUpgradeRateModifier() const
{
	return m_iImprovementUpgradeRateModifier;
}

bool CvTraitInfo::isCultureTrait() const
{
	return m_bCultureTrait;
}

int CvTraitInfo::getPrereqTrait() const
{
	return m_iPrereqTrait;
}

int CvTraitInfo::getExtraImprovementPerCity() const { return m_iExtraImprovementPerCity; }
int CvTraitInfo::getExtraManaNodesPercent() const { return m_iExtraManaNodesPercent; }
int CvTraitInfo::getReducedHurryCostBuilding() const { return m_iReducedHurryCostBuilding; }
int CvTraitInfo::getExtraSupportUnitLimit() const { return m_iExtraSupportUnitLimit; }
int CvTraitInfo::getExtraBuildingCapturedChance() const { return m_iExtraBuildingCapturedChance; }

// Arrays

int CvTraitInfo::getExtraYieldThreshold(int i) const
{
	return m_paiExtraYieldThreshold ? m_paiExtraYieldThreshold[i] : -1;
}

int CvTraitInfo::getTradeYieldModifier(int i) const
{
	return m_paiTradeYieldModifier ? m_paiTradeYieldModifier[i] : -1;
}

int CvTraitInfo::getCommerceChange(int i) const
{
	return m_paiCommerceChange ? m_paiCommerceChange[i] : -1;
}

int CvTraitInfo::getCommerceModifier(int i) const
{
	return m_paiCommerceModifier ? m_paiCommerceModifier[i] : -1;
}

int CvTraitInfo::isFreePromotion(int i) const
{
	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;
}

int CvTraitInfo::isFreePromotionUnitCombat(int i) const
{
	return m_pabFreePromotionUnitCombat ? m_pabFreePromotionUnitCombat[i] : -1;
}

/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
const TCHAR *CvTraitInfo::getPyPerTurn() const
{
	return m_szTraitPyPerTurn;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
int CvTraitInfo::getCorporationSupport(int iCorporation) const
{
	return m_paiCorporationSupport[iCorporation];
}

int CvTraitInfo::getCorporationSupportMultiplier(int iCorporation) const
{
	return m_paiCorporationSupportMod[iCorporation];
}

bool CvTraitInfo::isIgnoreBuildingGYCost(int iCorporation) const
{
	return m_paiIgnoreBuildingGYCost[iCorporation];
}

int CvTraitInfo::getCorporationSupportVectorSize()					{return m_aszCorporationSupportforPass3.size();}
CvString CvTraitInfo::getCorporationSupportNamesVectorElement(int i)	{return m_aszCorporationSupportforPass3[i];}
int CvTraitInfo::getCorporationSupportValuesVectorElement(int i)		{return m_aiCorporationSupportforPass3[i];}

int CvTraitInfo::getCorporationSupportModVectorSize()					{return m_aszCorporationSupportModforPass3.size();}
CvString CvTraitInfo::getCorporationSupportModNamesVectorElement(int i)	{return m_aszCorporationSupportModforPass3[i];}
int CvTraitInfo::getCorporationSupportModValuesVectorElement(int i)		{return m_aiCorporationSupportModforPass3[i];}

int CvTraitInfo::getIgnoreBuildingGYCostVectorSize()					{return m_aszIgnoreBuildingGYCostforPass3.size();}
CvString CvTraitInfo::getIgnoreBuildingGYCostNamesVectorElement(int i)	{return m_aszIgnoreBuildingGYCostforPass3[i];}
int CvTraitInfo::getIgnoreBuildingGYCostValuesVectorElement(int i)		{return m_aiIgnoreBuildingGYCostforPass3[i];}

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
bool CvTraitInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ShortDescription");
	setShortDescription(szTextVal);

	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHappiness, "iHappiness");
	pXML->GetChildXmlValByName(&m_iMaxAnarchy, "iMaxAnarchy", -1);
	pXML->GetChildXmlValByName(&m_iUpkeepModifier, "iUpkeepModifier");
	pXML->GetChildXmlValByName(&m_iLevelExperienceModifier, "iLevelExperienceModifier");
	pXML->GetChildXmlValByName(&m_iGreatPeopleRateModifier, "iGreatPeopleRateModifier");
	pXML->GetChildXmlValByName(&m_iGreatGeneralRateModifier, "iGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iDomesticGreatGeneralRateModifier, "iDomesticGreatGeneralRateModifier");
	pXML->GetChildXmlValByName(&m_iMaxGlobalBuildingProductionModifier, "iMaxGlobalBuildingProductionModifier");
	pXML->GetChildXmlValByName(&m_iMaxTeamBuildingProductionModifier, "iMaxTeamBuildingProductionModifier");
	pXML->GetChildXmlValByName(&m_iMaxPlayerBuildingProductionModifier, "iMaxPlayerBuildingProductionModifier");

//FfH Traits: Added by Kael 08/02/2007
	pXML->GetChildXmlValByName(&m_bAdaptive, "bAdaptive");
	pXML->GetChildXmlValByName(&m_bIgnoreUnHealthFromImprovements, "bIgnoreUnHealthFromImprovements");
	pXML->GetChildXmlValByName(&m_bAgnostic, "bAgnostic");
	pXML->GetChildXmlValByName(&m_bAssimilation, "bAssimilation");
	pXML->GetChildXmlValByName(&m_bBarbarianAlly, "bBarbarianAlly");
	pXML->GetChildXmlValByName(&m_bIgnoreFood, "bIgnoreFood");
	pXML->GetChildXmlValByName(&m_bInsane, "bInsane");
	pXML->GetChildXmlValByName(&m_bSelectable, "bSelectable");
	pXML->GetChildXmlValByName(&m_bSprawling, "bSprawling");
	pXML->GetChildXmlValByName(&m_iFreeXPFromCombat, "iFreeXPFromCombat");
	pXML->GetChildXmlValByName(&m_iMaxCities, "iMaxCities", -1);
	pXML->GetChildXmlValByName(&m_iPillagingGold, "iPillagingGold");
	pXML->GetChildXmlValByName(&m_iStartingGold, "iStartingGold");
	pXML->GetChildXmlValByName(&m_iSummonCostReduction, "iSummonCostReduction");
	pXML->GetChildXmlValByName(&m_iTaxesModifier, "iTaxesModifier");
	pXML->GetChildXmlValByName(&m_iFoodPerPopulationModifier, "iFoodPerPopulationModifier");
	pXML->GetChildXmlValByName(&m_iUpgradeCostModifier, "iUpgradeCostModifier");
	pXML->GetChildXmlValByName(&m_iProductionCostReductionCapitalBuilding, "iProductionCostReductionCapitalBuilding");
	pXML->GetChildXmlValByName(&m_iUnitSupportModifier, "iUnitSupportModifier");
//FfH: End Add
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    pXML->GetChildXmlValByName(m_szTraitPyPerTurn,"PyPerTurn");
	pXML->GetChildXmlValByName(&m_iManaFromImprovement, "iManaFromImprovement");
	pXML->GetChildXmlValByName(szTextVal, "ManaFromImprovementType");
	m_iManaFromImprovementType = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iImprovementUpgradeRateModifier, "iImprovementUpgradeRateModifier");	
	pXML->GetChildXmlValByName(&m_bCultureTrait, "bCultureTrait");	
	pXML->GetChildXmlValByName(&m_iExtraImprovementPerCity, "iExtraImprovementPerCity");	
	pXML->GetChildXmlValByName(&m_iExtraManaNodesPercent, "iExtraManaNodesPercent");	
	pXML->GetChildXmlValByName(&m_iReducedHurryCostBuilding, "iReducedHurryCostBuilding");	
	pXML->GetChildXmlValByName(&m_iExtraSupportUnitLimit, "iExtraSupportUnitLimit");	
	pXML->GetChildXmlValByName(&m_iExtraBuildingCapturedChance, "iExtraBuildingCapturedChance");	

	pXML->GetChildXmlValByName(szTextVal, "PrereqTrait");
	m_aszExtraXMLforPass3.push_back(szTextVal);
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ExtraYieldThresholds"))
	{
		pXML->SetYields(&m_paiExtraYieldThreshold);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiExtraYieldThreshold, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TradeYieldModifiers"))
	{
		pXML->SetYields(&m_paiTradeYieldModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiTradeYieldModifier, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceChanges"))
	{
		pXML->SetCommerce(&m_paiCommerceChange);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiCommerceChange, NUM_COMMERCE_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "CommerceModifiers"))
	{
		pXML->SetCommerce(&m_paiCommerceModifier);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_paiCommerceModifier, NUM_COMMERCE_TYPES);
	}

	pXML->SetVariableListTagPair(&m_pabFreePromotion, "FreePromotions", sizeof(GC.getPromotionInfo((PromotionTypes)0)), GC.getNumPromotionInfos());

	pXML->SetVariableListTagPair(&m_pabFreePromotionUnitCombat, "FreePromotionUnitCombats", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos());
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationSupportValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCorporationSupportforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiCorporationSupportforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationSupportModifierValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszCorporationSupportModforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiCorporationSupportModforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"IgnoreBuildingGYCostValues"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			int iTemp = 0;
			if (iNumSibs > 0)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int i=0;i<iNumSibs;i++)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
                            m_aszIgnoreBuildingGYCostforPass3.push_back(szTextVal);
                            pXML->GetNextXmlVal(&iTemp);
                            m_aiIgnoreBuildingGYCostforPass3.push_back(iTemp);
							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}

/*************************************************************************************************/
/**	ADDON (TraitInfo Readpass3) Sephi		                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
bool CvTraitInfo::readPass3()
{
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iPrereqTrait = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
    m_aszExtraXMLforPass3.clear();

/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    m_paiCorporationSupport = new int[GC.getNumCorporationInfos()];
    for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
        m_paiCorporationSupport[iI] = 0;
	}
    int iNumLoad = m_aiCorporationSupportforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCorporationSupportforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_paiCorporationSupport[GC.getInfoTypeForString(m_aszCorporationSupportforPass3[iI])] += m_aiCorporationSupportforPass3[iI];
	}
    m_aszCorporationSupportforPass3.clear();
    m_aiCorporationSupportforPass3.clear();


    m_paiCorporationSupportMod = new int[GC.getNumCorporationInfos()];
    for (int iI = 0; iI < GC.getNumCorporationInfos(); iI++)
	{
        m_paiCorporationSupportMod[iI] = 0;
	}
    iNumLoad = m_aiCorporationSupportModforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszCorporationSupportModforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_paiCorporationSupportMod[GC.getInfoTypeForString(m_aszCorporationSupportModforPass3[iI])] += m_aiCorporationSupportModforPass3[iI];
	}
    m_aszCorporationSupportModforPass3.clear();
    m_aiCorporationSupportModforPass3.clear();

    m_paiIgnoreBuildingGYCost = new bool[GC.getNumBuildingClassInfos()];
    for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
        m_paiIgnoreBuildingGYCost[iI] = 0;
	}
    iNumLoad = m_aiIgnoreBuildingGYCostforPass3.size();
	for(iI = 0; iI < iNumLoad; iI++)
	{
		FAssertMsg(GC.getInfoTypeForString(m_aszIgnoreBuildingGYCostforPass3[iI]) >= 0, "Warning, about to leak memory in CvPromotionInfo::readPass3");
		m_paiIgnoreBuildingGYCost[GC.getInfoTypeForString(m_aszIgnoreBuildingGYCostforPass3[iI])] = m_aiIgnoreBuildingGYCostforPass3[iI];
	}
    m_aszIgnoreBuildingGYCostforPass3.clear();
    m_aiIgnoreBuildingGYCostforPass3.clear();
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	return true;
}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(TraitInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTraitInfo::copyNonDefaults(CvTraitInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isAdaptive()								== false)		m_bAdaptive								= pClassInfo->isAdaptive();
	if (isIgnoreUnHealthFromImprovements()			== false)		m_bIgnoreUnHealthFromImprovements		= pClassInfo->isIgnoreUnHealthFromImprovements();
	if (isAgnostic()								== false)		m_bAgnostic								= pClassInfo->isAgnostic();
	if (isAssimilation()							== false)		m_bAssimilation							= pClassInfo->isAssimilation();
	if (isBarbarianAlly()							== false)		m_bBarbarianAlly						= pClassInfo->isBarbarianAlly();
	if (isIgnoreFood()								== false)		m_bIgnoreFood							= pClassInfo->isIgnoreFood();
	if (isInsane()									== false)		m_bInsane								= pClassInfo->isInsane();
	if (isSelectable()								== false)		m_bSelectable							= pClassInfo->isSelectable();
	if (isSprawling()								== false)		m_bSprawling							= pClassInfo->isSprawling();
	if (getFreeXPFromCombat()						== 0)			m_iFreeXPFromCombat						= pClassInfo->getFreeXPFromCombat();
	if (getMaxCities()								== -1)			m_iMaxCities							= pClassInfo->getMaxCities();
	if (getPillagingGold()							== 0)			m_iPillagingGold						= pClassInfo->getPillagingGold();
	if (getStartingGold()							== 0)			m_iStartingGold							= pClassInfo->getStartingGold();
	if (getSummonCostReduction()					== 0)			m_iSummonCostReduction					= pClassInfo->getSummonCostReduction();
	if (getTaxesModifier()							== 0)			m_iTaxesModifier						= pClassInfo->getTaxesModifier();
	if (getFoodPerPopulationModifier()				== 0)			m_iFoodPerPopulationModifier			= pClassInfo->getFoodPerPopulationModifier();
	if (getUpgradeCostModifier()					== 0)			m_iUpgradeCostModifier					= pClassInfo->getUpgradeCostModifier();
	if (getProductionCostReductionCapitalBuilding()	== 0)			m_iProductionCostReductionCapitalBuilding	= pClassInfo->getProductionCostReductionCapitalBuilding();
	if (getUnitSupportModifier()					== 0)			m_iUnitSupportModifier					= pClassInfo->getUnitSupportModifier();
	if (getHealth()									== 0)			m_iHealth								= pClassInfo->getHealth();
	if (getHappiness()								== 0)			m_iHappiness							= pClassInfo->getHappiness();
	if (getMaxAnarchy()								== -1)			m_iMaxAnarchy							= pClassInfo->getMaxAnarchy();
	if (getUpkeepModifier()							== 0)			m_iUpkeepModifier						= pClassInfo->getUpkeepModifier();
	if (getLevelExperienceModifier()				== 0)			m_iLevelExperienceModifier				= pClassInfo->getLevelExperienceModifier();
	if (getGreatPeopleRateModifier()				== 0)			m_iGreatPeopleRateModifier				= pClassInfo->getGreatPeopleRateModifier();
	if (getGreatGeneralRateModifier()				== 0)			m_iGreatGeneralRateModifier				= pClassInfo->getGreatGeneralRateModifier();
	if (getDomesticGreatGeneralRateModifier()		== 0)			m_iDomesticGreatGeneralRateModifier		= pClassInfo->getDomesticGreatGeneralRateModifier();
	if (getMaxGlobalBuildingProductionModifier()	== 0)			m_iMaxGlobalBuildingProductionModifier	= pClassInfo->getMaxGlobalBuildingProductionModifier();
	if (getMaxTeamBuildingProductionModifier()		== 0)			m_iMaxTeamBuildingProductionModifier	= pClassInfo->getMaxTeamBuildingProductionModifier();
	if (getMaxPlayerBuildingProductionModifier()	== 0)			m_iMaxPlayerBuildingProductionModifier	= pClassInfo->getMaxPlayerBuildingProductionModifier();
	if (getShortDescription()						== cDefault)	setShortDescription(					pClassInfo->getShortDescription());
	for (int j = 0; j < NUM_YIELD_TYPES; j++ )
	{
		if (getExtraYieldThreshold(j)				== 0)			m_paiExtraYieldThreshold[j]				= pClassInfo->getExtraYieldThreshold(j);
		if (getTradeYieldModifier(j)				== 0)			m_paiTradeYieldModifier[j]				= pClassInfo->getTradeYieldModifier(j);
	}
	for ( int j = 0; j < NUM_COMMERCE_TYPES; j++ )
	{
		if (getCommerceChange(j)					== 0)			m_paiCommerceChange[j]					= pClassInfo->getCommerceChange(j);
		if (getCommerceModifier(j)					== 0)			m_paiCommerceModifier[j]				= pClassInfo->getCommerceModifier(j);
	}
	for ( int j = 0; j < GC.getNumPromotionInfos(); j++ )
	{
		if (isFreePromotion(j)						== false)		m_pabFreePromotion[j]					= pClassInfo->isFreePromotion(j);
	}
	for ( int j = 0; j < GC.getNumUnitCombatInfos(); j++ )
	{
		if (isFreePromotionUnitCombat(j)			== false)		m_pabFreePromotionUnitCombat[j]			= pClassInfo->isFreePromotionUnitCombat(j);
	}
/*************************************************************************************************/
/**	ADDON (New Functions Definition) Sephi                                     					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
    if (getPyPerTurn() == cDefault) m_szTraitPyPerTurn = pClassInfo->getPyPerTurn();
	if (getManaFromImprovement()					== 0)			m_iManaFromImprovement					= pClassInfo->getManaFromImprovement();
	if (getManaFromImprovementType()	== NO_IMPROVEMENT)			m_iManaFromImprovementType				= pClassInfo->getManaFromImprovementType();
	if (getImprovementUpgradeRateModifier()			== 0)			m_iImprovementUpgradeRateModifier		= pClassInfo->getImprovementUpgradeRateModifier();
	if (isCultureTrait()							== false)		m_bCultureTrait							= pClassInfo->isCultureTrait();
	if (getPrereqTrait()							== NO_TRAIT)	m_iPrereqTrait							= pClassInfo->getPrereqTrait();
	if (getExtraImprovementPerCity()				== 0)  			m_iExtraImprovementPerCity				= pClassInfo->getExtraImprovementPerCity();            
	if (getExtraManaNodesPercent()					== 0)			m_iExtraManaNodesPercent				= pClassInfo->getExtraManaNodesPercent();
	if (getReducedHurryCostBuilding()				== 0)			m_iReducedHurryCostBuilding				= pClassInfo->getReducedHurryCostBuilding();
	if (getExtraSupportUnitLimit() 					== 0)			m_iExtraSupportUnitLimit				= pClassInfo->getExtraSupportUnitLimit();
	if (getExtraBuildingCapturedChance()			== 0)			m_iExtraBuildingCapturedChance			= pClassInfo->getExtraBuildingCapturedChance();

/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
	//readpass3
/*************************************************************************************************/
/**	ADDON (Houses of Erebus) Sephi			                                 					**/
/**																								**/
/**						                                            							**/
/*************************************************************************************************/
	for ( int i = 0; i < pClassInfo->getCorporationSupportVectorSize(); i++ )
	{
		m_aszCorporationSupportforPass3.push_back(	pClassInfo->getCorporationSupportNamesVectorElement(i));
		m_aiCorporationSupportforPass3.push_back(	pClassInfo->getCorporationSupportValuesVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getCorporationSupportModVectorSize(); i++ )
	{
		m_aszCorporationSupportModforPass3.push_back(	pClassInfo->getCorporationSupportModNamesVectorElement(i));
		m_aiCorporationSupportModforPass3.push_back(	pClassInfo->getCorporationSupportModValuesVectorElement(i));
	}

	for ( int i = 0; i < pClassInfo->getIgnoreBuildingGYCostVectorSize(); i++ )
	{
		m_aszIgnoreBuildingGYCostforPass3.push_back(pClassInfo->getIgnoreBuildingGYCostNamesVectorElement(i));
		m_aiIgnoreBuildingGYCostforPass3.push_back(pClassInfo->getIgnoreBuildingGYCostValuesVectorElement(i));
	}
/*************************************************************************************************/
/**	END	                                        												**/
/*************************************************************************************************/
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvCursorInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvCursorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvCursorInfo::CvCursorInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvCursorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvCursorInfo::~CvCursorInfo()
{
}

const TCHAR* CvCursorInfo::getPath()
{
	return m_szPath;
}

void CvCursorInfo::setPath(const TCHAR* szVal)
{
	m_szPath = szVal;
}

bool CvCursorInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "CursorPath");
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCursorInfo::copyNonDefaults(CvCursorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvThroneRoomCamera
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvThroneRoomCamera()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomCamera::CvThroneRoomCamera()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvThroneRoomCamera()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomCamera::~CvThroneRoomCamera()
{
}

const TCHAR* CvThroneRoomCamera::getFileName()
{
	return m_szFileName;
}

void CvThroneRoomCamera::setFileName(const TCHAR* szVal)
{
	m_szFileName = szVal;
}

bool CvThroneRoomCamera::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "FileName");
	setFileName(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvThroneRoomCamera::copyNonDefaults(CvThroneRoomCamera* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getFileName()		== cDefault)		setFileName(		pClassInfo->getFileName());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvThroneRoomInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvThroneRoomInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomInfo::CvThroneRoomInfo() :
m_iFromState(0),
m_iToState(0),
m_iAnimation(0)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvThroneRoomInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomInfo::~CvThroneRoomInfo()
{
}

const TCHAR* CvThroneRoomInfo::getEvent()
{
	return m_szEvent;
}

void CvThroneRoomInfo::setEvent(const TCHAR* szVal)
{
	m_szEvent = szVal;
}

const TCHAR* CvThroneRoomInfo::getNodeName()
{
	return m_szNodeName;
}

void CvThroneRoomInfo::setNodeName(const TCHAR* szVal)
{
	m_szNodeName = szVal;
}

int CvThroneRoomInfo::getFromState()
{
	return m_iFromState;
}

void CvThroneRoomInfo::setFromState(int iVal)
{
	m_iFromState = iVal;
}

int CvThroneRoomInfo::getToState()
{
	return m_iToState;
}

void CvThroneRoomInfo::setToState(int iVal)
{
	m_iToState = iVal;
}

int CvThroneRoomInfo::getAnimation()
{
	return m_iAnimation;
}

void CvThroneRoomInfo::setAnimation(int iVal)
{
	m_iAnimation= iVal;
}

bool CvThroneRoomInfo::read(CvXMLLoadUtility* pXML)
{
	int iVal;
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Event");
	setEvent(szTextVal);
	pXML->GetChildXmlValByName(&iVal, "iFromState" );
	setFromState(iVal);
	pXML->GetChildXmlValByName(&iVal, "iToState" );
	setToState(iVal);
	pXML->GetChildXmlValByName(szTextVal, "NodeName");
	setNodeName(szTextVal);
	pXML->GetChildXmlValByName(&iVal, "iAnimation" );
	setAnimation(iVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvThroneRoomInfo::copyNonDefaults(CvThroneRoomInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getEvent()		== cDefault)	setEvent(			pClassInfo->getEvent());
	if (getNodeName()	== cDefault)	setNodeName(		pClassInfo->getNodeName());
	if (getFromState()	== 0)			setFromState(		pClassInfo->getFromState());
	if (getToState()	== 0)			setToState(			pClassInfo->getToState());
	if (getAnimation()	== 0)			setAnimation(		pClassInfo->getAnimation());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvThroneRoomStyleInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvThroneRoomStyleInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomStyleInfo::CvThroneRoomStyleInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvThroneRoomStyleInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvThroneRoomStyleInfo::~CvThroneRoomStyleInfo()
{
}

const TCHAR* CvThroneRoomStyleInfo::getArtStyleType()
{
	return m_szArtStyleType;
}

void CvThroneRoomStyleInfo::setArtStyleType(const TCHAR* szVal)
{
	m_szArtStyleType = szVal;
}

const TCHAR* CvThroneRoomStyleInfo::getEraType()
{
	return m_szEraType;
}

void CvThroneRoomStyleInfo::setEraType(const TCHAR* szVal)
{
	m_szEraType = szVal;
}

const TCHAR* CvThroneRoomStyleInfo::getFileName()
{
	return m_szFileName;
}

void CvThroneRoomStyleInfo::setFileName(const TCHAR* szVal)
{
	m_szFileName = szVal;
}

bool CvThroneRoomStyleInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ArtStyleType");
	setArtStyleType(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "EraType");
	setEraType(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "FileName");
	setFileName(szTextVal);

	//node names
	if(gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
	{
		while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "NodeName"))
		{
			pXML->GetXmlVal(szTextVal);
			m_aNodeNames.push_back(szTextVal);
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//texture names
	if(gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
	{
		while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "TextureName"))
		{
			pXML->GetXmlVal(szTextVal);
			m_aTextureNames.push_back(szTextVal);
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvThroneRoomStyleInfo::copyNonDefaults(CvThroneRoomStyleInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getArtStyleType()	== cDefault)	setArtStyleType(	pClassInfo->getArtStyleType());
	if (getEraType()		== cDefault)	setEraType(			pClassInfo->getEraType());
	if (getFileName()		== cDefault)	setFileName(		pClassInfo->getFileName());

	/*
	m_aNodeNames and m_aTextureNames don't seem to be used?
	since I hardly doubt anyone ever touches those XML's anyway, I'll just leave them out
	FOR NOW! */
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSlideShowInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSlideShowInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowInfo::CvSlideShowInfo() :
m_fStartTime(0.0f)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSlideShowInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowInfo::~CvSlideShowInfo()
{
}

const TCHAR* CvSlideShowInfo::getPath()
{
	return m_szPath;
}

void CvSlideShowInfo::setPath(const TCHAR* szVal)
{
	m_szPath = szVal;
}

const TCHAR* CvSlideShowInfo::getTransitionType()
{
	return m_szTransitionType;
}

void CvSlideShowInfo::setTransitionType(const TCHAR* szVal)
{
	m_szTransitionType = szVal;
}

float CvSlideShowInfo::getStartTime()
{
	return m_fStartTime;
}

void CvSlideShowInfo::setStartTime(float fVal)
{
	m_fStartTime = fVal;
}

bool CvSlideShowInfo::read(CvXMLLoadUtility* pXML)
{
	float fVal;
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "TransitionType");
	setTransitionType(szTextVal);
	pXML->GetChildXmlValByName(&fVal, "fStartTime");
	setStartTime(fVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSlideShowInfo::copyNonDefaults(CvSlideShowInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPath()				== cDefault)	setPath(				pClassInfo->getPath());
	if (getTransitionType()		== cDefault)	setTransitionType(		pClassInfo->getTransitionType());
	if (getStartTime()			== 0.0f)		setStartTime(			pClassInfo->getStartTime());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSlideShowRandomInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSlideShowRandomInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowRandomInfo::CvSlideShowRandomInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSlideShowRandomInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSlideShowRandomInfo::~CvSlideShowRandomInfo()
{
}

const TCHAR* CvSlideShowRandomInfo::getPath()
{
	return m_szPath;
}

void CvSlideShowRandomInfo::setPath(const TCHAR* szVal)
{
	m_szPath = szVal;
}

bool CvSlideShowRandomInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSlideShowRandomInfo::copyNonDefaults(CvSlideShowRandomInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvWorldPickerInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvWorldPickerInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvWorldPickerInfo::CvWorldPickerInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvWorldPickerInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvWorldPickerInfo::~CvWorldPickerInfo()
{
}

const TCHAR* CvWorldPickerInfo::getMapName()
{
	return m_szMapName;
}

void CvWorldPickerInfo::setMapName(const TCHAR* szVal)
{
	m_szMapName = szVal;
}

const TCHAR* CvWorldPickerInfo::getModelFile()
{
	return m_szModelFile;
}

void CvWorldPickerInfo::setModelFile(const TCHAR* szVal)
{
	m_szModelFile = szVal;
}

int CvWorldPickerInfo::getNumSizes()
{
	return m_aSizes.size();
}

float CvWorldPickerInfo::getSize(int index)
{
	return m_aSizes[index];
}

int CvWorldPickerInfo::getNumClimates()
{
	return m_aClimates.size();
}

const TCHAR* CvWorldPickerInfo::getClimatePath(int index)
{
	return m_aClimates[index];
}

int CvWorldPickerInfo::getNumWaterLevelDecals()
{
	return m_aWaterLevelDecals.size();
}

const TCHAR* CvWorldPickerInfo::getWaterLevelDecalPath(int index)
{
	return m_aWaterLevelDecals[index];
}

int CvWorldPickerInfo::getNumWaterLevelGloss()
{
	return m_aWaterLevelGloss.size();
}

const TCHAR* CvWorldPickerInfo::getWaterLevelGlossPath(int index)
{
	return m_aWaterLevelGloss[index];
}

bool CvWorldPickerInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	float fVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "MapName");
	setMapName(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ModelFile");
	setModelFile(szTextVal);

	//sizes
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Sizes"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Size"))
		{
			do
			{
				pXML->GetXmlVal(&fVal);
				m_aSizes.push_back(fVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "Size"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//climates
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "Climates"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "ClimatePath"))
		{
			do
			{
				pXML->GetXmlVal(szTextVal);
				m_aClimates.push_back(szTextVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "ClimatePath"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//water level decals
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelDecals"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelDecalPath"))
		{
			do
			{
				pXML->GetXmlVal(szTextVal);
				m_aWaterLevelDecals.push_back(szTextVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "WaterLevelDecalPath"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	//water level gloss
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelGloss"))
	{
		if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "WaterLevelGlossPath"))
		{
			do
			{
				pXML->GetXmlVal(szTextVal);
				m_aWaterLevelGloss.push_back(szTextVal);
			} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "WaterLevelGlossPath"));

			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvWorldPickerInfo::copyNonDefaults(CvWorldPickerInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getMapName()		== cDefault)		setMapName(							pClassInfo->getMapName());
	if (getModelFile()		== cDefault)		setModelFile(						pClassInfo->getModelFile());
	if (getNumSizes()		== 0)
	{
		for ( int i = 0; i < pClassInfo->getNumSizes(); i++ )
		{
												m_aSizes.push_back(					pClassInfo->getSize(i));
		}
	}

	if (getNumClimates() == 0)
	{
		for ( int i = 0; i < pClassInfo->getNumClimates(); i++ )
		{
												m_aClimates.push_back(				pClassInfo->getClimatePath(i));
		}
	}

	if (getNumWaterLevelDecals() == 0)
	{
		for ( int i = 0; i < pClassInfo->getNumWaterLevelDecals(); i++ )
		{
												m_aWaterLevelDecals.push_back(		pClassInfo->getWaterLevelDecalPath(i));
		}
	}
	if (getNumWaterLevelGloss() == 0)
	{
		for ( int i = 0; i < pClassInfo->getNumWaterLevelGloss(); i++ )
		{
												m_aWaterLevelDecals.push_back(		pClassInfo->getWaterLevelGlossPath(i));
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvSpaceShipInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvSpaceShipInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvSpaceShipInfo::CvSpaceShipInfo() :
m_eSpaceShipInfoType(SPACE_SHIP_INFO_TYPE_NONE),
m_iPartNumber(-1),
m_iArtType(-1),
m_iEventCode(-1),
m_eProjectType(NO_PROJECT),
m_eCameraUpAxis(AXIS_X)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvSpaceShipInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvSpaceShipInfo::~CvSpaceShipInfo()
{
}

const TCHAR* CvSpaceShipInfo::getNodeName()
{
	return m_szNodeName;
}

void CvSpaceShipInfo::setNodeName(const TCHAR* szVal)
{
	m_szNodeName = szVal;
}

const TCHAR* CvSpaceShipInfo::getProjectName()
{
	return m_szProjectName;
}

void CvSpaceShipInfo::setProjectName(const TCHAR* szVal)
{
	m_szProjectName = szVal;
	m_eProjectType = (ProjectTypes) GC.getInfoTypeForString(m_szProjectName, true);
}

ProjectTypes CvSpaceShipInfo::getProjectType()
{
	return m_eProjectType;
}

AxisTypes CvSpaceShipInfo::getCameraUpAxis()
{
	return m_eCameraUpAxis;
}

SpaceShipInfoTypes CvSpaceShipInfo::getSpaceShipInfoType()
{
	return m_eSpaceShipInfoType;
}

int CvSpaceShipInfo::getPartNumber()
{
	return m_iPartNumber;
}

int CvSpaceShipInfo::getArtType()
{
	return m_iArtType;
}

int CvSpaceShipInfo::getEventCode()
{
	return m_iEventCode;
}

bool CvSpaceShipInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "NodeName");
	setNodeName(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "ProjectName");
	setProjectName(szTextVal);

	//up axis
	pXML->GetChildXmlValByName(szTextVal, "CameraUpAxis");
	if(szTextVal.CompareNoCase("AXIS_X") == 0)
		m_eCameraUpAxis = AXIS_X;
	else if(szTextVal.CompareNoCase("AXIS_Y") == 0)
		m_eCameraUpAxis = AXIS_Y;
	else if(szTextVal.CompareNoCase("AXIS_Z") == 0)
		m_eCameraUpAxis = AXIS_Z;
	else
	{
		FAssertMsg(false, "[Jason] Unknown Axis Type.");
	}

	pXML->GetChildXmlValByName(&m_iPartNumber, "PartNumber");
	pXML->GetChildXmlValByName(&m_iArtType, "ArtType");
	pXML->GetChildXmlValByName(&m_iEventCode, "EventCode");

	//type
	pXML->GetChildXmlValByName(szTextVal, "InfoType");
	if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_FILENAME") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_FILENAME;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_ALPHA_CENTAURI") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_ALPHA_CENTAURI;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_LAUNCH") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_LAUNCH;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_LAUNCHED") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_LAUNCHED;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_ZOOM_IN") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_ZOOM_IN;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_ZOOM_MOVE") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_ZOOM_MOVE;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_OFF") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_OFF;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_APPEAR") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_APPEAR;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_PREVIEW") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_PREVIEW;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_COMPONENT_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_COMPONENT_ON;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_LIGHT_OFF") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_LIGHT_OFF;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_GANTRY_SMOKE_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_GANTRY_SMOKE_ON;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_IN_SPACE_SMOKE_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_IN_SPACE_SMOKE_ON;
	else if(szTextVal.CompareNoCase("SPACE_SHIP_INFO_TYPE_IN_GAME_SMOKE_ON") == 0)
		m_eSpaceShipInfoType = SPACE_SHIP_INFO_TYPE_IN_GAME_SMOKE_ON;
	else
	{
		FAssertMsg(false, "[Jason] Unknown SpaceShipInfoType.");
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvSpaceShipInfo::copyNonDefaults(CvSpaceShipInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getNodeName()			== cDefault)	setNodeName(			pClassInfo->getNodeName());
	if (getProjectName()		== cDefault)	setProjectName(			pClassInfo->getProjectName());
	if (getPartNumber()			== 0)			m_iPartNumber			= pClassInfo->getPartNumber();
	if (getArtType()			== 0)			m_iArtType				= pClassInfo->getArtType();
	if (getEventCode()			== 0)			m_iEventCode			= pClassInfo->getEventCode();

//	if (getCameraUpAxis()		== cDefault)	m_eCameraUpAxis			= pClassInfo->getCameraUpAxis();
//	if (getSpaceShipInfoType()	== cDefault)	m_eSpaceShipInfoType	= pClassInfo->getSpaceShipInfoType();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAnimationPathInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAnimationPathInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationPathInfo::CvAnimationPathInfo() :
	m_bMissionPath(false)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAnimationPathInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationPathInfo::~CvAnimationPathInfo()
{
}

int CvAnimationPathInfo::getPathCategory( int i )
{
	return (int)m_vctPathDefinition.size() > i ? m_vctPathDefinition[i].first : -1;
}

float CvAnimationPathInfo::getPathParameter( int i )
{
	return (int)m_vctPathDefinition.size() > i ? m_vctPathDefinition[i].second : -1;
}

int CvAnimationPathInfo::getNumPathDefinitions()
{
	return m_vctPathDefinition.size();
}

CvAnimationPathDefinition * CvAnimationPathInfo::getPath( )
{
	return &m_vctPathDefinition;
}

bool CvAnimationPathInfo::isMissionPath() const
{
	return m_bMissionPath;
}

//------------------------------------------------------------------------------------------------
// FUNCTION:    CvAnimationPathInfo::read
//! \brief      Reads in a CvAnimationPathInfo definition from XML
//! \param      pXML Pointer to the XML loading object
//! \retval     true if the definition was read successfully, false otherwise
//------------------------------------------------------------------------------------------------
bool CvAnimationPathInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	TCHAR	szTempString[1024];				// Extracting text
	int		iCurrentCategory;				// The current category information we are building
	float	fParameter;						// Temporary

	pXML->GetChildXmlValByName( &m_bMissionPath, "bMissionPath" );
	gDLL->getXMLIFace()->SetToChild(pXML->GetXML() );
	gDLL->getXMLIFace()->GetLastNodeText(pXML->GetXML(), szTempString);
	gDLL->getXMLIFace()->NextSibling(pXML->GetXML());
	gDLL->getXMLIFace()->NextSibling(pXML->GetXML());
	do
	{
		if ( pXML->GetChildXmlValByName( szTempString, _T("Category") ))
		{
			iCurrentCategory = pXML->FindInInfoClass( szTempString);
			fParameter = 0.0f;
		}
		else
		{
			pXML->GetChildXmlValByName( szTempString, _T("Operator"));
			iCurrentCategory = GC.getTypesEnum(szTempString);
			iCurrentCategory = ((int)ANIMOP_FIRST) + iCurrentCategory;
			if ( !pXML->GetChildXmlValByName( &fParameter, "Parameter" ) )
			{
				fParameter = 0.0f;
			}
		}
			m_vctPathDefinition.push_back( std::make_pair(iCurrentCategory, fParameter ));
	}
	while ( gDLL->getXMLIFace()->NextSibling(pXML->GetXML()));
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAnimationPathInfo::copyNonDefaults(CvAnimationPathInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isMissionPath()				== false)		m_bMissionPath			= pClassInfo->isMissionPath();
	if (m_vctPathDefinition.size()	== 0)
	{
		for ( int i = 0; i < (int)m_vctPathDefinition.size(); i++ )
		{
			int iCurrentCategory											= pClassInfo->getPathCategory(i);
			float fParameter												= pClassInfo->getPathParameter(i);
													m_vctPathDefinition.push_back(std::make_pair(iCurrentCategory, fParameter ));
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvAnimationCategoryInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvAnimationCategoryInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationCategoryInfo::CvAnimationCategoryInfo()
{
	m_kCategory.second = -7540; // invalid.
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvAnimationCategoryInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvAnimationCategoryInfo::~CvAnimationCategoryInfo()
{
}

int CvAnimationCategoryInfo::getCategoryBaseID( )
{
	return m_kCategory.first;
}

int CvAnimationCategoryInfo::getCategoryDefaultTo( )
{
	if ( m_kCategory.second < -1 )
	{
		// CvXMLLoadUtility *pXML = new CvXMLLoadUtility();
		m_kCategory.second = CvXMLLoadUtility::FindInInfoClass( m_szDefaultTo);
	}
	return (int)m_kCategory.second;
}

bool CvAnimationCategoryInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int		iBaseID;						// Temporary
	pXML->GetChildXmlValByName( m_szDefaultTo, "DefaultTo");
	pXML->GetChildXmlValByName( &iBaseID, "BaseID");
	m_kCategory.first = iBaseID;
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAnimationCategoryInfo::copyNonDefaults(CvAnimationCategoryInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getCategoryBaseID()		== 0)				m_kCategory.first		= pClassInfo->getCategoryBaseID();
	if (getCategoryDefaultTo()	== ANIMCAT_NONE)	m_kCategory.second		= pClassInfo->getCategoryDefaultTo();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvEntityEventInfo
/////////////////////////////////////////////////////////////////////////////////////////////

CvEntityEventInfo::CvEntityEventInfo() :
m_bUpdateFormation(true)
{
}

CvEntityEventInfo::~CvEntityEventInfo()
{
}

bool CvEntityEventInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTmp, szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int iNumSibs, i;

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AnimationPathTypes"))
	{
		// Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				// if the call to the function that sets the current xml node to it's first non-comment
				// child and sets the parameter with the new node's value succeeds
				if (pXML->GetChildXmlVal(szTmp))
				{
					AnimationPathTypes eAnimationPath = (AnimationPathTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
					if ( eAnimationPath > ANIMATIONPATH_NONE )
						m_vctAnimationPathType.push_back( eAnimationPath );

					// loop through all the siblings, we start at 1 since we already have the first value
					for (i=1;i<iNumSibs;i++)
					{
						if (!pXML->GetNextXmlVal(szTmp))
						{
							break;
						}
						AnimationPathTypes eAnimationPath = (AnimationPathTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
						if ( eAnimationPath > ANIMATIONPATH_NONE )
							m_vctAnimationPathType.push_back( eAnimationPath );

					}
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"EffectTypes"))
	{
		// Skip any comments and stop at the next value we might want
		if (pXML->SkipToNextVal())
		{
			// get the total number of children the current xml node has
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (iNumSibs > 0)
			{
				// if the call to the function that sets the current xml node to it's first non-comment
				// child and sets the parameter with the new node's value succeeds
				if (pXML->GetChildXmlVal(szTmp))
				{
					EffectTypes eEffectType = (EffectTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
					if ( eEffectType > NO_EFFECT )
						m_vctEffectTypes.push_back( eEffectType );

					// loop through all the siblings, we start at 1 since we already have the first value
					for (i=1;i<iNumSibs;i++)
					{
						if (!pXML->GetNextXmlVal(szTmp))
						{
							break;
						}
						EffectTypes eEffectType = (EffectTypes)CvXMLLoadUtility::FindInInfoClass( szTmp);
						if ( eEffectType > NO_EFFECT )
							m_vctEffectTypes.push_back( eEffectType );
					}
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName( &m_bUpdateFormation, "bUpdateFormation" );

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEntityEventInfo::copyNonDefaults(CvEntityEventInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getUpdateFormation()		== false)		m_bUpdateFormation						= pClassInfo->getUpdateFormation();
	for (int i = 0; i < pClassInfo->getAnimationPathCount(); i++)
	{
		bool bPushBack = true;
		for (int j = 0; j < getAnimationPathCount(); j++)
		{
			if (getAnimationPathType(j) == pClassInfo->getAnimationPathType(i))	bPushBack = false;
		}
		if (bPushBack)								m_vctAnimationPathType.push_back(		pClassInfo->getAnimationPathType(i));
	}

	for (int i = 0; i < pClassInfo->getEffectTypeCount(); i++)
	{
		bool bPushBack = true;
		for (int j = 0; j < getEffectTypeCount(); j++)
		{
			if (getEffectType(j) == pClassInfo->getEffectType(i))	bPushBack = false;
		}
		if (bPushBack)								m_vctEffectTypes.push_back(				pClassInfo->getEffectType(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

AnimationPathTypes CvEntityEventInfo::getAnimationPathType(int iIndex) const
{
	return iIndex >= (int)m_vctAnimationPathType.size() ? ANIMATIONPATH_NONE : m_vctAnimationPathType[iIndex];
}

EffectTypes CvEntityEventInfo::getEffectType(int iIndex) const
{
	return iIndex >= (int)m_vctEffectTypes.size() ? NO_EFFECT : m_vctEffectTypes[iIndex];
}

int CvEntityEventInfo::getAnimationPathCount() const
{
	return m_vctAnimationPathType.size();
}

int CvEntityEventInfo::getEffectTypeCount() const
{
	return m_vctEffectTypes.size();
}

bool CvEntityEventInfo::getUpdateFormation() const
{
	return m_bUpdateFormation;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CvAssetInfoBase
/////////////////////////////////////////////////////////////////////////////////////////////

const TCHAR* CvAssetInfoBase::getTag() const
{
	return getType();
}

void CvAssetInfoBase::setTag(const TCHAR* szDesc)
{
	m_szType = szDesc;
}

const TCHAR* CvAssetInfoBase::getPath() const
{
	return m_szPath;
}

void CvAssetInfoBase::setPath(const TCHAR* szDesc)
{
	m_szPath = szDesc;
}

bool CvAssetInfoBase::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))		// 'tag' is the same as 'type'
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
	setPath(szTextVal);

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoAsset
/////////////////////////////////////////////////////////////////////////////////////////////

const TCHAR* CvArtInfoAsset::getNIF() const
{
	return m_szNIF;
}

const TCHAR* CvArtInfoAsset::getKFM() const
{
	return m_szKFM;
}

void CvArtInfoAsset::setNIF(const TCHAR* szDesc)
{
	m_szNIF = szDesc;
}

void CvArtInfoAsset::setKFM(const TCHAR* szDesc)
{
	m_szKFM = szDesc;
}

bool CvArtInfoAsset::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvAssetInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "NIF");
	setNIF(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "KFM");
	setKFM(szTextVal);


	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoAsset::copyNonDefaults(CvArtInfoAsset* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoBonus
/////////////////////////////////////////////////////////////////////////////////////////////

bool CvArtInfoBonus::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "SHADERNIF");
	setShaderNIF(szTextVal);

	pXML->GetChildXmlValByName(&m_iFontButtonIndex, "FontButtonIndex");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoBonus::copyNonDefaults(CvArtInfoBonus* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

CvArtInfoBonus::CvArtInfoBonus()
{
	m_iFontButtonIndex = 0;
}

int CvArtInfoBonus::getFontButtonIndex() const
{
	return m_iFontButtonIndex;
}

const TCHAR* CvArtInfoBonus::getShaderNIF() const
{
	return m_szShaderNIF;
}
void CvArtInfoBonus::setShaderNIF(const TCHAR* szDesc)
{
	m_szShaderNIF = szDesc;
}

const CvArtInfoBonus* CvBonusInfo::getArtInfo() const
{
	return ARTFILEMGR.getBonusArtInfo( getArtDefineTag());
}


/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoUnit
/////////////////////////////////////////////////////////////////////////////////////////////

CvArtInfoUnit::CvArtInfoUnit() :
m_fShadowScale(0.0f),
m_iDamageStates(0),
m_bActAsRanged(false),
m_bActAsLand(false),
m_bActAsAir(false),
m_bCombatExempt(false),
m_fTrailWidth(0.0f),
m_fTrailLength(0.0f),
m_fTrailTaper(0.0f),
m_fTrailFadeStartTime(0.0f),
m_fTrailFadeFalloff(0.0f),
m_fRangedDeathTime(0.0f),
m_fExchangeAngle(0.0f),
m_bSmoothMove(false),
m_fAngleInterRate(FLT_MAX),
m_fBankRate(0),
m_iRunLoopSoundTag(0),
m_iRunEndSoundTag(0),
m_iSelectionSoundScriptId(0),
m_iActionSoundScriptId(0),
m_iPatrolSoundTag(0)
{
}

CvArtInfoUnit::~CvArtInfoUnit()
{
}

bool CvArtInfoUnit::getActAsRanged() const
{
	return m_bActAsRanged;
}

bool CvArtInfoUnit::getActAsLand() const
{
	return m_bActAsLand;
}

bool CvArtInfoUnit::getActAsAir() const
{
	return m_bActAsAir;
}

const TCHAR* CvArtInfoUnit::getShaderNIF() const
{
	return m_szShaderNIF;
}

void CvArtInfoUnit::setShaderNIF(const TCHAR* szDesc)
{
	m_szShaderNIF = szDesc;
}

const TCHAR* CvArtInfoUnit::getShadowNIF() const
{
	return m_szShadowNIF;
}

float CvArtInfoUnit::getShadowScale() const
{
	return m_fShadowScale;
}

const TCHAR* CvArtInfoUnit::getShadowAttachNode() const
{
	return m_szShadowAttach;
}

int CvArtInfoUnit::getDamageStates() const
{
	return m_iDamageStates;
}


const TCHAR* CvArtInfoUnit::getTrailTexture() const
{
	return m_szTrailTexture;
}

float CvArtInfoUnit::getTrailWidth() const
{
	return m_fTrailWidth;
}

float CvArtInfoUnit::getTrailLength() const
{
	return m_fTrailLength;
}

float CvArtInfoUnit::getTrailTaper() const
{
	return m_fTrailTaper;
}

float CvArtInfoUnit::getTrailFadeStarTime() const
{
	return m_fTrailFadeStartTime;
}

float CvArtInfoUnit::getTrailFadeFalloff() const
{
	return m_fTrailFadeFalloff;
}

float CvArtInfoUnit::getBattleDistance() const
{
	return m_fBattleDistance;
}

float CvArtInfoUnit::getRangedDeathTime() const
{
	return m_fRangedDeathTime;
}

float CvArtInfoUnit::getExchangeAngle() const
{
	return m_fExchangeAngle;
}

bool CvArtInfoUnit::getCombatExempt() const
{
	return m_bCombatExempt;
}

bool CvArtInfoUnit::getSmoothMove() const
{
	return m_bSmoothMove;
}

float CvArtInfoUnit::getAngleInterpRate() const
{
	return m_fAngleInterRate;
}

float CvArtInfoUnit::getBankRate() const
{
	return m_fBankRate;
}

bool CvArtInfoUnit::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	CvString szTextVal;

	pXML->GetChildXmlValByName(szTextVal, "ActionSound");
	m_iActionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;
	pXML->GetChildXmlValByName(szTextVal, "SelectionSound");
	m_iSelectionSoundScriptId = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;
	pXML->GetChildXmlValByName(szTextVal, "PatrolSound");
	m_iPatrolSoundTag = (szTextVal.GetLength() > 0) ? gDLL->getAudioTagIndex( szTextVal.GetCString(), AUDIOTAG_3DSCRIPT ) : -1;

	pXML->GetChildXmlValByName(szTextVal, "TrainSound");
	setTrainSound(szTextVal);

	pXML->GetChildXmlValByName(&m_bActAsRanged, "bActAsRanged" );
	pXML->GetChildXmlValByName(&m_bActAsLand, "bActAsLand" );
	pXML->GetChildXmlValByName(&m_bActAsAir, "bActAsAir" );
	pXML->GetChildXmlValByName(&m_bCombatExempt, "bCombatExempt", false );
	pXML->GetChildXmlValByName(&m_fExchangeAngle, "fExchangeAngle", 0.0f );
	pXML->GetChildXmlValByName(&m_bSmoothMove, "bSmoothMove", false );
	pXML->GetChildXmlValByName(&m_fAngleInterRate, "fAngleInterpRate", FLT_MAX );
	pXML->GetChildXmlValByName(&m_fBankRate, "fBankRate", 0 );

	pXML->GetChildXmlValByName(szTextVal, "SHADERNIF");
	setShaderNIF(szTextVal);

	if ( gDLL->getXMLIFace()->SetToChildByTagName( pXML->GetXML(), "ShadowDef" ))
	{
		pXML->GetChildXmlValByName( m_szShadowAttach, "ShadowAttachNode" );
		pXML->GetChildXmlValByName(m_szShadowNIF, "ShadowNIF");
		pXML->GetChildXmlValByName(&m_fShadowScale, "fShadowScale");
		gDLL->getXMLIFace()->SetToParent( pXML->GetXML());
	}

	pXML->GetChildXmlValByName(&m_iDamageStates, "iDamageStates", 0);
	pXML->GetChildXmlValByName(&m_fBattleDistance, "fBattleDistance", 0.0f);
	pXML->GetChildXmlValByName(&m_fRangedDeathTime, "fRangedDeathTime", 0.0f );

	m_fTrailWidth = -1.0f; // invalid.
	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TrailDefinition"))
	{
		pXML->GetChildXmlValByName(m_szTrailTexture, "Texture" );
		pXML->GetChildXmlValByName(&m_fTrailWidth, "fWidth" );
		pXML->GetChildXmlValByName(&m_fTrailLength, "fLength" );
		pXML->GetChildXmlValByName(&m_fTrailTaper, "fTaper" );
		pXML->GetChildXmlValByName(&m_fTrailFadeStartTime, "fFadeStartTime" );
		pXML->GetChildXmlValByName(&m_fTrailFadeFalloff, "fFadeFalloff" );
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML() );
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AudioRunSounds"))
	{
		pXML->GetChildXmlValByName(szTextVal, "AudioRunTypeLoop");
		m_iRunLoopSoundTag = GC.getFootstepAudioTypeByTag(szTextVal);
		pXML->GetChildXmlValByName(szTextVal, "AudioRunTypeEnd");
		m_iRunEndSoundTag = GC.getFootstepAudioTypeByTag(szTextVal);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoUnit::copyNonDefaults(CvArtInfoUnit* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

const TCHAR* CvArtInfoUnit::getTrainSound() const
{
	return m_szTrainSound;
}

void CvArtInfoUnit::setTrainSound(const TCHAR* szVal)
{
	m_szTrainSound = szVal;
}

int CvArtInfoUnit::getRunLoopSoundTag() const
{
	return m_iRunLoopSoundTag;
}

int CvArtInfoUnit::getRunEndSoundTag() const
{
	return m_iRunEndSoundTag;
}

int CvArtInfoUnit::getPatrolSoundTag() const
{
	return m_iPatrolSoundTag;
}

int CvArtInfoUnit::getSelectionSoundScriptId() const
{
	return m_iSelectionSoundScriptId;
}

int CvArtInfoUnit::getActionSoundScriptId() const
{
	return m_iActionSoundScriptId;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoBuilding
/////////////////////////////////////////////////////////////////////////////////////////////

CvArtInfoBuilding::CvArtInfoBuilding() :
m_bAnimated(false)
{
}

CvArtInfoBuilding::~CvArtInfoBuilding()
{
}

bool CvArtInfoBuilding::isAnimated() const
{
	return m_bAnimated;
}

const TCHAR* CvArtInfoBuilding::getLSystemName() const
{
	return m_szLSystemName;
}

bool CvArtInfoBuilding::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szLSystemName, "LSystem");

	pXML->GetChildXmlValByName(&m_bAnimated, "bAnimated");
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoBuilding::copyNonDefaults(CvArtInfoBuilding* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoCivilization
/////////////////////////////////////////////////////////////////////////////////////////////

CvArtInfoCivilization::CvArtInfoCivilization() :
m_bWhiteFlag(false)
{
}

CvArtInfoCivilization::~CvArtInfoCivilization()
{
}

bool CvArtInfoCivilization::isWhiteFlag() const
{
	return m_bWhiteFlag;
}

bool CvArtInfoCivilization::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bWhiteFlag, "bWhiteFlag");
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoCivilization::copyNonDefaults(CvArtInfoCivilization* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoLeaderhead
/////////////////////////////////////////////////////////////////////////////////////////////

const TCHAR* CvArtInfoLeaderhead::getNoShaderNIF() const
{
	return m_szNoShaderNIF;
}

void CvArtInfoLeaderhead::setNoShaderNIF(const TCHAR* szNIF)
{
	m_szNoShaderNIF = szNIF;
}

const TCHAR* CvArtInfoLeaderhead::getBackgroundKFM() const
{
	return m_szBackgroundKFM;
}

void CvArtInfoLeaderhead::setBackgroundKFM( const TCHAR* szKFM)
{
	m_szBackgroundKFM = szKFM;
}

bool CvArtInfoLeaderhead::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "NoShaderNIF");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setNoShaderNIF(szTextVal);

	if (pXML->GetChildXmlValByName(szTextVal, "BackgroundKFM"))
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
		setBackgroundKFM(szTextVal);
/**								----  End Original Code  ----									**/
	{
		p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
		SAFE_DELETE(p_aszDirName);
		setBackgroundKFM(szTextVal);
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	else
		setBackgroundKFM("");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoLeaderhead::copyNonDefaults(CvArtInfoLeaderhead* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/////////////////////////////////////////////////////////////////////////////////////////////
// CvArtInfoScalableAsset
/////////////////////////////////////////////////////////////////////////////////////////////

bool CvArtInfoScalableAsset::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	return CvScalableInfo::read(pXML);
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoScalableAsset::copyNonDefaults(CvArtInfoScalableAsset* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvArtInfoImprovement
//////////////////////////////////////////////////////////////////////////

CvArtInfoImprovement::CvArtInfoImprovement() :
m_bExtraAnimations(false)
{
}

CvArtInfoImprovement::~CvArtInfoImprovement()
{
}

bool CvArtInfoImprovement::isExtraAnimations() const
{
	return m_bExtraAnimations;
}

bool CvArtInfoImprovement::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bExtraAnimations, "bExtraAnimations");

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "SHADERNIF");
	setShaderNIF(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoImprovement::copyNonDefaults(CvArtInfoImprovement* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvArtInfoTerrain
//////////////////////////////////////////////////////////////////////////

CvArtInfoTerrain::CvArtInfoTerrain() :
m_iLayerOrder(0),
m_bAlphaShader(false),
m_numTextureBlends(16),
m_pTextureSlots(NULL)
{
	m_pTextureSlots = new CvTextureBlendSlotList * [m_numTextureBlends];
	for ( int i = 0; i < m_numTextureBlends; i++ )
	{
		m_pTextureSlots[i] = new CvTextureBlendSlotList;
	}

}

CvArtInfoTerrain::~CvArtInfoTerrain()
{
	for ( int i = 0; i < m_numTextureBlends; i++ )
	{
		SAFE_DELETE(m_pTextureSlots[i]);
	}
	SAFE_DELETE_ARRAY( m_pTextureSlots);
}

const TCHAR* CvArtInfoTerrain::getBaseTexture()
{
	return getPath();
}

void CvArtInfoTerrain::setBaseTexture(const TCHAR* szTmp )
{
	setPath(szTmp);
}

const TCHAR* CvArtInfoTerrain::getGridTexture()
{
	return m_szGridTexture;
}

void CvArtInfoTerrain::setGridTexture(const TCHAR* szTmp )
{
	m_szGridTexture = szTmp;
}

const TCHAR* CvArtInfoTerrain::getDetailTexture()
{
	return m_szDetailTexture;
}

void CvArtInfoTerrain::setDetailTexture(const TCHAR* szTmp)
{
	m_szDetailTexture = szTmp;
}

int CvArtInfoTerrain::getLayerOrder()
{
	return m_iLayerOrder;
}

bool CvArtInfoTerrain::useAlphaShader()
{
	return m_bAlphaShader;
}

CvTextureBlendSlotList &CvArtInfoTerrain::getBlendList(int blendMask)
{
	FAssert(blendMask>0 && blendMask<16);
	return *m_pTextureSlots[blendMask];
}

void BuildSlotList( CvTextureBlendSlotList &list, CvString &numlist)
{
	//convert string to
	char seps[]   = " ,\t\n";
	char *token;
	const char *numstring = numlist;
	token = strtok( const_cast<char *>(numstring), seps);
	while( token != NULL )
	{
		int slot = atoi(token);
		token = strtok( NULL, seps);
		int rotation = atoi(token);
		list.push_back(std::make_pair( slot, rotation));
		token = strtok( NULL, seps);
	}
}

bool CvArtInfoTerrain::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvArtInfoAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Grid");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setGridTexture(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "Detail");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setDetailTexture(szTextVal);
	pXML->GetChildXmlValByName(&m_iLayerOrder, "LayerOrder");
	pXML->GetChildXmlValByName(&m_bAlphaShader, "AlphaShader");

	// Parse texture slots for blend tile lists
	char xmlName[] = "TextureBlend00";
	for(int i =1; i<m_numTextureBlends;i++ )
	{
		sprintf(xmlName+(strlen(xmlName)-2),"%02d",i);
		pXML->GetChildXmlValByName(szTextVal, xmlName);
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
		p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
		SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
		BuildSlotList(*m_pTextureSlots[i], szTextVal);
	}

	return CvArtInfoAsset::read(pXML);
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoTerrain::copyNonDefaults(CvArtInfoTerrain* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvArtInfoFeature
//////////////////////////////////////////////////////////////////////////

CvArtInfoFeature::CvArtInfoFeature() :
m_bAnimated(false),
m_bRiverArt(false),
m_eTileArtType(TILE_ART_TYPE_NONE),
m_eLightType(LIGHT_TYPE_NONE)
{
}

CvArtInfoFeature::~CvArtInfoFeature()
{
}

bool CvArtInfoFeature::isAnimated() const
{
	return m_bAnimated;
}

bool CvArtInfoFeature::isRiverArt() const
{
	return m_bRiverArt;
}

TileArtTypes CvArtInfoFeature::getTileArtType() const
{
	return m_eTileArtType;
}

LightTypes CvArtInfoFeature::getLightType() const
{
	return m_eLightType;
}

bool CvArtInfoFeature::read(CvXMLLoadUtility* pXML)
{
	if (!CvArtInfoScalableAsset::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bAnimated, "bAnimated");
	pXML->GetChildXmlValByName(&m_bRiverArt, "bRiverArt");

	CvString szTemp;
	pXML->GetChildXmlValByName(szTemp, "TileArtType");
	if(szTemp.CompareNoCase("TILE_ART_TYPE_NONE") == 0)
		m_eTileArtType = TILE_ART_TYPE_NONE;
	else if(szTemp.CompareNoCase("TILE_ART_TYPE_TREES") == 0)
		m_eTileArtType = TILE_ART_TYPE_TREES;
	else if(szTemp.CompareNoCase("TILE_ART_TYPE_HALF_TILING") == 0)
		m_eTileArtType = TILE_ART_TYPE_HALF_TILING;
	else if(szTemp.CompareNoCase("TILE_ART_TYPE_PLOT_TILING") == 0)
		m_eTileArtType = TILE_ART_TYPE_PLOT_TILING;
	else
	{
		FAssertMsg(false, "[Jason] Unknown TileArtType.");
	}

	pXML->GetChildXmlValByName(szTemp, "LightType");
	if(szTemp.CompareNoCase("LIGHT_TYPE_NONE") == 0)
		m_eLightType = LIGHT_TYPE_NONE;
	else if(szTemp.CompareNoCase("LIGHT_TYPE_SUN") == 0)
		m_eLightType = LIGHT_TYPE_SUN;
	else if(szTemp.CompareNoCase("LIGHT_TYPE_TERRAIN") == 0)
		m_eLightType = LIGHT_TYPE_TERRAIN;
	else if(szTemp.CompareNoCase("LIGHT_TYPE_UNIT") == 0)
		m_eLightType = LIGHT_TYPE_UNIT;
	else
	{
		FAssertMsg(false, "[Jason] Unknown LightType.");
	}

	//feature varieties
	if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureVariety"))
	{
		do
		{
			m_aFeatureVarieties.push_back(FeatureVariety());
			FeatureVariety &featureVariety = m_aFeatureVarieties.back();

			//generate rotations
			bool generateRotations = false;
			pXML->GetChildXmlValByName(&generateRotations, "bGenerateRotations");

			//feature art pieces
			if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureArtPieces"))
			{
				if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureArtPiece"))
				{
					do
					{
						//connection mask
						pXML->GetChildXmlValByName(szTemp, "Connections");
						int connectionMask = getConnectionMaskFromString(szTemp);

						//model files
						if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ModelFile"))
						{
							do
							{
								pXML->GetXmlVal(szTemp);
								if(!generateRotations)
								{
									FeatureArtPiece &featureArtPiece = featureVariety.createFeatureArtPieceFromConnectionMask(connectionMask);
									featureArtPiece.m_aArtModels.push_back(FeatureArtModel(szTemp, ROTATE_NONE));
								}
								else
								{
									for(int i=0;i<NUM_ROTATION_TYPES;i++)
									{
										int newConnectionMask = getRotatedConnectionMask(connectionMask, (RotationTypes) i);
										FeatureArtPiece &featureArtPiece = featureVariety.createFeatureArtPieceFromConnectionMask(newConnectionMask);
										featureArtPiece.m_aArtModels.push_back(FeatureArtModel(szTemp, (RotationTypes) i));
									}
								}
							} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "ModelFile"));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}
					} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "FeatureArtPiece"));

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}

			//feature art pieces
			if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureDummyNodes"))
			{
				if(gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeatureDummyNode"))
				{
					do
					{
						CvString tagName;
						CvString nodeName;

						//tag name
						pXML->GetChildXmlValByName(tagName, "Tag");

						//node name
						pXML->GetChildXmlValByName(nodeName, "Name");

						featureVariety.createFeatureDummyNode(tagName, nodeName);
					} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "FeatureDummyNode"));

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}

				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}

			//variety button
			pXML->GetChildXmlValByName(featureVariety.m_szVarietyButton, "VarietyButton");

		} while(gDLL->getXMLIFace()->LocateNextSiblingNodeByTagName(pXML->GetXML(), "FeatureVariety"));

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvArtInfoFeature::copyNonDefaults(CvArtInfoFeature* pClassInfo, CvXMLLoadUtility* pXML)
{
	// Empty, for Art files we stick to FULL XML defintions
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

const CvArtInfoFeature::FeatureVariety &CvArtInfoFeature::getVariety(int index) const
{
	FAssertMsg((index >= 0) && (index < (int) m_aFeatureVarieties.size()), "[Jason] Feature Variety index out of range.");
	return m_aFeatureVarieties[index];
}

int CvArtInfoFeature::getNumVarieties() const
{
	return m_aFeatureVarieties.size();
}

std::string CvArtInfoFeature::getFeatureDummyNodeName(int variety, std::string tagName)
{
	return getVariety(variety).getFeatureDummyNodeName(tagName);
}

int CvArtInfoFeature::getConnectionMaskFromString(const CvString &connectionString)
{
	if(connectionString.IsEmpty())
		return 0;
	else
	{
		std::vector<CvString> tokens;
		connectionString.getTokens(" \t\n", tokens);

		int connectionMask = 0;
		for(int i=0;i<(int)tokens.size();i++)
		{
			// found a token, parse it.
			CvString &token = tokens[i];
			if(token.CompareNoCase("NW") == 0)
				connectionMask |= DIRECTION_NORTHWEST_MASK;
			else if(token.CompareNoCase("N") == 0)
				connectionMask |= DIRECTION_NORTH_MASK;
			else if(token.CompareNoCase("NE") == 0)
				connectionMask |= DIRECTION_NORTHEAST_MASK;
			else if(token.CompareNoCase("E") == 0)
				connectionMask |= DIRECTION_EAST_MASK;
			else if(token.CompareNoCase("SE") == 0)
				connectionMask |= DIRECTION_SOUTHEAST_MASK;
			else if(token.CompareNoCase("S") == 0)
				connectionMask |= DIRECTION_SOUTH_MASK;
			else if(token.CompareNoCase("SW") == 0)
				connectionMask |= DIRECTION_SOUTHWEST_MASK;
			else if(token.CompareNoCase("W") == 0)
				connectionMask |= DIRECTION_WEST_MASK;
			else
			{
				FAssertMsg(false, "[Jason] Invalid connection direction.");
			}
		}

		FAssertMsg(connectionMask > 0, "[Jason] Did not find feature connection mask.");
		return connectionMask;
	}
}

int CvArtInfoFeature::getRotatedConnectionMask(int connectionMask, RotationTypes rotation)
{
	if(rotation == ROTATE_NONE)
		connectionMask = connectionMask;
	else if(rotation == ROTATE_90CW)
		connectionMask = connectionMask << 2; //rotate two directions CW
	else if(rotation == ROTATE_180CW)
		connectionMask = connectionMask << 4; //rotate four directions CW
	else if(rotation == ROTATE_270CW)
		connectionMask = connectionMask << 6; //rotate six directions CW

	//renormalize directions that wrapped around
	connectionMask = connectionMask | (connectionMask >> 8);
	connectionMask = connectionMask & 255;
	return connectionMask;
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvEmphasizeInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvEmphasizeInfo::CvEmphasizeInfo() :
m_bAvoidGrowth(false),
m_bGreatPeople(false),
/*************************************************************************************************/
/**	New Tag Defs	(CityAIInfos)			11/15/08								Jean Elcard	**/
/**	ADDON (GrowthControl) merged Sephi															**/
/**										Initial Values											**/
/*************************************************************************************************/
m_bAvoidAngryCitizens(false),
m_bAvoidUnhealthyCitizens(false),
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
m_piYieldModifiers(NULL),
m_piCommerceModifiers(NULL)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvEmphasizeInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvEmphasizeInfo::~CvEmphasizeInfo()
{
	SAFE_DELETE_ARRAY(m_piYieldModifiers);
	SAFE_DELETE_ARRAY(m_piCommerceModifiers);
}

bool CvEmphasizeInfo::isAvoidGrowth() const
{
	return m_bAvoidGrowth;
}

bool CvEmphasizeInfo::isGreatPeople() const
{
	return m_bGreatPeople;
}

/*************************************************************************************************/
/**	New Tag Defs	(CityAIInfos)			11/15/08								Jean Elcard	**/
/**	ADDON (GrowthControl) merged Sephi															**/
/**									Called for Logic Checks										**/
/*************************************************************************************************/
bool CvEmphasizeInfo::isAvoidAngryCitizens() const
{
	return m_bAvoidAngryCitizens;
}

bool CvEmphasizeInfo::isAvoidUnhealthyCitizens() const
{
	return m_bAvoidUnhealthyCitizens;
}
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
// Arrays

int CvEmphasizeInfo::getYieldChange(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piYieldModifiers ? m_piYieldModifiers[i] : -1;
}

int CvEmphasizeInfo::getCommerceChange(int i) const
{
	FAssertMsg(i < NUM_COMMERCE_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piCommerceModifiers ? m_piCommerceModifiers[i] : -1;
}

//
// read from XML
//
bool CvEmphasizeInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bAvoidGrowth, "bAvoidGrowth");
	pXML->GetChildXmlValByName(&m_bGreatPeople, "bGreatPeople");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"YieldModifiers"))
	{
		pXML->SetYields(&m_piYieldModifiers);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piYieldModifiers, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CommerceModifiers"))
	{
		pXML->SetCommerce(&m_piCommerceModifiers);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_piCommerceModifiers, NUM_COMMERCE_TYPES);
	}
/*************************************************************************************************/
/**	New Tag Defs	(CityAIInfos)			11/15/08								Jean Elcard	**/
/**	ADDON (GrowthControl) merged Sephi															**/
/**									Loads Information from XML									**/
/*************************************************************************************************/
	pXML->GetChildXmlValByName(&m_bAvoidAngryCitizens, "bAvoidAngryCitizens");
	pXML->GetChildXmlValByName(&m_bAvoidUnhealthyCitizens, "bAvoidUnhealthyCitizens");
/*************************************************************************************************/
/**	New Tag Defs							END													**/
/*************************************************************************************************/
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(CityAIInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEmphasizeInfo::copyNonDefaults(CvEmphasizeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isAvoidGrowth()					== false)		m_bAvoidGrowth				= pClassInfo->isAvoidGrowth();
	if (isGreatPeople()					== false)		m_bGreatPeople				= pClassInfo->isGreatPeople();
	if (isAvoidAngryCitizens()			== false)		m_bAvoidAngryCitizens		= pClassInfo->isAvoidAngryCitizens();
	if (isAvoidUnhealthyCitizens()		== false)		m_bAvoidUnhealthyCitizens	= pClassInfo->isAvoidUnhealthyCitizens();
	for ( int i = 0; i < NUM_YIELD_TYPES; i++ )
	{
		if (m_piYieldModifiers[i]		== 0)			m_piYieldModifiers[i]		= pClassInfo->getYieldChange(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++ )
	{
		if (m_piCommerceModifiers[i]	== 0)			m_piCommerceModifiers[i]	= pClassInfo->getCommerceChange(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  CvUpkeepInfo
//

CvUpkeepInfo::CvUpkeepInfo() :
m_iPopulationPercent(0),
m_iCityPercent(0)
{
}

CvUpkeepInfo::~CvUpkeepInfo()
{
}

int CvUpkeepInfo::getPopulationPercent() const
{
	return m_iPopulationPercent;
}

int CvUpkeepInfo::getCityPercent() const
{
	return m_iCityPercent;
}

bool CvUpkeepInfo::read(CvXMLLoadUtility* pXml)
{
	if (!CvInfoBase::read(pXml))
	{
		return false;
	}

	pXml->GetChildXmlValByName(&m_iPopulationPercent, "iPopulationPercent");
	pXml->GetChildXmlValByName(&m_iCityPercent, "iCityPercent");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUpkeepInfo::copyNonDefaults(CvUpkeepInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPopulationPercent()		== 0)		m_iPopulationPercent		= pClassInfo->getPopulationPercent();
	if (getCityPercent()			== 0)		m_iCityPercent				= pClassInfo->getCityPercent();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  CvCultureLevelInfo
//

CvCultureLevelInfo::CvCultureLevelInfo() :
m_iCityDefenseModifier(0),
m_paiSpeedThreshold(NULL)
{
}

CvCultureLevelInfo::~CvCultureLevelInfo()
{
	SAFE_DELETE_ARRAY(m_paiSpeedThreshold);
}

int CvCultureLevelInfo::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

int CvCultureLevelInfo::getSpeedThreshold(int i) const
{
	FAssert(i < GC.getNumGameSpeedInfos());
	FAssert(i > -1);
	return m_paiSpeedThreshold[i];
}

bool CvCultureLevelInfo::read(CvXMLLoadUtility* pXml)
{
	if (!CvInfoBase::read(pXml))
	{
		return false;
	}

	pXml->GetChildXmlValByName(&m_iCityDefenseModifier, "iCityDefenseModifier");

	pXml->SetVariableListTagPair(&m_paiSpeedThreshold, "SpeedThresholds", sizeof(GC.getGameSpeedInfo((GameSpeedTypes)0)), GC.getNumGameSpeedInfos());

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCultureLevelInfo::copyNonDefaults(CvCultureLevelInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getCityDefenseModifier()		== 0)		m_iCityDefenseModifier		= pClassInfo->getCityDefenseModifier();
	for ( int i = 0; i < GC.getNumGameSpeedInfos(); i++ )
	{
		if (m_paiSpeedThreshold[i]		== 0)		m_paiSpeedThreshold[i]		= pClassInfo->getSpeedThreshold(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  CvEraInfo
//

CvEraInfo::CvEraInfo() :
m_iStartingUnitMultiplier(0),
m_iStartingDefenseUnits(0),
m_iStartingWorkerUnits(0),
m_iStartingExploreUnits(0),
m_iAdvancedStartPoints(0),
m_iStartingGold(0),
m_iFreePopulation(0),
m_iStartPercent(0),
m_iGrowthPercent(0),
m_iTrainPercent(0),
m_iConstructPercent(0),
m_iCreatePercent(0),
m_iResearchPercent(0),
m_iBuildPercent(0),
m_iImprovementPercent(0),
m_iGreatPeoplePercent(0),
m_iAnarchyPercent(0),
m_iEventChancePerTurn(0),
m_iSoundtrackSpace(0),
m_iNumSoundtracks(0),
m_bNoGoodies(false),
m_bNoAnimals(false),
m_bNoBarbUnits(false),
m_bNoBarbCities(false),
m_iBaseTechCost(0),
m_iBaseSpellresearchCost(0),
m_bFirstSoundtrackFirst(false),
m_paiCitySoundscapeSciptIds(NULL),
m_paiSoundtracks(NULL)
{
}

CvEraInfo::~CvEraInfo()
{
	SAFE_DELETE_ARRAY(m_paiCitySoundscapeSciptIds);
	SAFE_DELETE_ARRAY(m_paiSoundtracks);
}

int CvEraInfo::getStartingUnitMultiplier() const
{
	return m_iStartingUnitMultiplier;
}

int CvEraInfo::getStartingDefenseUnits() const
{
	return m_iStartingDefenseUnits;
}

int CvEraInfo::getStartingWorkerUnits() const
{
	return m_iStartingWorkerUnits;
}

int CvEraInfo::getStartingExploreUnits() const
{
	return m_iStartingExploreUnits;
}

int CvEraInfo::getAdvancedStartPoints() const
{
	return m_iAdvancedStartPoints;
}

int CvEraInfo::getStartingGold() const
{
	return m_iStartingGold;
}

int CvEraInfo::getFreePopulation() const
{
	return m_iFreePopulation;
}

int CvEraInfo::getStartPercent() const
{
	return m_iStartPercent;
}

int CvEraInfo::getGrowthPercent() const
{
	return m_iGrowthPercent;
}

int CvEraInfo::getTrainPercent() const
{
	return m_iTrainPercent;
}

int CvEraInfo::getConstructPercent() const
{
	return m_iConstructPercent;
}

int CvEraInfo::getCreatePercent() const
{
	return m_iCreatePercent;
}

int CvEraInfo::getResearchPercent() const
{
	return m_iResearchPercent;
}

int CvEraInfo::getBuildPercent() const
{
	return m_iBuildPercent;
}

int CvEraInfo::getImprovementPercent() const
{
	return m_iImprovementPercent;
}

int CvEraInfo::getGreatPeoplePercent() const
{
	return m_iGreatPeoplePercent;
}

int CvEraInfo::getAnarchyPercent() const
{
	return m_iAnarchyPercent;
}

int CvEraInfo::getEventChancePerTurn() const
{
	return m_iEventChancePerTurn;
}

int CvEraInfo::getSoundtrackSpace() const
{
	return m_iSoundtrackSpace;
}

bool CvEraInfo::isFirstSoundtrackFirst() const
{
	return m_bFirstSoundtrackFirst;
}

int CvEraInfo::getNumSoundtracks() const
{
	return m_iNumSoundtracks;
}

const TCHAR* CvEraInfo::getAudioUnitVictoryScript() const
{
	return m_szAudioUnitVictoryScript;
}

const TCHAR* CvEraInfo::getAudioUnitDefeatScript() const
{
	return m_szAudioUnitDefeatScript;
}

bool CvEraInfo::isNoGoodies() const
{
	return m_bNoGoodies;
}

bool CvEraInfo::isNoAnimals() const
{
	return m_bNoAnimals;
}

bool CvEraInfo::isNoBarbUnits() const
{
	return m_bNoBarbUnits;
}

bool CvEraInfo::isNoBarbCities() const
{
	return m_bNoBarbCities;
}

int CvEraInfo::getBaseTechCost() const
{
	return m_iBaseTechCost;
}

int CvEraInfo::getBaseSpellresearchCost() const
{
	return m_iBaseSpellresearchCost;
}

// Arrays

int CvEraInfo::getSoundtracks(int i) const
{
	FAssertMsg(i < getNumSoundtracks(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");

	return m_paiSoundtracks ? m_paiSoundtracks[i] : -1;
}

int CvEraInfo::getCitySoundscapeSciptId(int i) const
{
//	FAssertMsg(i < ?, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paiCitySoundscapeSciptIds ? m_paiCitySoundscapeSciptIds[i] : -1;
}

bool CvEraInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bNoGoodies, "bNoGoodies");
	pXML->GetChildXmlValByName(&m_bNoAnimals, "bNoAnimals");
	pXML->GetChildXmlValByName(&m_bNoBarbUnits, "bNoBarbUnits");
	pXML->GetChildXmlValByName(&m_bNoBarbCities, "bNoBarbCities");
	pXML->GetChildXmlValByName(&m_iBaseTechCost, "iBaseTechCost");
	pXML->GetChildXmlValByName(&m_iBaseSpellresearchCost, "iBaseSpellresearchCost");
	pXML->GetChildXmlValByName(&m_iStartingUnitMultiplier, "iStartingUnitMultiplier");
	pXML->GetChildXmlValByName(&m_iStartingDefenseUnits, "iStartingDefenseUnits");
	pXML->GetChildXmlValByName(&m_iStartingWorkerUnits, "iStartingWorkerUnits");
	pXML->GetChildXmlValByName(&m_iStartingExploreUnits, "iStartingExploreUnits");
	pXML->GetChildXmlValByName(&m_iAdvancedStartPoints, "iAdvancedStartPoints");
	pXML->GetChildXmlValByName(&m_iStartingGold, "iStartingGold");
	pXML->GetChildXmlValByName(&m_iFreePopulation, "iFreePopulation");
	pXML->GetChildXmlValByName(&m_iStartPercent, "iStartPercent");
	pXML->GetChildXmlValByName(&m_iGrowthPercent, "iGrowthPercent");
	pXML->GetChildXmlValByName(&m_iTrainPercent, "iTrainPercent");
	pXML->GetChildXmlValByName(&m_iConstructPercent, "iConstructPercent");
	pXML->GetChildXmlValByName(&m_iCreatePercent, "iCreatePercent");
	pXML->GetChildXmlValByName(&m_iResearchPercent, "iResearchPercent");
	pXML->GetChildXmlValByName(&m_iBuildPercent, "iBuildPercent");
	pXML->GetChildXmlValByName(&m_iImprovementPercent, "iImprovementPercent");
	pXML->GetChildXmlValByName(&m_iGreatPeoplePercent, "iGreatPeoplePercent");
	pXML->GetChildXmlValByName(&m_iAnarchyPercent, "iAnarchyPercent");
	pXML->GetChildXmlValByName(&m_iEventChancePerTurn, "iEventChancePerTurn");
	pXML->GetChildXmlValByName(&m_iSoundtrackSpace, "iSoundtrackSpace");
	pXML->GetChildXmlValByName(&m_bFirstSoundtrackFirst, "bFirstSoundtrackFirst");
	pXML->GetChildXmlValByName(m_szAudioUnitVictoryScript, "AudioUnitVictoryScript");
	pXML->GetChildXmlValByName(m_szAudioUnitDefeatScript, "AudioUnitDefeatScript");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "EraInfoSoundtracks"))
	{
		CvString* pszSoundTrackNames = NULL;
		pXML->SetStringList(&pszSoundTrackNames, &m_iNumSoundtracks);

		if (m_iNumSoundtracks > 0)
		{
			m_paiSoundtracks = new int[m_iNumSoundtracks];

			int j;
			for (j=0;j<m_iNumSoundtracks;j++)
			{
				m_paiSoundtracks[j] = ((!gDLL->getAudioDisabled()) ? gDLL->getAudioTagIndex(pszSoundTrackNames[j], AUDIOTAG_2DSCRIPT) : -1);
			}
		}
		else
		{
			m_paiSoundtracks = NULL;
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

		SAFE_DELETE_ARRAY(pszSoundTrackNames);
	}

	pXML->SetVariableListTagPairForAudioScripts(&m_paiCitySoundscapeSciptIds, "CitySoundscapes", GC.getCitySizeTypes(), sizeof(GC.getCitySizeTypes((CitySizeTypes)0)));

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEraInfo::copyNonDefaults(CvEraInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isNoGoodies()					== false)		m_bNoGoodies					= pClassInfo->isNoGoodies();
	if (isNoAnimals()					== false)		m_bNoAnimals					= pClassInfo->isNoAnimals();
	if (isNoBarbUnits()					== false)		m_bNoBarbUnits					= pClassInfo->isNoBarbUnits();
	if (isNoBarbCities()				== false)		m_bNoBarbCities					= pClassInfo->isNoBarbCities();
	if (getBaseTechCost()				== 0)			m_iBaseTechCost					= pClassInfo->getBaseTechCost();
	if (getBaseSpellresearchCost()		== 0)			m_iBaseSpellresearchCost		= pClassInfo->getBaseSpellresearchCost();
	if (getStartingUnitMultiplier()		== 0)			m_iStartingUnitMultiplier		= pClassInfo->getStartingUnitMultiplier();
	if (getStartingDefenseUnits()		== 0)			m_iStartingDefenseUnits			= pClassInfo->getStartingDefenseUnits();
	if (getStartingWorkerUnits()		== 0)			m_iStartingWorkerUnits			= pClassInfo->getStartingWorkerUnits();
	if (getStartingExploreUnits()		== 0)			m_iStartingExploreUnits			= pClassInfo->getStartingExploreUnits();
	if (getAdvancedStartPoints()		== 0)			m_iAdvancedStartPoints			= pClassInfo->getAdvancedStartPoints();
	if (getStartingGold()				== 0)			m_iStartingGold					= pClassInfo->getStartingGold();
	if (getFreePopulation()				== 0)			m_iFreePopulation				= pClassInfo->getFreePopulation();
	if (getStartPercent()				== 0)			m_iStartPercent					= pClassInfo->getStartPercent();
	if (getGrowthPercent()				== 0)			m_iGrowthPercent				= pClassInfo->getGrowthPercent();
	if (getTrainPercent()				== 0)			m_iTrainPercent					= pClassInfo->getTrainPercent();
	if (getConstructPercent()			== 0)			m_iConstructPercent				= pClassInfo->getConstructPercent();
	if (getCreatePercent()				== 0)			m_iCreatePercent				= pClassInfo->getCreatePercent();
	if (getResearchPercent()			== 0)			m_iResearchPercent				= pClassInfo->getResearchPercent();
	if (getBuildPercent()				== 0)			m_iBuildPercent					= pClassInfo->getBuildPercent();
	if (getImprovementPercent()			== 0)			m_iImprovementPercent			= pClassInfo->getImprovementPercent();
	if (getGreatPeoplePercent()			== 0)			m_iGreatPeoplePercent			= pClassInfo->getGreatPeoplePercent();
	if (getAnarchyPercent()				== 0)			m_iAnarchyPercent				= pClassInfo->getAnarchyPercent();
	if (getEventChancePerTurn()			== 0)			m_iEventChancePerTurn			= pClassInfo->getEventChancePerTurn();
	if (getSoundtrackSpace()			== 0)			m_iSoundtrackSpace				= pClassInfo->getSoundtrackSpace();
	if (isFirstSoundtrackFirst()		== false)		m_bFirstSoundtrackFirst			= pClassInfo->isFirstSoundtrackFirst();
	if (getAudioUnitVictoryScript()		== cDefault)	m_szAudioUnitVictoryScript		= pClassInfo->getAudioUnitVictoryScript();
	if (getAudioUnitDefeatScript()		== cDefault)	m_szAudioUnitDefeatScript		= pClassInfo->getAudioUnitDefeatScript();
	if (pClassInfo->getNumSoundtracks()	!= 0)
	{
		int iNumSoundTracks = getNumSoundtracks() + pClassInfo->getNumSoundtracks();
		int* m_paiSoundtracksTemp = new int[iNumSoundTracks];
		for (int i = 0; i < iNumSoundTracks; i++)
		{
			if (i < getNumSoundtracks())
			{
				m_paiSoundtracksTemp[i] = getSoundtracks(i);
			}
			else
			{
				m_paiSoundtracksTemp[i] = pClassInfo->getSoundtracks(i - getNumSoundtracks());
			}
		}
		SAFE_DELETE_ARRAY(m_paiSoundtracks);
		m_paiSoundtracks = new int[iNumSoundTracks];
		for (int i = 0; i < iNumSoundTracks; i++)
		{
														m_paiSoundtracks[i]				= m_paiSoundtracksTemp[i];
		}
		SAFE_DELETE_ARRAY(m_paiSoundtracksTemp);
	}
	for (int i = 0; i <  GC.getNumCitySizeTypes(); i++)
	{
		if (getCitySoundscapeSciptId(i) == -1)			m_paiCitySoundscapeSciptIds[i]	= pClassInfo->getCitySoundscapeSciptId(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvColorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvColorInfo::CvColorInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvColorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvColorInfo::~CvColorInfo()
{
}

const NiColorA& CvColorInfo::getColor() const
{
	return m_Color;
}

bool CvColorInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	float afColorVals[4];	// array to hold the 4 color values, red, green, blue, and alpha

	pXML->GetChildXmlValByName(&afColorVals[0], "fRed");
	pXML->GetChildXmlValByName(&afColorVals[1], "fGreen");
	pXML->GetChildXmlValByName(&afColorVals[2], "fBlue");
	pXML->GetChildXmlValByName(&afColorVals[3], "fAlpha");

	m_Color = NiColorA(afColorVals[0], afColorVals[1], afColorVals[2], afColorVals[3]);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvColorInfo::copyNonDefaults(CvColorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

//	if (afColorVals[0] == 0.0f && afColorVals[1] == 0.0f && afColorVals[2] == 0.0f
//		 && afColorVals[3] == 0.0f) m_Color = pClassInfo->getColor();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvPlayerColorInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvPlayerColorInfo::CvPlayerColorInfo() :
m_iColorTypePrimary(NO_COLOR),
m_iColorTypeSecondary(NO_COLOR),
m_iTextColorType(NO_COLOR)
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvPlayerColorInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvPlayerColorInfo::~CvPlayerColorInfo()
{
}

int CvPlayerColorInfo::getColorTypePrimary() const
{
	return m_iColorTypePrimary;
}

int CvPlayerColorInfo::getColorTypeSecondary() const
{
	return m_iColorTypeSecondary;
}

int CvPlayerColorInfo::getTextColorType() const
{
	return m_iTextColorType;
}

bool CvPlayerColorInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "ColorTypePrimary");
	m_iColorTypePrimary = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "ColorTypeSecondary");
	m_iColorTypeSecondary = pXML->FindInInfoClass( szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TextColorType");
	m_iTextColorType = pXML->FindInInfoClass( szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvPlayerColorInfo::copyNonDefaults(CvPlayerColorInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getColorTypePrimary()		== NO_PLAYERCOLOR)		m_iColorTypePrimary		= pClassInfo->getColorTypePrimary();
	if (getColorTypeSecondary()		== NO_PLAYERCOLOR)		m_iColorTypeSecondary	= pClassInfo->getColorTypeSecondary();
	if (getTextColorType()			== NO_PLAYERCOLOR)		m_iTextColorType		= pClassInfo->getTextColorType();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//------------------------------------------------------------------------------------------------------
//
//	CvLandscapeInfo
//
//
CvLandscapeInfo::CvLandscapeInfo() :
m_iFogR(0),
m_iFogG(0),
m_iFogB(0),
m_iHorizontalGameCell(0),
m_iVerticalGameCell(0),
m_iPlotsPerCellX(0),
m_iPlotsPerCellY(0),
m_iHorizontalVertCnt(0),
m_iVerticalVertCnt(0),
m_iWaterHeight(0),
m_fTextureScaleX(0.0f),
m_fTextureScaleY(0.0f),
m_fZScale(0.0f),
m_bUseTerrainShader(false),
m_bUseLightmap(false),
m_bRandomMap(false)
{
}

int CvLandscapeInfo::getFogR() const
{
	return m_iFogR;
}

int CvLandscapeInfo::getFogG() const
{
	return m_iFogG;
}

int CvLandscapeInfo::getFogB() const
{
	return m_iFogB;
}

int CvLandscapeInfo::getHorizontalGameCell() const
{
	return m_iHorizontalGameCell;
}

int CvLandscapeInfo::getVerticalGameCell() const
{
	return m_iVerticalGameCell;
}

int CvLandscapeInfo::getPlotsPerCellX() const
{
	return m_iPlotsPerCellX;
}

int CvLandscapeInfo::getPlotsPerCellY() const
{
	return m_iPlotsPerCellY;
}

int CvLandscapeInfo::getHorizontalVertCnt() const
{
	return m_iHorizontalVertCnt;
}

int CvLandscapeInfo::getVerticalVertCnt() const
{
	return m_iVerticalVertCnt;
}

int CvLandscapeInfo::getWaterHeight() const
{
	return m_iWaterHeight;
}

float CvLandscapeInfo::getTextureScaleX() const
{
	return m_fTextureScaleX;
}

float CvLandscapeInfo::getTextureScaleY() const
{
	return m_fTextureScaleY;
}

float CvLandscapeInfo::getZScale() const
{
	return m_fZScale;
}

bool CvLandscapeInfo::isUseTerrainShader() const
{
	return m_bUseTerrainShader;
}

bool CvLandscapeInfo::isUseLightmap() const
{
	return m_bUseLightmap;
}
float CvLandscapeInfo::getPeakScale() const
{
	return 	m_fPeakScale;
}

float CvLandscapeInfo::getHillScale() const
{
	return 	m_fHillScale;
}

bool CvLandscapeInfo::isRandomMap() const
{
	return m_bRandomMap;
}

const TCHAR* CvLandscapeInfo::getSkyArt()
{
	return m_szSkyArt;
}

void CvLandscapeInfo::setSkyArt(const TCHAR* szPath)
{
	m_szSkyArt = szPath;
}

const TCHAR* CvLandscapeInfo::getHeightMap()
{
	return m_szHeightMap;
}

void CvLandscapeInfo::setHeightMap(const TCHAR* szPath)
{
	m_szHeightMap = szPath;
}

const TCHAR* CvLandscapeInfo::getTerrainMap()
{
	return m_szTerrainMap;
}

void CvLandscapeInfo::setTerrainMap(const TCHAR* szPath)
{
	m_szTerrainMap = szPath;
}

const TCHAR* CvLandscapeInfo::getNormalMap()
{
	return m_szNormalMap;
}

void CvLandscapeInfo::setNormalMap(const TCHAR* szPath)
{
	m_szNormalMap = szPath;
}

const TCHAR* CvLandscapeInfo::getBlendMap()
{
	return m_szBlendMap;
}

void CvLandscapeInfo::setBlendMap(const TCHAR* szPath)
{
	m_szBlendMap = szPath;
}

//
// read from xml
//
bool CvLandscapeInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iWaterHeight, "iWaterHeight");
	pXML->GetChildXmlValByName(&m_bRandomMap, "bRandomMap");

	pXML->GetChildXmlValByName(szTextVal, "HeightMap");
	setHeightMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "TerrainMap");
	setTerrainMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "NormalMap");
	setNormalMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "BlendMap");
	setBlendMap(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "SkyArt");
	setSkyArt(szTextVal);

	pXML->GetChildXmlValByName(&m_iFogR, "iFogR");
	pXML->GetChildXmlValByName(&m_iFogG, "iFogG");
	pXML->GetChildXmlValByName(&m_iFogB, "iFogB");

	pXML->GetChildXmlValByName(&m_fTextureScaleX, "fTextureScaleX");
	pXML->GetChildXmlValByName(&m_fTextureScaleY, "fTextureScaleY");

	pXML->GetChildXmlValByName(&m_iHorizontalGameCell, "iGameCellSizeX");
	pXML->GetChildXmlValByName(&m_iVerticalGameCell, "iGameCellSizeY");

	pXML->GetChildXmlValByName(&m_iPlotsPerCellX, "iPlotsPerCellX");
	pXML->GetChildXmlValByName(&m_iPlotsPerCellY, "iPlotsPerCellY");

	m_iHorizontalVertCnt = m_iPlotsPerCellX * m_iHorizontalGameCell - (m_iPlotsPerCellX - 1);
	m_iVerticalVertCnt   = m_iPlotsPerCellY * m_iVerticalGameCell - (m_iPlotsPerCellY - 1);

	pXML->GetChildXmlValByName(&m_fZScale, "fZScale");
	pXML->GetChildXmlValByName(&m_bUseTerrainShader, "bTerrainShader");
	pXML->GetChildXmlValByName(&m_bUseLightmap, "bUseLightmap");
	pXML->GetChildXmlValByName(&m_fPeakScale, "fPeakScale");
	pXML->GetChildXmlValByName(&m_fHillScale, "fHillScale");


	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvLandscapeInfo::copyNonDefaults(CvLandscapeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isRandomMap()			== false)			m_bRandomMap				= pClassInfo->isRandomMap();
	if (isUseTerrainShader()	== false)			m_bUseTerrainShader			= pClassInfo->isUseTerrainShader();
	if (isUseLightmap()			== false)			m_bUseLightmap				= pClassInfo->isUseLightmap();
	if (getHeightMap()			== cDefault)		setHeightMap(				pClassInfo->getHeightMap());
	if (getTerrainMap()			== cDefault)		setTerrainMap(				pClassInfo->getTerrainMap());
	if (getNormalMap()			== cDefault)		setNormalMap(				pClassInfo->getNormalMap());
	if (getBlendMap()			== cDefault)		setBlendMap(				pClassInfo->getBlendMap());
	if (getSkyArt()				== cDefault)		setSkyArt(					pClassInfo->getSkyArt());
	if (getWaterHeight()		== 0)				m_iWaterHeight				= pClassInfo->getWaterHeight();
	if (getFogR()				== 0)				m_iFogR						= pClassInfo->getFogR();
	if (getFogG()				== 0)				m_iFogG						= pClassInfo->getFogG();
	if (getFogB()				== 0)				m_iFogB						= pClassInfo->getFogB();
	if (getHorizontalGameCell()	== 0)				m_iHorizontalGameCell		= pClassInfo->getHorizontalGameCell();
	if (getVerticalGameCell()	== 0)				m_iVerticalGameCell			= pClassInfo->getVerticalGameCell();
	if (getPlotsPerCellX()		== 0)				m_iPlotsPerCellX			= pClassInfo->getPlotsPerCellX();
	if (getPlotsPerCellY()		== 0)				m_iPlotsPerCellY			= pClassInfo->getPlotsPerCellY();
													m_iHorizontalVertCnt		= m_iPlotsPerCellX * m_iHorizontalGameCell - (m_iPlotsPerCellX - 1);
													m_iVerticalVertCnt			= m_iPlotsPerCellY * m_iVerticalGameCell - (m_iPlotsPerCellY - 1);
	if (getTextureScaleX()		== 0.0f)			m_fTextureScaleX			= pClassInfo->getTextureScaleX();
	if (getTextureScaleY()		== 0.0f)			m_fTextureScaleY			= pClassInfo->getTextureScaleY();
	if (getZScale()				== 0.0f)			m_fZScale					= pClassInfo->getZScale();
	if (getPeakScale()			== 0.0f)			m_fPeakScale				= pClassInfo->getPeakScale();
	if (getHillScale()			== 0.0f)			m_fHillScale				= pClassInfo->getHillScale();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
// CvGameText
//////////////////////////////////////////////////////////////////////////

// static
int CvGameText::NUM_LANGUAGES = 0;

int CvGameText::getNumLanguages() const
{
	return NUM_LANGUAGES;
}
void CvGameText::setNumLanguages(int iNum)
{
	NUM_LANGUAGES = iNum;
}

CvGameText::CvGameText() :
	m_szGender("N"),
	m_szPlural("false")
{
}

const wchar* CvGameText::getText() const
{
	return m_szText;
}

void CvGameText::setText(const wchar* szText)
{
	m_szText = szText;
}

bool CvGameText::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	CvWString wszTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	gDLL->getXMLIFace()->SetToChild(pXML->GetXML()); // Move down to Child level
	pXML->GetXmlVal(m_szType);		// TAG

	static const int iMaxNumLanguages = GC.getDefineINT("MAX_NUM_LANGUAGES");
	int iNumLanguages = NUM_LANGUAGES ? NUM_LANGUAGES : iMaxNumLanguages + 1;

	int j=0;
	for (j = 0; j < iNumLanguages; j++)
	{
		pXML->SkipToNextVal();	// skip comments

		if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()) || j == iMaxNumLanguages)
		{
			NUM_LANGUAGES = j;
			break;
		}
		if (j == GAMETEXT.getCurrentLanguage()) // Only add appropriate language Text
		{
			// TEXT
			if (pXML->GetChildXmlValByName(wszTextVal, "Text"))
			{
				setText(wszTextVal);
			}
			else
			{
				pXML->GetXmlVal(wszTextVal);
				setText(wszTextVal);
				if (NUM_LANGUAGES > 0)
				{
					break;
				}
			}

			// GENDER
			if (pXML->GetChildXmlValByName(wszTextVal, "Gender"))
			{
				setGender(wszTextVal);
			}

			// PLURAL
			if (pXML->GetChildXmlValByName(wszTextVal, "Plural"))
			{
				setPlural(wszTextVal);
			}
			if (NUM_LANGUAGES > 0)
			{
				break;
			}
		}
	}

	gDLL->getXMLIFace()->SetToParent(pXML->GetXML()); // Move back up to Parent

	return true;
}

//////////////////////////////////////////////////////////////////////////
//
//	CvDiplomacyTextInfo
//
//

CvDiplomacyTextInfo::CvDiplomacyTextInfo() :
m_iNumResponses(0),
m_pResponses(NULL)
{
}

// note - Response member vars allocated by CvXmlLoadUtility
void CvDiplomacyTextInfo::init(int iNum)
{
	uninit();
	m_pResponses = new Response[iNum];
	m_iNumResponses=iNum;
}

void CvDiplomacyTextInfo::uninit()
{
	SAFE_DELETE_ARRAY(m_pResponses);
}

int CvDiplomacyTextInfo::getNumResponses() const
{
	return m_iNumResponses;
}

bool CvDiplomacyTextInfo::getCivilizationTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumCivilizationInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbCivilizationTypes[j];
}

bool CvDiplomacyTextInfo::getLeaderHeadTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumLeaderHeadInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbLeaderHeadTypes[j];
}

bool CvDiplomacyTextInfo::getAttitudeTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_ATTITUDE_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbAttitudeTypes[j];
}

bool CvDiplomacyTextInfo::getDiplomacyPowerTypes(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < NUM_DIPLOMACYPOWER_TYPES, "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_pbDiplomacyPowerTypes[j];
}

int CvDiplomacyTextInfo::getNumDiplomacyText(int i) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_pResponses[i].m_iNumDiplomacyText;
}

const TCHAR* CvDiplomacyTextInfo::getDiplomacyText(int i, int j) const
{
	FAssertMsg(i < getNumResponses(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < getNumDiplomacyText(i), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");
	return m_pResponses[i].m_paszDiplomacyText[j];
}

void CvDiplomacyTextInfo::Response::read(FDataStreamBase* stream)
{
	stream->Read(&m_iNumDiplomacyText);

	SAFE_DELETE_ARRAY(m_pbCivilizationTypes);
	m_pbCivilizationTypes = new bool[GC.getNumCivilizationInfos()];
	stream->Read(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);

	SAFE_DELETE_ARRAY(m_pbLeaderHeadTypes);
	m_pbLeaderHeadTypes = new bool[GC.getNumLeaderHeadInfos()];
	stream->Read(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);

	SAFE_DELETE_ARRAY(m_pbAttitudeTypes);
	m_pbAttitudeTypes = new bool[NUM_ATTITUDE_TYPES];
	stream->Read(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);

	SAFE_DELETE_ARRAY(m_pbDiplomacyPowerTypes);
	m_pbDiplomacyPowerTypes = new bool[NUM_DIPLOMACYPOWER_TYPES];
	stream->Read(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);

	SAFE_DELETE_ARRAY(m_paszDiplomacyText);
	m_paszDiplomacyText = new CvString[m_iNumDiplomacyText];
	stream->ReadString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

void CvDiplomacyTextInfo::Response::write(FDataStreamBase* stream)
{
	stream->Write(m_iNumDiplomacyText);

	stream->Write(GC.getNumCivilizationInfos(), m_pbCivilizationTypes);
	stream->Write(GC.getNumLeaderHeadInfos(), m_pbLeaderHeadTypes);
	stream->Write(NUM_ATTITUDE_TYPES, m_pbAttitudeTypes);
	stream->Write(NUM_DIPLOMACYPOWER_TYPES, m_pbDiplomacyPowerTypes);
	stream->WriteString(m_iNumDiplomacyText, m_paszDiplomacyText);
}

void CvDiplomacyTextInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);		// flag for expansion

	stream->Read(&m_iNumResponses);

	// Arrays

	init(m_iNumResponses);

	for (uint uiIndex = 0; (int) uiIndex < m_iNumResponses; uiIndex++)
	{
		m_pResponses[uiIndex].read(stream);
	}
}

void CvDiplomacyTextInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iNumResponses);

	// Arrays

	for (uint uiIndex = 0; (int) uiIndex < m_iNumResponses; uiIndex++)
	{
		m_pResponses[uiIndex].write(stream);
	}
}

bool CvDiplomacyTextInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	int j;
	pXML->GetChildXmlValByName(szTextVal, "Type");

	if ( gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Responses") )
	{
		int iIndexVal = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "Response");
		init(iIndexVal);

		for (j = 0; j < iIndexVal; j++)
		{
			if (j == 0)
			{
				gDLL->getXMLIFace()->SetToChild(pXML->GetXML());
			}
			// Civilizations
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbCivilizationTypes, "Civilizations", sizeof(GC.getCivilizationInfo((CivilizationTypes)0)), GC.getNumCivilizationInfos());
			// Leaders
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbLeaderHeadTypes, "Leaders", sizeof(GC.getLeaderHeadInfo((LeaderHeadTypes)0)), GC.getNumLeaderHeadInfos());
			// AttitudeTypes
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbAttitudeTypes, "Attitudes", sizeof(GC.getAttitudeInfo((AttitudeTypes)0)), NUM_ATTITUDE_TYPES);
			// PowerTypes
			pXML->SetVariableListTagPair(&m_pResponses[j].m_pbDiplomacyPowerTypes, "DiplomacyPowers", GC.getDiplomacyPowerTypes(), NUM_DIPLOMACYPOWER_TYPES);
			// DiplomacyText
			if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"DiplomacyText"))
			{
				pXML->SetStringList(&m_pResponses[j].m_paszDiplomacyText, &m_pResponses[j].m_iNumDiplomacyText);
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}

			if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
			{
				break;
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

	return true;
}


//////////////////////////////////////////////////////////////////////////
//
//	CvEffectInfo			Misc\CIV4EffectInfos.xml
//
//

CvEffectInfo::CvEffectInfo() :
m_fUpdateRate(0.0f),
m_bProjectile(false),
m_bSticky(false),
m_fProjectileSpeed(0.0f),
m_fProjectileArc(0.0f)
{
}

CvEffectInfo::~CvEffectInfo()
{
}

bool CvEffectInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvScalableInfo::read(pXML);

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);

	pXML->GetChildXmlValByName(&m_fUpdateRate, "fUpdateRate" );

	int iTemporary;
	pXML->GetChildXmlValByName(&iTemporary, "bIsProjectile" );
	m_bProjectile = iTemporary != 0;

	pXML->GetChildXmlValByName(&m_fProjectileSpeed, "fSpeed" );
	pXML->GetChildXmlValByName(&m_fProjectileArc, "fArcValue" );
	pXML->GetChildXmlValByName(&m_bSticky, "bSticky", false );
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEffectInfo::copyNonDefaults(CvEffectInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);
	CvScalableInfo::copyNonDefaults(pClassInfo, pXML);

	if (getPath()				== cDefault)	setPath(				pClassInfo->getPath());
	if (getUpdateRate()			== 0.0f)		m_fUpdateRate			= pClassInfo->getUpdateRate();
	if (isProjectile()			== false)		m_bProjectile			= pClassInfo->isProjectile();
	if (getProjectileSpeed()	== 0.0f)		m_fProjectileSpeed		= pClassInfo->getProjectileSpeed();
	if (getProjectileArc()		== 0.0f)		m_fProjectileArc		= pClassInfo->getProjectileArc();
	if (isSticky()				== false)		m_bSticky				= pClassInfo->isSticky();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvAttachableInfo			Misc\CIV4AttachableInfos.xml
//
//
CvAttachableInfo::CvAttachableInfo() :
m_fUpdateRate(0.0f)
{
}

CvAttachableInfo::~CvAttachableInfo()
{
}

bool CvAttachableInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	CvScalableInfo::read(pXML);

	pXML->GetChildXmlValByName(szTextVal, "Path");
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvAttachableInfo::copyNonDefaults(CvAttachableInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);
	CvScalableInfo::copyNonDefaults(pClassInfo, pXML);

	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvCameraInfo			Interface\CIV4CameraInfos.xml
//
//
bool CvCameraInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "Path");
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	CvXMLLoadUtilityModTools* p_aszDirName = new CvXMLLoadUtilityModTools;
	p_aszDirName->setLocationName( &szTextVal, (GC.getModDir()).c_str());
	SAFE_DELETE(p_aszDirName);
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	setPath(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvCameraInfo::copyNonDefaults(CvCameraInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);
	if (getPath()		== cDefault)		setPath(		pClassInfo->getPath());
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvQuestInfo			Misc\CIV4QuestInfos.xml
//
//
CvQuestInfo::CvQuestInfo() :
m_iNumQuestMessages(0),
m_iNumQuestLinks(0),
m_iNumQuestSounds(0),
m_paszQuestMessages(NULL),
m_pQuestLinks(NULL),
m_paszQuestSounds(NULL)
{
	m_szQuestScript = "NONE";
}

CvQuestInfo::~CvQuestInfo()
{
	reset();
}


void CvQuestInfo::reset()
{
	CvInfoBase::reset();
	SAFE_DELETE_ARRAY(m_paszQuestMessages);
	SAFE_DELETE_ARRAY(m_pQuestLinks);
	SAFE_DELETE_ARRAY(m_paszQuestSounds);
}

bool CvQuestInfo::initQuestLinks(int iNum)
{
	reset();
	if ( iNum > 0 )
	{
		m_pQuestLinks = new QuestLink[iNum];
		m_iNumQuestLinks = iNum;
		return true;
	}
	return false;
}

const TCHAR* CvQuestInfo::getQuestObjective() const
{
	return m_szQuestObjective;
}

const TCHAR* CvQuestInfo::getQuestBodyText() const
{
	return m_szQuestBodyText;
}

int CvQuestInfo::getNumQuestMessages() const
{
	return m_iNumQuestMessages;
}

const TCHAR* CvQuestInfo::getQuestMessages(int iIndex) const
{
	return m_paszQuestMessages ? m_paszQuestMessages[iIndex] : "";
}

int CvQuestInfo::getNumQuestLinks() const
{
	return m_iNumQuestLinks;
}

const TCHAR* CvQuestInfo::getQuestLinkType(int iIndex)  const
{
	return m_pQuestLinks[iIndex].m_szQuestLinkType;
}

const TCHAR* CvQuestInfo::getQuestLinkName(int iIndex)  const
{
	return m_pQuestLinks[iIndex].m_szQuestLinkName;
}

int CvQuestInfo::getNumQuestSounds() const
{
	return m_iNumQuestSounds;
}

const TCHAR* CvQuestInfo::getQuestSounds(int iIndex) const
{
	return m_paszQuestSounds ? m_paszQuestSounds[iIndex] : "";
}

const TCHAR* CvQuestInfo::getQuestScript() const
{
	return m_szQuestScript;
}

void CvQuestInfo::setQuestObjective(const TCHAR* szText)
{
	m_szQuestObjective = szText;
}

void CvQuestInfo::setQuestBodyText(const TCHAR* szText)
{
	m_szQuestBodyText = szText;
}

void CvQuestInfo::setNumQuestMessages(int iNum)
{
	m_iNumQuestMessages = iNum;
}

void CvQuestInfo::setQuestMessages(int iIndex, const TCHAR* szText)
{
	m_paszQuestMessages[iIndex] = szText;
}

void CvQuestInfo::setNumQuestSounds(int iNum)
{
	m_iNumQuestSounds = iNum;
}

void CvQuestInfo::setQuestSounds(int iIndex, const TCHAR* szText)
{
	m_paszQuestSounds[iIndex] = szText;
}

void CvQuestInfo::setQuestScript(const TCHAR* szText)
{
	m_szQuestScript = szText;
}

bool CvQuestInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(szTextVal, "QuestObjective");
	setQuestObjective(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "QuestBodyText");
	setQuestBodyText(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "QuestMessages"))
	{
		pXML->SetStringList(&m_paszQuestMessages, &m_iNumQuestMessages);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"QuestLinks"))
	{
		int iNum;
		iNum = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "QuestLink");

		if (initQuestLinks(iNum))
		{
			int i;
			for (i=0; i<m_iNumQuestLinks; i++)
			{
				pXML->GetChildXmlValByName(szTextVal, "QuestLinkType");
				m_pQuestLinks[i].m_szQuestLinkType = szTextVal;

				pXML->GetChildXmlValByName(szTextVal, "QuestLinkName");
				m_pQuestLinks[i].m_szQuestLinkName = szTextVal;

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "QuestSounds"))
	{
		pXML->SetStringList(&m_paszQuestSounds, &m_iNumQuestSounds);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "QuestScript");
	setQuestScript(szTextVal);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvQuestInfo::copyNonDefaults(CvQuestInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getQuestObjective()		== cDefault)	setQuestObjective(								pClassInfo->getQuestObjective());
	if (getQuestBodyText()		== cDefault)	setQuestBodyText(								pClassInfo->getQuestBodyText());
    if (getQuestScript()		== cDefault)	setQuestScript(									pClassInfo->getQuestScript());

	// Add new QuestMessages
	if (pClassInfo->getNumQuestMessages() != 0)
	{
		CvString* m_paszNewMessages = new CvString[pClassInfo->getNumQuestMessages()];
		for ( int i = 0; i < pClassInfo->getNumQuestMessages(); i++)
		{
			m_paszNewMessages[i] = pClassInfo->getQuestMessages(i);
		}

		CvXMLLoadUtilityModTools* pCurrentInfoClass = new CvXMLLoadUtilityModTools;
		pCurrentInfoClass->StringArrayExtend(	&m_paszQuestMessages, &m_iNumQuestMessages,		&m_paszNewMessages, pClassInfo->getNumQuestMessages());
		SAFE_DELETE_ARRAY(m_paszNewMessages)
	}
	if (pClassInfo->getNumQuestLinks() > 0)
	{
		int m_iNumQuestSoundsTemp = m_iNumQuestSounds + pClassInfo->getNumQuestLinks();
		QuestLink* m_pQuestLinksTemp = new QuestLink[m_iNumQuestSoundsTemp];
		int iCurrentClass = 0;
		for (int i = 0; i < m_iNumQuestSoundsTemp; i++)
		{
			if (i < pClassInfo->getNumQuestLinks())
			{
				m_pQuestLinksTemp[i].m_szQuestLinkType = pClassInfo->getQuestLinkType(i);
				m_pQuestLinksTemp[i].m_szQuestLinkName = pClassInfo->getQuestLinkName(i);
			}
			else
			{
				m_pQuestLinksTemp[i].m_szQuestLinkType = getQuestLinkType(iCurrentClass);
				m_pQuestLinksTemp[i].m_szQuestLinkName = getQuestLinkName(iCurrentClass);
				iCurrentClass++;
			}
		}
		SAFE_DELETE_ARRAY(m_pQuestLinks);
		m_pQuestLinks = new QuestLink[m_iNumQuestSoundsTemp];
		for (int i = 0; i < m_iNumQuestSoundsTemp; i++)
		{
												m_pQuestLinks[i].m_szQuestLinkType				= m_pQuestLinksTemp[i].m_szQuestLinkType;
												m_pQuestLinks[i].m_szQuestLinkName				= m_pQuestLinksTemp[i].m_szQuestLinkName;
		}
		SAFE_DELETE_ARRAY(m_pQuestLinksTemp);
	}
	// Add new QuestSounds
	if (pClassInfo->getNumQuestSounds() != 0)
	{
		CvString* m_paszNewSounds = new CvString[pClassInfo->getNumQuestSounds()];
		for ( int i = 0; i < pClassInfo->getNumQuestSounds(); i++)
		{
			m_paszNewSounds[i] = pClassInfo->getQuestSounds(i);
		}
		CvXMLLoadUtilityModTools* pCurrentInfoClass = new CvXMLLoadUtilityModTools;
		pCurrentInfoClass->StringArrayExtend(	&m_paszQuestSounds, &m_iNumQuestSounds,			&m_paszNewSounds, pClassInfo->getNumQuestSounds());
		SAFE_DELETE_ARRAY(m_paszNewSounds)
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvTutorialMessage
//
CvTutorialMessage::CvTutorialMessage() :
m_iNumTutorialScripts(0),
m_paszTutorialScripts(NULL)
{
	m_szTutorialMessageText = "No Text";
	m_szTutorialMessageImage = "No Text";
	m_szTutorialMessageSound = "No Text";
}

CvTutorialMessage::~CvTutorialMessage()
{
	SAFE_DELETE_ARRAY(m_paszTutorialScripts);
}

const TCHAR* CvTutorialMessage::getText() const
{
	return m_szTutorialMessageText;
}

const TCHAR* CvTutorialMessage::getImage() const
{
	return m_szTutorialMessageImage;
}

const TCHAR* CvTutorialMessage::getSound() const
{
	return m_szTutorialMessageSound;
}

void CvTutorialMessage::setText(const TCHAR* szText)
{
	m_szTutorialMessageText = szText;
}

void CvTutorialMessage::setImage(const TCHAR* szText)
{
	m_szTutorialMessageImage = szText;
}

void CvTutorialMessage::setSound(const TCHAR* szText)
{
	m_szTutorialMessageSound = szText;
}

int CvTutorialMessage::getNumTutorialScripts() const
{
	return m_iNumTutorialScripts;
}

const TCHAR* CvTutorialMessage::getTutorialScriptByIndex(int i) const
{
	return m_paszTutorialScripts[i];
}

bool CvTutorialMessage::read(CvXMLLoadUtility* pXML)
{
	// Skip any comments and stop at the next value we might want
	if (!pXML->SkipToNextVal())
	{
		return false;
	}
	CvString szTextVal;

	pXML->MapChildren();	// try to hash children for fast lookup by name
	if (pXML->GetChildXmlValByName(szTextVal, "TutorialMessageText"))
	{
		setText(szTextVal);
	}
	if (pXML->GetChildXmlValByName(szTextVal, "TutorialMessageImage"))
	{
		setImage(szTextVal);
	}
	if (pXML->GetChildXmlValByName(szTextVal, "TutorialMessageSound"))
	{
		setSound(szTextVal);
	}
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(), "TutorialScripts"))
	{
		pXML->SetStringList(&m_paszTutorialScripts, &m_iNumTutorialScripts);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	return true;
}


CvTutorialInfo::CvTutorialInfo() :
m_iNumTutorialMessages(0),
m_paTutorialMessages(NULL)
{
	m_szNextTutorialInfoType = "NONE";
}

CvTutorialInfo::~CvTutorialInfo()
{
	resetMessages();
}

const TCHAR* CvTutorialInfo::getNextTutorialInfoType()
{
	return m_szNextTutorialInfoType;
}

void CvTutorialInfo::setNextTutorialInfoType(const TCHAR* szVal)
{
	m_szNextTutorialInfoType = szVal;
}

bool CvTutorialInfo::initTutorialMessages(int iNum)
{
	resetMessages();
	m_paTutorialMessages = new CvTutorialMessage[iNum];
	m_iNumTutorialMessages = iNum;
	return true;
}

void CvTutorialInfo::resetMessages()
{
	SAFE_DELETE_ARRAY(m_paTutorialMessages);
	m_iNumTutorialMessages = 0;
}

int CvTutorialInfo::getNumTutorialMessages() const
{
	return m_iNumTutorialMessages;
}

const CvTutorialMessage* CvTutorialInfo::getTutorialMessage(int iIndex) const
{
	return &m_paTutorialMessages[iIndex];
}

bool CvTutorialInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	CvString szTextVal;

	pXML->MapChildren();	// try to hash children for fast lookup by name
	if (pXML->GetChildXmlValByName(szTextVal, "NextTutorialInfoType"))
	{
		setNextTutorialInfoType(szTextVal);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TutorialMessages"))
	{
		int iNum;
		iNum = gDLL->getXMLIFace()->NumOfChildrenByTagName(pXML->GetXML(), "TutorialMessage");
		if ( iNum > 0 )
		{
			gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TutorialMessage");
			initTutorialMessages(iNum);
			for (int i = 0; i<m_iNumTutorialMessages; i++)
			{
				if (!m_paTutorialMessages[i].read(pXML))
				{
					return false;
				}

				if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
				{
					break;
				}
			}
			gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvTutorialInfo::copyNonDefaults(CvTutorialInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getNextTutorialInfoType()	== cDefault)	setNextTutorialInfoType(	pClassInfo->getNextTutorialInfoType());

/*	if (pClassInfo->getNumTutorialMessages() > 0)
	{
		int m_iNumTutorialMessagesTemp = m_iNumTutorialMessages + pClassInfo->getNumTutorialMessages();
		CvTutorialMessage* m_paTutorialMessagesTemp = new CvTutorialMessage[m_iNumTutorialMessagesTemp];
		int iCurrentClass = 0;
		for (int i = 0; i < m_iNumTutorialMessagesTemp; i++)
		{
			if (i < pClassInfo->getNumTutorialMessages())
			{
				m_paTutorialMessagesTemp[i] = pClassInfo->getTutorialMessage(i);
			}
			else
			{
				m_paTutorialMessagesTemp[i] = getTutorialMessage(iCurrentClass);
				iCurrentClass++;
			}
		}
		SAFE_DELETE_ARRAY(m_paTutorialMessages);
		m_paTutorialMessages = new CvTutorialMessage[m_iNumTutorialMessagesTemp];

		for (int i = 0; i < m_iNumTutorialMessagesTemp; i++)
		{
													m_paTutorialMessages[i]		= m_paTutorialMessagesTemp[i];
		}
		SAFE_DELETE_ARRAY(m_paTutorialMessagesTemp);
	}
*/
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvGameOptionInfo
//	Game options and their default values
//
//
CvGameOptionInfo::CvGameOptionInfo() :
m_bDefault(false),
m_bVisible(true)
{
}

CvGameOptionInfo::~CvGameOptionInfo()
{
}

bool CvGameOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvGameOptionInfo::getVisible() const
{
	return m_bVisible;
}

bool CvGameOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");
	pXML->GetChildXmlValByName(&m_bVisible, "bVisible");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGameOptionInfo::copyNonDefaults(CvGameOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
	if (getVisible()		== false)		m_bVisible		= pClassInfo->getVisible();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvMPOptionInfo
//	Multiplayer options and their default values
//
//
CvMPOptionInfo::CvMPOptionInfo() :
m_bDefault(false)
{
}

CvMPOptionInfo::~CvMPOptionInfo()
{
}

bool CvMPOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvMPOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvMPOptionInfo::copyNonDefaults(CvMPOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvForceControlInfo
//	Forced Controls and their default values
//
//
CvForceControlInfo::CvForceControlInfo() :
m_bDefault(false)
{
}

CvForceControlInfo::~CvForceControlInfo()
{
}

bool CvForceControlInfo::getDefault() const
{
	return m_bDefault;
}

bool CvForceControlInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvForceControlInfo::copyNonDefaults(CvForceControlInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvPlayerOptionInfo
//	Player options and their default values
//
//
CvPlayerOptionInfo::CvPlayerOptionInfo() :
m_bDefault(false)
{
}

CvPlayerOptionInfo::~CvPlayerOptionInfo()
{
}

bool CvPlayerOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvPlayerOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvPlayerOptionInfo::copyNonDefaults(CvPlayerOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvGraphicOptionInfo
//	Graphic options and their default values
//
//
CvGraphicOptionInfo::CvGraphicOptionInfo() :
m_bDefault(false)
{
}

CvGraphicOptionInfo::~CvGraphicOptionInfo()
{
}

bool CvGraphicOptionInfo::getDefault() const
{
	return m_bDefault;
}

bool CvGraphicOptionInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bDefault, "bDefault");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvGraphicOptionInfo::copyNonDefaults(CvGraphicOptionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getDefault()		== false)		m_bDefault		= pClassInfo->getDefault();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvEventTriggerInfo
//	Event triggers
//
//
CvEventTriggerInfo::CvEventTriggerInfo() :
	m_iPercentGamesActive(0),
	m_iProbability(0),
	m_iNumUnits(0),
	m_iNumBuildings(0),
	m_iNumUnitsGlobal(0),
	m_iNumBuildingsGlobal(0),
	m_iNumPlotsRequired(0),
	m_iPlotType(0),
	m_iNumReligions(0),
	m_iNumCorporations(0),
	m_iOtherPlayerShareBorders(0),
	m_iOtherPlayerHasTech(NO_TECH),
	m_iCivic(NO_CIVIC),
	m_iMinPopulation(0),
	m_iMaxPopulation(0),
	m_iMinMapLandmass(0),
	m_iMinOurLandmass(0),
	m_iMaxOurLandmass(0),
	m_iMinDifficulty(NO_HANDICAP),
	m_iAngry(0),
	m_iUnhealthy(0),
	m_iUnitDamagedWeight(0),
	m_iUnitDistanceWeight(0),
	m_iUnitExperienceWeight(0),
	m_iMinTreasury(0),
	m_bSinglePlayer(false),
	m_bTeam(false),
	m_bRecurring(false),
	m_bGlobal(false),
	m_bPickPlayer(false),
	m_bOtherPlayerWar(false),
	m_bOtherPlayerHasReligion(false),
	m_bOtherPlayerHasOtherReligion(false),
	m_bOtherPlayerAI(false),
	m_bPickCity(false),
	m_bPickOtherPlayerCity(false),
	m_bShowPlot(true),
	m_iCityFoodWeight(0),
	m_bUnitsOnPlot(false),
	m_bOwnPlot(false),
	m_bPickReligion(false),
	m_bStateReligion(false),
	m_bHolyCity(false),
	m_bPickCorporation(false),
	m_bHeadquarters(false),
	m_bProbabilityUnitMultiply(false),
	m_bProbabilityBuildingMultiply(false),
	m_bPrereqEventCity(false),

//FfH Events: Added by Kael 08/08/2007
	m_iPrereqCrime(0),
	m_iPrereqGlobalCounter(0),
	m_iPrereqAlignment(NO_ALIGNMENT),
	m_iPrereqCivilizationPleased(NO_CIVILIZATION),
	m_iPrereqLeader(NO_LEADER),
	m_iPrereqTrait(NO_TRAIT)
//FfH: End Add

{
}

CvEventTriggerInfo::~CvEventTriggerInfo()
{
}

int CvEventTriggerInfo::getPercentGamesActive() const
{
	return m_iPercentGamesActive;
}

int CvEventTriggerInfo::getProbability() const
{
	return m_iProbability;
}

int CvEventTriggerInfo::getUnitRequired(int i) const
{
	return m_aiUnitsRequired[i];
}

int CvEventTriggerInfo::getNumUnitsRequired() const
{
	return (int)m_aiUnitsRequired.size();
}

int CvEventTriggerInfo::getBuildingRequired(int i) const
{
	return m_aiBuildingsRequired[i];
}

int CvEventTriggerInfo::getNumBuildingsRequired() const
{
	return (int)m_aiBuildingsRequired.size();
}

int CvEventTriggerInfo::getNumUnits() const
{
	return m_iNumUnits;
}

int CvEventTriggerInfo::getNumBuildings() const
{
	return m_iNumBuildings;
}

int CvEventTriggerInfo::getNumUnitsGlobal() const
{
	return m_iNumUnitsGlobal;
}

int CvEventTriggerInfo::getNumBuildingsGlobal() const
{
	return m_iNumBuildingsGlobal;
}

int CvEventTriggerInfo::getNumPlotsRequired() const
{
	return m_iNumPlotsRequired;
}

int CvEventTriggerInfo::getPlotType() const
{
	return m_iPlotType;
}

int CvEventTriggerInfo::getNumReligions() const
{
	return m_iNumReligions;
}

int CvEventTriggerInfo::getNumCorporations() const
{
	return m_iNumCorporations;
}

int CvEventTriggerInfo::getOtherPlayerShareBorders() const
{
	return m_iOtherPlayerShareBorders;
}

int CvEventTriggerInfo::getOtherPlayerHasTech() const
{
	return m_iOtherPlayerHasTech;
}

int CvEventTriggerInfo::getCivic() const
{
	return m_iCivic;
}

int CvEventTriggerInfo::getMinPopulation() const
{
	return m_iMinPopulation;
}

int CvEventTriggerInfo::getMaxPopulation() const
{
	return m_iMaxPopulation;
}

int CvEventTriggerInfo::getMinMapLandmass() const
{
	return m_iMinMapLandmass;
}

int CvEventTriggerInfo::getMinOurLandmass() const
{
	return m_iMinOurLandmass;
}

int CvEventTriggerInfo::getMaxOurLandmass() const
{
	return m_iMaxOurLandmass;
}

int CvEventTriggerInfo::getMinDifficulty() const
{
	return m_iMinDifficulty;
}

int CvEventTriggerInfo::getAngry() const
{
	return m_iAngry;
}

int CvEventTriggerInfo::getUnhealthy() const
{
	return m_iUnhealthy;
}

int CvEventTriggerInfo::getUnitDamagedWeight() const
{
	return m_iUnitDamagedWeight;
}

int CvEventTriggerInfo::getUnitDistanceWeight() const
{
	return m_iUnitDistanceWeight;
}

int CvEventTriggerInfo::getUnitExperienceWeight() const
{
	return m_iUnitExperienceWeight;
}

int CvEventTriggerInfo::getMinTreasury() const
{
	return m_iMinTreasury;
}

int CvEventTriggerInfo::getEvent(int i) const
{
	return m_aiEvents[i];
}

int CvEventTriggerInfo::getNumEvents() const
{
	return (int)m_aiEvents.size();
}

int CvEventTriggerInfo::getPrereqEvent(int i) const
{
	return m_aiPrereqEvents[i];
}

int CvEventTriggerInfo::getNumPrereqEvents() const
{
	return (int)m_aiPrereqEvents.size();
}

int CvEventTriggerInfo::getPrereqOrTechs(int i) const
{
	return m_aiPrereqOrTechs[i];
}

int CvEventTriggerInfo::getNumPrereqOrTechs() const
{
	return (int)m_aiPrereqOrTechs.size();
}

int CvEventTriggerInfo::getPrereqAndTechs(int i) const
{
	return m_aiPrereqAndTechs[i];
}

int CvEventTriggerInfo::getNumPrereqAndTechs() const
{
	return (int)m_aiPrereqAndTechs.size();
}

int CvEventTriggerInfo::getObsoleteTech(int i) const
{
	return m_aiObsoleteTechs[i];
}

int CvEventTriggerInfo::getNumObsoleteTechs() const
{
	return (int)m_aiObsoleteTechs.size();
}

int CvEventTriggerInfo::getFeatureRequired(int i) const
{
	return m_aiFeaturesRequired[i];
}

int CvEventTriggerInfo::getNumFeaturesRequired() const
{
	return (int)m_aiFeaturesRequired.size();
}

int CvEventTriggerInfo::getTerrainRequired(int i) const
{
	return m_aiTerrainsRequired[i];
}

int CvEventTriggerInfo::getNumTerrainsRequired() const
{
	return (int)m_aiTerrainsRequired.size();
}

int CvEventTriggerInfo::getImprovementRequired(int i) const
{
	return m_aiImprovementsRequired[i];
}

int CvEventTriggerInfo::getNumImprovementsRequired() const
{
	return (int)m_aiImprovementsRequired.size();
}

int CvEventTriggerInfo::getBonusRequired(int i) const
{
	return m_aiBonusesRequired[i];
}

int CvEventTriggerInfo::getNumBonusesRequired() const
{
	return (int)m_aiBonusesRequired.size();
}

int CvEventTriggerInfo::getRouteRequired(int i) const
{
	return m_aiRoutesRequired[i];
}

int CvEventTriggerInfo::getNumRoutesRequired() const
{
	return (int)m_aiRoutesRequired.size();
}

int CvEventTriggerInfo::getReligionRequired(int i) const
{
	return m_aiReligionsRequired[i];
}

int CvEventTriggerInfo::getNumReligionsRequired() const
{
	return (int)m_aiReligionsRequired.size();
}

int CvEventTriggerInfo::getCorporationRequired(int i) const
{
	return m_aiCorporationsRequired[i];
}

int CvEventTriggerInfo::getNumCorporationsRequired() const
{
	return (int)m_aiCorporationsRequired.size();
}

bool CvEventTriggerInfo::isSinglePlayer() const
{
	return m_bSinglePlayer;
}

bool CvEventTriggerInfo::isTeam() const
{
	return m_bTeam;
}

const CvWString& CvEventTriggerInfo::getText(int i) const
{
	FAssert(i >= 0 && i < (int)m_aszText.size());
	return m_aszText[i];
}

int CvEventTriggerInfo::getTextEra(int i) const
{
	FAssert(i >= 0 && i < (int)m_aiTextEra.size());
	return m_aiTextEra[i];
}

int CvEventTriggerInfo::getNumTexts() const
{
	FAssert(m_aiTextEra.size() == m_aszText.size());
	return m_aszText.size();
}

const CvWString& CvEventTriggerInfo::getWorldNews(int i) const
{
	FAssert(i >= 0 && i < (int)m_aszWorldNews.size());
	return m_aszWorldNews[i];
}

int CvEventTriggerInfo::getNumWorldNews() const
{
	return m_aszWorldNews.size();
}

bool CvEventTriggerInfo::isRecurring() const
{
	return m_bRecurring;
}

bool CvEventTriggerInfo::isGlobal() const
{
	return m_bGlobal;
}

bool CvEventTriggerInfo::isPickPlayer() const
{
	return m_bPickPlayer;
}

bool CvEventTriggerInfo::isOtherPlayerWar() const
{
	return m_bOtherPlayerWar;
}

bool CvEventTriggerInfo::isOtherPlayerHasReligion() const
{
	return m_bOtherPlayerHasReligion;
}

bool CvEventTriggerInfo::isOtherPlayerHasOtherReligion() const
{
	return m_bOtherPlayerHasOtherReligion;
}

bool CvEventTriggerInfo::isOtherPlayerAI() const
{
	return m_bOtherPlayerAI;
}

bool CvEventTriggerInfo::isPickCity() const
{
	return m_bPickCity;
}

bool CvEventTriggerInfo::isPickOtherPlayerCity() const
{
	return m_bPickOtherPlayerCity;
}

bool CvEventTriggerInfo::isShowPlot() const
{
	return m_bShowPlot;
}

int CvEventTriggerInfo::getCityFoodWeight() const
{
	return m_iCityFoodWeight;
}

bool CvEventTriggerInfo::isUnitsOnPlot() const
{
	return m_bUnitsOnPlot;
}

bool CvEventTriggerInfo::isOwnPlot() const
{
	return m_bOwnPlot;
}

bool CvEventTriggerInfo::isPickReligion() const
{
	return m_bPickReligion;
}

bool CvEventTriggerInfo::isStateReligion() const
{
	return m_bStateReligion;
}

bool CvEventTriggerInfo::isHolyCity() const
{
	return m_bHolyCity;
}

bool CvEventTriggerInfo::isPickCorporation() const
{
	return m_bPickCorporation;
}

bool CvEventTriggerInfo::isHeadquarters() const
{
	return m_bHeadquarters;
}

bool CvEventTriggerInfo::isProbabilityUnitMultiply() const
{
	return m_bProbabilityUnitMultiply;
}

bool CvEventTriggerInfo::isProbabilityBuildingMultiply() const
{
	return m_bProbabilityBuildingMultiply;
}

bool CvEventTriggerInfo::isPrereqEventCity() const
{
	return m_bPrereqEventCity;
}

const char* CvEventTriggerInfo::getPythonCallback() const
{
	return m_szPythonCallback;
}

const char* CvEventTriggerInfo::getPythonCanDo() const
{
	return m_szPythonCanDo;
}

const char* CvEventTriggerInfo::getPythonCanDoCity() const
{
	return m_szPythonCanDoCity;
}

const char* CvEventTriggerInfo::getPythonCanDoUnit() const
{
	return m_szPythonCanDoUnit;
}

//FfH Events: Added by Kael 08/08/2007
int CvEventTriggerInfo::getPrereqCrime() const
{
	return m_iPrereqCrime;
}

int CvEventTriggerInfo::getPrereqGlobalCounter() const
{
	return m_iPrereqGlobalCounter;
}

int CvEventTriggerInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

int CvEventTriggerInfo::getPrereqCivilizationPleased() const
{
	return m_iPrereqCivilizationPleased;
}

int CvEventTriggerInfo::getPrereqLeader() const
{
	return m_iPrereqLeader;
}

int CvEventTriggerInfo::getPrereqTrait() const
{
	return m_iPrereqTrait;
}
//FfH: End Add

// Begin EmperorFool: Events with Images
const TCHAR* CvEventTriggerInfo::getEventArt() const
{
	if (m_szEventArt.empty())
	{
		return NULL;
	}

	return m_szEventArt;
}
// End EmperorFool: Events with Images

void CvEventTriggerInfo::read(FDataStreamBase* stream)
{
	int iNumElements;
	int iElement;
	CvWString szElement;

	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_iPercentGamesActive);
	stream->Read(&m_iProbability);
	stream->Read(&m_iNumUnits);
	stream->Read(&m_iNumBuildings);
	stream->Read(&m_iNumUnitsGlobal);
	stream->Read(&m_iNumBuildingsGlobal);
	stream->Read(&m_iNumPlotsRequired);
	stream->Read(&m_iPlotType);
	stream->Read(&m_iNumReligions);
	stream->Read(&m_iNumCorporations);
	stream->Read(&m_iOtherPlayerShareBorders);
	stream->Read(&m_iOtherPlayerHasTech);
	stream->Read(&m_iCivic);
	stream->Read(&m_iMinPopulation);
	stream->Read(&m_iMaxPopulation);
	stream->Read(&m_iMinMapLandmass);
	stream->Read(&m_iMinOurLandmass);
	stream->Read(&m_iMaxOurLandmass);
	stream->Read(&m_iMinDifficulty);
	stream->Read(&m_iAngry);
	stream->Read(&m_iUnhealthy);
	stream->Read(&m_iUnitDamagedWeight);
	stream->Read(&m_iUnitDistanceWeight);
	stream->Read(&m_iUnitExperienceWeight);
	stream->Read(&m_iMinTreasury);

	stream->Read(&iNumElements);
	m_aiUnitsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiUnitsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiBuildingsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiBuildingsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiPrereqOrTechs.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqOrTechs.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiPrereqAndTechs.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqAndTechs.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiObsoleteTechs.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiObsoleteTechs.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiEvents.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiEvents.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiPrereqEvents.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiPrereqEvents.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiFeaturesRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiFeaturesRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiTerrainsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiTerrainsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiImprovementsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiImprovementsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiBonusesRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiBonusesRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiRoutesRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiRoutesRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiReligionsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiReligionsRequired.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aiCorporationsRequired.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiCorporationsRequired.push_back(iElement);
	}

	stream->Read(&m_bSinglePlayer);
	stream->Read(&m_bTeam);
	stream->Read(&m_bRecurring);
	stream->Read(&m_bGlobal);
	stream->Read(&m_bPickPlayer);
	stream->Read(&m_bOtherPlayerWar);
	stream->Read(&m_bOtherPlayerHasReligion);
	stream->Read(&m_bOtherPlayerHasOtherReligion);
	stream->Read(&m_bOtherPlayerAI);
	stream->Read(&m_bPickCity);
	stream->Read(&m_bPickOtherPlayerCity);
	stream->Read(&m_bShowPlot);
	stream->Read(&m_iCityFoodWeight);
	stream->Read(&m_bUnitsOnPlot);
	stream->Read(&m_bOwnPlot);
	stream->Read(&m_bPickReligion);
	stream->Read(&m_bStateReligion);
	stream->Read(&m_bHolyCity);
	stream->Read(&m_bPickCorporation);
	stream->Read(&m_bHeadquarters);
	stream->Read(&m_bProbabilityUnitMultiply);
	stream->Read(&m_bProbabilityBuildingMultiply);
	stream->Read(&m_bPrereqEventCity);

	stream->Read(&iNumElements);
	m_aszText.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->ReadString(szElement);
		m_aszText.push_back(szElement);
	}

	m_aiTextEra.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->Read(&iElement);
		m_aiTextEra.push_back(iElement);
	}

	stream->Read(&iNumElements);
	m_aszWorldNews.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->ReadString(szElement);
		m_aszWorldNews.push_back(szElement);
	}

	stream->ReadString(m_szPythonCallback);
	stream->ReadString(m_szPythonCanDo);
	stream->ReadString(m_szPythonCanDoCity);
	stream->ReadString(m_szPythonCanDoUnit);

//FfH Events: Added by Kael 08/08/2007
	stream->Read(&m_iPrereqCrime);
	stream->Read(&m_iPrereqGlobalCounter);
	stream->Read(&m_iPrereqAlignment);
	stream->Read(&m_iPrereqCivilizationPleased);
	stream->Read(&m_iPrereqLeader);
	stream->Read(&m_iPrereqTrait);
//FfH: End Add

}

void CvEventTriggerInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_iPercentGamesActive);
	stream->Write(m_iProbability);
	stream->Write(m_iNumUnits);
	stream->Write(m_iNumBuildings);
	stream->Write(m_iNumUnitsGlobal);
	stream->Write(m_iNumBuildingsGlobal);
	stream->Write(m_iNumPlotsRequired);
	stream->Write(m_iPlotType);
	stream->Write(m_iNumReligions);
	stream->Write(m_iNumCorporations);
	stream->Write(m_iOtherPlayerShareBorders);
	stream->Write(m_iOtherPlayerHasTech);
	stream->Write(m_iCivic);
	stream->Write(m_iMinPopulation);
	stream->Write(m_iMaxPopulation);
	stream->Write(m_iMinMapLandmass);
	stream->Write(m_iMinOurLandmass);
	stream->Write(m_iMaxOurLandmass);
	stream->Write(m_iMinDifficulty);
	stream->Write(m_iAngry);
	stream->Write(m_iUnhealthy);
	stream->Write(m_iUnitDamagedWeight);
	stream->Write(m_iUnitDistanceWeight);
	stream->Write(m_iUnitExperienceWeight);
	stream->Write(m_iMinTreasury);

	stream->Write(m_aiUnitsRequired.size());
	for (std::vector<int>::iterator it = m_aiUnitsRequired.begin(); it != m_aiUnitsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiBuildingsRequired.size());
	for (std::vector<int>::iterator it = m_aiBuildingsRequired.begin(); it != m_aiBuildingsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiPrereqOrTechs.size());
	for (std::vector<int>::iterator it = m_aiPrereqOrTechs.begin(); it != m_aiPrereqOrTechs.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiPrereqAndTechs.size());
	for (std::vector<int>::iterator it = m_aiPrereqAndTechs.begin(); it != m_aiPrereqAndTechs.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiObsoleteTechs.size());
	for (std::vector<int>::iterator it = m_aiObsoleteTechs.begin(); it != m_aiObsoleteTechs.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiEvents.size());
	for (std::vector<int>::iterator it = m_aiEvents.begin(); it != m_aiEvents.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiPrereqEvents.size());
	for (std::vector<int>::iterator it = m_aiPrereqEvents.begin(); it != m_aiPrereqEvents.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiFeaturesRequired.size());
	for (std::vector<int>::iterator it = m_aiFeaturesRequired.begin(); it != m_aiFeaturesRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiTerrainsRequired.size());
	for (std::vector<int>::iterator it = m_aiTerrainsRequired.begin(); it != m_aiTerrainsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiImprovementsRequired.size());
	for (std::vector<int>::iterator it = m_aiImprovementsRequired.begin(); it != m_aiImprovementsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiBonusesRequired.size());
	for (std::vector<int>::iterator it = m_aiBonusesRequired.begin(); it != m_aiBonusesRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiRoutesRequired.size());
	for (std::vector<int>::iterator it = m_aiRoutesRequired.begin(); it != m_aiRoutesRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiReligionsRequired.size());
	for (std::vector<int>::iterator it = m_aiReligionsRequired.begin(); it != m_aiReligionsRequired.end(); ++it)
	{
		stream->Write(*it);
	}
	stream->Write(m_aiCorporationsRequired.size());
	for (std::vector<int>::iterator it = m_aiCorporationsRequired.begin(); it != m_aiCorporationsRequired.end(); ++it)
	{
		stream->Write(*it);
	}

	stream->Write(m_bSinglePlayer);
	stream->Write(m_bTeam);
	stream->Write(m_bRecurring);
	stream->Write(m_bGlobal);
	stream->Write(m_bPickPlayer);
	stream->Write(m_bOtherPlayerWar);
	stream->Write(m_bOtherPlayerHasReligion);
	stream->Write(m_bOtherPlayerHasOtherReligion);
	stream->Write(m_bOtherPlayerAI);
	stream->Write(m_bPickCity);
	stream->Write(m_bPickOtherPlayerCity);
	stream->Write(m_bShowPlot);
	stream->Write(m_iCityFoodWeight);
	stream->Write(m_bUnitsOnPlot);
	stream->Write(m_bOwnPlot);
	stream->Write(m_bPickReligion);
	stream->Write(m_bStateReligion);
	stream->Write(m_bHolyCity);
	stream->Write(m_bPickCorporation);
	stream->Write(m_bHeadquarters);
	stream->Write(m_bProbabilityUnitMultiply);
	stream->Write(m_bProbabilityBuildingMultiply);
	stream->Write(m_bPrereqEventCity);

	stream->Write(m_aszText.size());
	for (std::vector<CvWString>::iterator it = m_aszText.begin(); it != m_aszText.end(); ++it)
	{
		stream->WriteString(*it);
	}
	for (std::vector<int>::iterator it = m_aiTextEra.begin(); it != m_aiTextEra.end(); ++it)
	{
		stream->Write(*it);
	}

	stream->Write(m_aszWorldNews.size());
	for (std::vector<CvWString>::iterator it = m_aszWorldNews.begin(); it != m_aszWorldNews.end(); ++it)
	{
		stream->WriteString(*it);
	}

	stream->WriteString(m_szPythonCallback);
	stream->WriteString(m_szPythonCanDo);
	stream->WriteString(m_szPythonCanDoCity);
	stream->WriteString(m_szPythonCanDoUnit);

//FfH Events: Added by Kael 08/08/2007
	stream->Write(m_iPrereqCrime);
	stream->Write(m_iPrereqGlobalCounter);
	stream->Write(m_iPrereqAlignment);
	stream->Write(m_iPrereqCivilizationPleased);
	stream->Write(m_iPrereqLeader);
	stream->Write(m_iPrereqTrait);
//FfH: End Add

}

bool CvEventTriggerInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iPercentGamesActive, "iPercentGamesActive");
	pXML->GetChildXmlValByName(&m_iProbability, "iWeight");

	pXML->GetChildXmlValByName(&m_iNumUnits, "iNumUnits");
	pXML->GetChildXmlValByName(&m_iNumBuildings, "iNumBuildings");
	pXML->GetChildXmlValByName(&m_iNumUnitsGlobal, "iNumUnitsGlobal");
	pXML->GetChildXmlValByName(&m_iNumBuildingsGlobal, "iNumBuildingsGlobal");

	pXML->GetChildXmlValByName(&m_iNumPlotsRequired, "iNumPlotsRequired");
	pXML->GetChildXmlValByName(&m_iPlotType, "iPlotType");

	pXML->GetChildXmlValByName(&m_iNumReligions, "iNumReligions");
	pXML->GetChildXmlValByName(&m_iNumCorporations, "iNumCorporations");

	pXML->GetChildXmlValByName(&m_iOtherPlayerShareBorders, "iOtherPlayerShareBorders");

	pXML->GetChildXmlValByName(&m_iMinPopulation, "iMinPopulation");
	pXML->GetChildXmlValByName(&m_iMaxPopulation, "iMaxPopulation");

	pXML->GetChildXmlValByName(&m_iMinMapLandmass, "iMinMapLandmass");
	pXML->GetChildXmlValByName(&m_iMinOurLandmass, "iMinOurLandmass");
	pXML->GetChildXmlValByName(&m_iMaxOurLandmass, "iMaxOurLandmass");
	pXML->GetChildXmlValByName(szTextVal, "MinDifficulty");
	m_iMinDifficulty = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iAngry, "iAngry");
	pXML->GetChildXmlValByName(&m_iUnhealthy, "iUnhealthy");
	pXML->GetChildXmlValByName(&m_iUnitDamagedWeight, "iUnitDamagedWeight");
	pXML->GetChildXmlValByName(&m_iUnitDistanceWeight, "iUnitDistanceWeight");
	pXML->GetChildXmlValByName(&m_iUnitExperienceWeight, "iUnitExperienceWeight");
	pXML->GetChildXmlValByName(&m_iMinTreasury, "iMinTreasury");

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UnitsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiUnitsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiUnitsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiBuildingsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiBuildingsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"OrPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqOrTechs.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiPrereqOrTechs.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"AndPreReqs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqAndTechs.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiPrereqAndTechs.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(szTextVal, "OtherPlayerHasTech");
	m_iOtherPlayerHasTech = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Civic");
	m_iCivic = pXML->FindInInfoClass(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ObsoleteTechs"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiObsoleteTechs.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiObsoleteTechs.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Events"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiEvents.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiEvents.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"PrereqEvents"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiPrereqEvents.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0;j<iNumSibs;j++)
					{
						m_aiPrereqEvents.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"FeaturesRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiFeaturesRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiFeaturesRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TerrainsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiTerrainsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiTerrainsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ImprovementsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiImprovementsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiImprovementsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BonusesRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiBonusesRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiBonusesRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"RoutesRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiRoutesRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j = 0; j < iNumSibs; j++)
					{
						m_aiRoutesRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ReligionsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiReligionsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j < iNumSibs; j++)
					{
						m_aiReligionsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"CorporationsRequired"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			m_aiCorporationsRequired.clear();

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j < iNumSibs; j++)
					{
						m_aiCorporationsRequired.push_back(pXML->FindInInfoClass(szTextVal));
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aszText.clear();
	m_aiTextEra.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"TriggerTexts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							m_aszText.push_back(szTextVal);
							pXML->GetNextXmlVal(szTextVal);
							m_aiTextEra.push_back(pXML->FindInInfoClass(szTextVal));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aszWorldNews.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"WorldNewsTexts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j<iNumSibs; ++j)
					{
						m_aszWorldNews.push_back(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	pXML->GetChildXmlValByName(&m_bSinglePlayer, "bSinglePlayer");
	pXML->GetChildXmlValByName(&m_bTeam, "bTeam");
	pXML->GetChildXmlValByName(&m_bRecurring, "bRecurring");
	pXML->GetChildXmlValByName(&m_bGlobal, "bGlobal");
	pXML->GetChildXmlValByName(&m_bPickPlayer, "bPickPlayer");
	pXML->GetChildXmlValByName(&m_bOtherPlayerWar, "bOtherPlayerWar");
	pXML->GetChildXmlValByName(&m_bOtherPlayerHasReligion, "bOtherPlayerHasReligion");
	pXML->GetChildXmlValByName(&m_bOtherPlayerHasOtherReligion, "bOtherPlayerHasOtherReligion");
	pXML->GetChildXmlValByName(&m_bOtherPlayerAI, "bOtherPlayerAI");
	pXML->GetChildXmlValByName(&m_bPickCity, "bPickCity");
	pXML->GetChildXmlValByName(&m_bPickOtherPlayerCity, "bPickOtherPlayerCity");
	pXML->GetChildXmlValByName(&m_bShowPlot, "bShowPlot");
	pXML->GetChildXmlValByName(&m_iCityFoodWeight, "iCityFoodWeight");
	pXML->GetChildXmlValByName(&m_bUnitsOnPlot, "bUnitsOnPlot");
	pXML->GetChildXmlValByName(&m_bOwnPlot, "bOwnPlot");
	pXML->GetChildXmlValByName(&m_bPickReligion, "bPickReligion");
	pXML->GetChildXmlValByName(&m_bStateReligion, "bStateReligion");
	pXML->GetChildXmlValByName(&m_bHolyCity, "bHolyCity");
	pXML->GetChildXmlValByName(&m_bPickCorporation, "bPickCorporation");
	pXML->GetChildXmlValByName(&m_bHeadquarters, "bHeadquarters");
	pXML->GetChildXmlValByName(&m_bProbabilityUnitMultiply, "bProbabilityUnitMultiply");
	pXML->GetChildXmlValByName(&m_bProbabilityBuildingMultiply, "bProbabilityBuildingMultiply");
	pXML->GetChildXmlValByName(&m_bPrereqEventCity, "bPrereqEventPlot");

	pXML->GetChildXmlValByName(m_szPythonCallback, "PythonCallback");
	pXML->GetChildXmlValByName(m_szPythonCanDo, "PythonCanDo");
	pXML->GetChildXmlValByName(m_szPythonCanDoCity, "PythonCanDoCity");
	pXML->GetChildXmlValByName(m_szPythonCanDoUnit, "PythonCanDoUnit");

//FfH Events: Added by Kael 08/08/2007
	pXML->GetChildXmlValByName(&m_iPrereqCrime, "iPrereqCrime");
	pXML->GetChildXmlValByName(&m_iPrereqGlobalCounter, "iPrereqGlobalCounter");
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilizationPleased");
	m_iPrereqCivilizationPleased = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqLeader");
	m_iPrereqLeader = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqTrait");
	m_iPrereqTrait = pXML->FindInInfoClass(szTextVal);
//FfH: End Add
// Begin EmperorFool: Events with Images
	pXML->GetChildXmlValByName(m_szEventArt, "EventArt");
// End EmperorFool: Events with Images

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(EventTriggerInfos)															**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEventTriggerInfo::copyNonDefaults(CvEventTriggerInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getPercentGamesActive()						== 0)				m_iPercentGamesActive					= pClassInfo->getPercentGamesActive();
	if (getProbability()							== 0)				m_iProbability							= pClassInfo->getProbability();
	if (getNumUnits()								== 0)				m_iNumUnits								= pClassInfo->getNumUnits();
	if (getNumBuildings()							== 0)				m_iNumBuildings							= pClassInfo->getNumBuildings();
	if (getNumUnitsGlobal()							== 0)				m_iNumUnitsGlobal						= pClassInfo->getNumUnitsGlobal();
	if (getNumBuildingsGlobal()						== 0)				m_iNumBuildingsGlobal					= pClassInfo->getNumBuildingsGlobal();
	if (getNumPlotsRequired()						== 0)				m_iNumPlotsRequired						= pClassInfo->getNumPlotsRequired();
	if (getPlotType()								== 0)				m_iPlotType								= pClassInfo->getPlotType();
	if (getNumReligions()							== 0)				m_iNumReligions							= pClassInfo->getNumReligions();
	if (getNumCorporations()						== 0)				m_iNumCorporations						= pClassInfo->getNumCorporations();
	if (getOtherPlayerShareBorders()				== 0)				m_iOtherPlayerShareBorders				= pClassInfo->getOtherPlayerShareBorders();
	if (getMinPopulation()							== 0)				m_iMinPopulation						= pClassInfo->getMinPopulation();
	if (getMaxPopulation()							== 0)				m_iMaxPopulation						= pClassInfo->getMaxPopulation();
	if (getMinMapLandmass()							== 0)				m_iMinMapLandmass						= pClassInfo->getMinMapLandmass();
	if (getMinOurLandmass()							== 0)				m_iMinOurLandmass						= pClassInfo->getMinOurLandmass();
	if (getMaxOurLandmass()							== 0)				m_iMaxOurLandmass						= pClassInfo->getMaxOurLandmass();
	if (getMinDifficulty()							== NO_HANDICAP)		m_iMinDifficulty						= pClassInfo->getMinDifficulty();
	if (getAngry()									== 0)				m_iAngry								= pClassInfo->getAngry();
	if (getUnhealthy()								== 0)				m_iUnhealthy							= pClassInfo->getUnhealthy();
	if (getUnitDamagedWeight()						== 0)				m_iUnitDamagedWeight					= pClassInfo->getUnitDamagedWeight();
	if (getUnitDistanceWeight()						== 0)				m_iUnitDistanceWeight					= pClassInfo->getUnitDistanceWeight();
	if (getUnitExperienceWeight()					== 0)				m_iUnitExperienceWeight					= pClassInfo->getUnitExperienceWeight();
	if (getMinTreasury()							== 0)				m_iMinTreasury							= pClassInfo->getMinTreasury();
	if (getCityFoodWeight()							== 0)				m_iCityFoodWeight						= pClassInfo->getCityFoodWeight();
	if (getOtherPlayerHasTech()						== NO_TECH)			m_iOtherPlayerHasTech					= pClassInfo->getOtherPlayerHasTech();
	if (getCivic()									== NO_CIVIC)		m_iCivic								= pClassInfo->getCivic();
	if (isSinglePlayer()							== false)			m_bSinglePlayer							= pClassInfo->isSinglePlayer();
	if (isTeam()									== false)			m_bTeam									= pClassInfo->isTeam();
	if (isRecurring()								== false)			m_bRecurring							= pClassInfo->isRecurring();
	if (isGlobal()									== false)			m_bGlobal								= pClassInfo->isGlobal();
	if (isPickPlayer()								== false)			m_bPickPlayer							= pClassInfo->isPickPlayer();
	if (isOtherPlayerWar()							== false)			m_bOtherPlayerWar						= pClassInfo->isOtherPlayerWar();
	if (isOtherPlayerHasReligion()					== false)			m_bOtherPlayerHasReligion				= pClassInfo->isOtherPlayerHasReligion();
	if (isOtherPlayerHasOtherReligion()				== false)			m_bOtherPlayerHasOtherReligion			= pClassInfo->isOtherPlayerHasOtherReligion();
	if (isOtherPlayerAI()							== false)			m_bOtherPlayerAI						= pClassInfo->isOtherPlayerAI();
	if (isPickCity()								== false)			m_bPickCity								= pClassInfo->isPickCity();
	if (isPickOtherPlayerCity()						== false)			m_bPickOtherPlayerCity					= pClassInfo->isPickOtherPlayerCity();
	if (isShowPlot()								== false)			m_bShowPlot								= pClassInfo->isShowPlot();
	if (isUnitsOnPlot()								== false)			m_bUnitsOnPlot							= pClassInfo->isUnitsOnPlot();
	if (isOwnPlot()									== false)			m_bOwnPlot								= pClassInfo->isOwnPlot();
	if (isPickReligion()							== false)			m_bPickReligion							= pClassInfo->isPickReligion();
	if (isStateReligion()							== false)			m_bStateReligion						= pClassInfo->isStateReligion();
	if (isHolyCity()								== false)			m_bHolyCity								= pClassInfo->isHolyCity();
	if (isPickCorporation()							== false)			m_bPickCorporation						= pClassInfo->isPickCorporation();
	if (isHeadquarters()							== false)			m_bHeadquarters							= pClassInfo->isHeadquarters();
	if (isProbabilityUnitMultiply()					== false)			m_bProbabilityUnitMultiply				= pClassInfo->isProbabilityUnitMultiply();
	if (isProbabilityBuildingMultiply()				== false)			m_bProbabilityBuildingMultiply			= pClassInfo->isProbabilityBuildingMultiply();
	if (isPrereqEventCity()							== false)			m_bPrereqEventCity						= pClassInfo->isPrereqEventCity();
	if (getPrereqGlobalCounter()					== 0)				m_iPrereqGlobalCounter					= pClassInfo->getPrereqGlobalCounter();
	if (getPythonCallback()							== cDefault)		m_szPythonCallback						= pClassInfo->getPythonCallback();
	if (getPythonCanDo()							== cDefault)		m_szPythonCanDo							= pClassInfo->getPythonCanDo();
	if (getPythonCanDoCity()						== cDefault)		m_szPythonCanDoCity						= pClassInfo->getPythonCanDoCity();
	if (getPythonCanDoUnit()						== cDefault)		m_szPythonCanDoUnit						= pClassInfo->getPythonCanDoUnit();
	if (getPrereqTrait()							== NO_TRAIT)		m_iPrereqTrait							= pClassInfo->getPrereqTrait();
	if (getPrereqLeader()							== NO_LEADER)		m_iPrereqLeader							= pClassInfo->getPrereqLeader();
	if (getPrereqAlignment()						== NO_ALIGNMENT)	m_iPrereqAlignment						= pClassInfo->getPrereqAlignment();
	if (getPrereqCivilizationPleased()				== NO_CIVILIZATION)	m_iPrereqCivilizationPleased			= pClassInfo->getPrereqCivilizationPleased();

	for ( int i = 0; i < pClassInfo->getNumUnitsRequired(); i++)
	{
		if (pClassInfo->getUnitRequired(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumUnitsRequired(), &m_aiUnitsRequired[0], pClassInfo->getUnitRequired(i))))
			{
																		m_aiUnitsRequired.push_back(			pClassInfo->getUnitRequired(i));
			}
		}
	}
	for (int i = 0; i < pClassInfo->getNumBuildingsRequired(); i++)
	{
		if ( pClassInfo->getBuildingRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumBuildingsRequired(), &m_aiBuildingsRequired[0], pClassInfo->getBuildingRequired(i))))
			{
																		m_aiBuildingsRequired.push_back(		pClassInfo->getBuildingRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumPrereqOrTechs(); i++)
	{
		if ( pClassInfo->getPrereqOrTechs(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqOrTechs(), &m_aiPrereqOrTechs[0], pClassInfo->getPrereqOrTechs(i))))
			{
																		m_aiPrereqOrTechs.push_back(			pClassInfo->getPrereqOrTechs(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumPrereqAndTechs(); i++)
	{
		if ( pClassInfo->getPrereqAndTechs(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqAndTechs(), &m_aiPrereqAndTechs[0], pClassInfo->getPrereqAndTechs(i))))
			{
																		m_aiPrereqAndTechs.push_back(			pClassInfo->getPrereqAndTechs(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumObsoleteTechs(); i++)
	{
		if ( pClassInfo->getObsoleteTech(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumObsoleteTechs(), &m_aiObsoleteTechs[0], pClassInfo->getObsoleteTech(i))))
			{
																		m_aiObsoleteTechs.push_back(			pClassInfo->getObsoleteTech(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumEvents(); i++)
	{
		if ( pClassInfo->getEvent(i)				!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumEvents(), &m_aiEvents[0], pClassInfo->getEvent(i))))
			{
																		m_aiEvents.push_back(					pClassInfo->getEvent(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumPrereqEvents(); i++)
	{
		if ( pClassInfo->getPrereqEvent(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumPrereqEvents(), &m_aiPrereqEvents[0], pClassInfo->getPrereqEvent(i))))
			{
																		m_aiPrereqEvents.push_back(				pClassInfo->getPrereqEvent(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumFeaturesRequired(); i++)
	{
		if ( pClassInfo->getFeatureRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumFeaturesRequired(), &m_aiFeaturesRequired[0], pClassInfo->getFeatureRequired(i))))
			{
																		m_aiFeaturesRequired.push_back(			pClassInfo->getFeatureRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumTerrainsRequired(); i++)
	{
		if ( pClassInfo->getTerrainRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumTerrainsRequired(), &m_aiTerrainsRequired[0], pClassInfo->getTerrainRequired(i))))
			{
																		m_aiTerrainsRequired.push_back(			pClassInfo->getTerrainRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumImprovementsRequired(); i++)
	{
		if ( pClassInfo->getImprovementRequired(i)	!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumImprovementsRequired(), &m_aiImprovementsRequired[0], pClassInfo->getImprovementRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getImprovementRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumBonusesRequired(); i++)
	{
		if ( pClassInfo->getBonusRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumBonusesRequired(), &m_aiBonusesRequired[0], pClassInfo->getBonusRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getBonusRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumRoutesRequired(); i++)
	{
		if ( pClassInfo->getRouteRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumRoutesRequired(), &m_aiRoutesRequired[0], pClassInfo->getRouteRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getRouteRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumReligionsRequired(); i++)
	{
		if ( pClassInfo->getReligionRequired(i)		!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumReligionsRequired(), &m_aiReligionsRequired[0], pClassInfo->getReligionRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getReligionRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumCorporationsRequired(); i++)
	{
		if ( pClassInfo->getCorporationRequired(i)	!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumCorporationsRequired(), &m_aiCorporationsRequired[0], pClassInfo->getCorporationRequired(i))))
			{
																		m_aiImprovementsRequired.push_back(		pClassInfo->getCorporationRequired(i));
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumTexts(); i++)
	{
		if (pClassInfo->getText(i)					!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumTexts(), &m_aszText[0], pClassInfo->getText(i))))
			{
																		m_aszText.push_back(					pClassInfo->getText(i));
																		m_aiTextEra.push_back(					pClassInfo->getTextEra(i));
			}
			else //If dupe exist, we want to overwrite whatever it is(assuming the modder changed the Era on purpose)
			{
																		m_aszText[i]							= pClassInfo->getText(i);
																		m_aiTextEra[i]							= pClassInfo->getTextEra(i);
			}
		}
	}
	for ( int i = 0; i < pClassInfo->getNumWorldNews(); i++)
	{
		if ( pClassInfo->getWorldNews(i)			!= NULL)
		{
			CvXMLLoadUtilityModTools* pCurrentUnitClass = new CvXMLLoadUtilityModTools;
			if (!(pCurrentUnitClass->isDuplicate(getNumWorldNews(), &m_aszWorldNews[0], pClassInfo->getWorldNews(i))))
			{
																		m_aszWorldNews.push_back(				pClassInfo->getWorldNews(i));
			}
		}
	}
// Begin EmperorFool: Events with Images
// added Sephi
	if (getEventArt()							== cDefault)		m_szEventArt						= pClassInfo->getEventArt();
// End EmperorFool: Events with Images

}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//////////////////////////////////////////////////////////////////////////
//
//	CvEventInfo
//	Events
//
//
CvEventInfo::CvEventInfo() :
	m_bQuest(false),
	m_bGlobal(false),
	m_bTeam(false),
	m_bCityEffect(false),
	m_bOtherPlayerCityEffect(false),
	m_bGoldToPlayer(false),
	m_bGoldenAge(false),
	m_bDeclareWar(false),
	m_bDisbandUnit(false),
	m_iGold(0),
	m_iRandomGold(0),
	m_iCulture(0),
	m_iEspionagePoints(0),
	m_iTech(NO_TECH),
	m_iTechPercent(0),
	m_iTechCostPercent(0),
	m_iTechMinTurnsLeft(0),
	m_iPrereqTech(NO_TECH),
	m_iUnitClass(NO_UNITCLASS),
	m_iNumUnits(0),
	m_iUnitExperience(0),
	m_iUnitImmobileTurns(0),
	m_iBuildingClass(NO_BUILDINGCLASS),
	m_iBuildingChange(0),
	m_iHappy(0),
	m_iHealth(0),
	m_iHurryAnger(0),
	m_iHappyTurns(0),
	m_iFood(0),
	m_iFoodPercent(0),
	m_iFeature(NO_FEATURE),
	m_iFeatureChange(0),
	m_iImprovement(NO_IMPROVEMENT),
	m_iImprovementChange(0),
	m_iBonus(NO_BONUS),
	m_iBonusChange(0),
	m_iRoute(NO_ROUTE),
	m_iRouteChange(0),
	m_iBonusRevealed(NO_BONUS),
	m_iBonusGift(NO_BONUS),
	m_iConvertOwnCities(0),
	m_iConvertOtherCities(0),
	m_iMaxNumReligions(-1),
	m_iOurAttitudeModifier(0),
	m_iAttitudeModifier(0),
	m_iTheirEnemyAttitudeModifier(0),
	m_iPopulationChange(0),
	m_iRevoltTurns(0),
	m_iMinPillage(0),
	m_iMaxPillage(0),
	m_iUnitPromotion(NO_PROMOTION),
	m_iFreeUnitSupport(0),
	m_iInflationModifier(0),
	m_iSpaceProductionModifier(0),
	m_iAIValue(0),

//FfH: Added by Kael 01/21/2008
	m_iCrime(0),
	m_iGlobalCounter(0),
	m_iPrereqAlignment(NO_ALIGNMENT),
	m_iPrereqBonus(NO_BONUS),
	m_iPrereqCivilization(NO_CIVILIZATION),
	m_iPrereqCorporation(NO_CORPORATION),
	m_iPrereqReligion(NO_RELIGION),
	m_iPrereqStateReligion(NO_RELIGION),
//FfH: End Add

	m_piTechFlavorValue(NULL),
	m_piPlotExtraYields(NULL),
	m_piFreeSpecialistCount(NULL),
	m_piAdditionalEventChance(NULL),
	m_piAdditionalEventTime(NULL),
	m_piClearEventChance(NULL),
	m_piUnitCombatPromotions(NULL),
	m_piUnitClassPromotions(NULL)
{
}

CvEventInfo::~CvEventInfo()
{
	SAFE_DELETE_ARRAY(m_piTechFlavorValue);
	SAFE_DELETE_ARRAY(m_piPlotExtraYields);
	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	SAFE_DELETE_ARRAY(m_piAdditionalEventChance);
	SAFE_DELETE_ARRAY(m_piAdditionalEventTime);
	SAFE_DELETE_ARRAY(m_piClearEventChance);
	SAFE_DELETE_ARRAY(m_piUnitCombatPromotions);
	SAFE_DELETE_ARRAY(m_piUnitClassPromotions);
}

bool CvEventInfo::isGlobal() const
{
	return m_bGlobal;
}

bool CvEventInfo::isQuest() const
{
	return m_bQuest;
}

bool CvEventInfo::isTeam() const
{
	return m_bTeam;
}

bool CvEventInfo::isCityEffect() const
{
	return m_bCityEffect;
}

bool CvEventInfo::isOtherPlayerCityEffect() const
{
	return m_bOtherPlayerCityEffect;
}

bool CvEventInfo::isGoldToPlayer() const
{
	return m_bGoldToPlayer;
}

bool CvEventInfo::isGoldenAge() const
{
	return m_bGoldenAge;
}

bool CvEventInfo::isDeclareWar() const
{
	return m_bDeclareWar;
}

bool CvEventInfo::isDisbandUnit() const
{
	return m_bDisbandUnit;
}

int CvEventInfo::getGold() const
{
	return m_iGold;
}

int CvEventInfo::getRandomGold() const
{
	return m_iRandomGold;
}

int CvEventInfo::getCulture() const
{
	return m_iCulture;
}

int CvEventInfo::getEspionagePoints() const
{
	return m_iEspionagePoints;
}

int CvEventInfo::getTech() const
{
	return m_iTech;
}

int CvEventInfo::getTechPercent() const
{
	return m_iTechPercent;
}

int CvEventInfo::getTechCostPercent() const
{
	return m_iTechCostPercent;
}

int CvEventInfo::getTechMinTurnsLeft() const
{
	return m_iTechMinTurnsLeft;
}

int CvEventInfo::getPrereqTech() const
{
	return m_iPrereqTech;
}

int CvEventInfo::getUnitClass() const
{
	return m_iUnitClass;
}

int CvEventInfo::getNumUnits() const
{
	return m_iNumUnits;
}

int CvEventInfo::getUnitExperience() const
{
	return m_iUnitExperience;
}

int CvEventInfo::getUnitImmobileTurns() const
{
	return m_iUnitImmobileTurns;
}

int CvEventInfo::getBuildingClass() const
{
	return m_iBuildingClass;
}

int CvEventInfo::getBuildingChange() const
{
	return m_iBuildingChange;
}

int CvEventInfo::getHappy() const
{
	return m_iHappy;
}

int CvEventInfo::getHealth() const
{
	return m_iHealth;
}

int CvEventInfo::getHurryAnger() const
{
	return m_iHurryAnger;
}

int CvEventInfo::getHappyTurns() const
{
	return m_iHappyTurns;
}

int CvEventInfo::getFood() const
{
	return m_iFood;
}

int CvEventInfo::getFoodPercent() const
{
	return m_iFoodPercent;
}

int CvEventInfo::getFeature() const
{
	return m_iFeature;
}

int CvEventInfo::getFeatureChange() const
{
	return m_iFeatureChange;
}

int CvEventInfo::getImprovement() const
{
	return m_iImprovement;
}

int CvEventInfo::getImprovementChange() const
{
	return m_iImprovementChange;
}

int CvEventInfo::getBonus() const
{
	return m_iBonus;
}

int CvEventInfo::getBonusChange() const
{
	return m_iBonusChange;
}

int CvEventInfo::getRoute() const
{
	return m_iRoute;
}

int CvEventInfo::getRouteChange() const
{
	return m_iRouteChange;
}

int CvEventInfo::getBonusRevealed() const
{
	return m_iBonusRevealed;
}

int CvEventInfo::getBonusGift() const
{
	return m_iBonusGift;
}

int CvEventInfo::getConvertOwnCities() const
{
	return m_iConvertOwnCities;
}

int CvEventInfo::getConvertOtherCities() const
{
	return m_iConvertOtherCities;
}

int CvEventInfo::getMaxNumReligions() const
{
	return m_iMaxNumReligions;
}

int CvEventInfo::getOurAttitudeModifier() const
{
	return m_iOurAttitudeModifier;
}

int CvEventInfo::getAttitudeModifier() const
{
	return m_iAttitudeModifier;
}

int CvEventInfo::getTheirEnemyAttitudeModifier() const
{
	return m_iTheirEnemyAttitudeModifier;
}

int CvEventInfo::getPopulationChange() const
{
	return m_iPopulationChange;
}

int CvEventInfo::getRevoltTurns() const
{
	return m_iRevoltTurns;
}

int CvEventInfo::getMinPillage() const
{
	return m_iMinPillage;
}

int CvEventInfo::getMaxPillage() const
{
	return m_iMaxPillage;
}

int CvEventInfo::getUnitPromotion() const
{
	return m_iUnitPromotion;
}

int CvEventInfo::getFreeUnitSupport() const
{
	return m_iFreeUnitSupport;
}

int CvEventInfo::getInflationModifier() const
{
	return m_iInflationModifier;
}

int CvEventInfo::getSpaceProductionModifier() const
{
	return m_iSpaceProductionModifier;
}

int CvEventInfo::getAIValue() const
{
	return m_iAIValue;
}

//FfH: Added by Kael 01/21/2008
int CvEventInfo::getCrime() const
{
	return m_iCrime;
}

int CvEventInfo::getGlobalCounter() const
{
	return m_iGlobalCounter;
}

int CvEventInfo::getPrereqAlignment() const
{
	return m_iPrereqAlignment;
}

int CvEventInfo::getPrereqBonus() const
{
	return m_iPrereqBonus;
}

int CvEventInfo::getPrereqCivilization() const
{
	return m_iPrereqCivilization;
}

int CvEventInfo::getPrereqCorporation() const
{
	return m_iPrereqCorporation;
}

int CvEventInfo::getPrereqReligion() const
{
	return m_iPrereqReligion;
}

int CvEventInfo::getPrereqStateReligion() const
{
	return m_iPrereqStateReligion;
}
//FfH: End Add

int CvEventInfo::getAdditionalEventChance(int i) const
{
	FAssert (i >= 0 && i < GC.getNumEventInfos());
	return m_piAdditionalEventChance ? m_piAdditionalEventChance[i] : 0;
}

int CvEventInfo::getAdditionalEventTime(int i) const
{
	FAssert (i >= 0 && i < GC.getNumEventInfos());
	return m_piAdditionalEventTime ? m_piAdditionalEventTime[i] : 0;
}

int CvEventInfo::getClearEventChance(int i) const
{
	FAssert (i >= 0 && i < GC.getNumEventInfos());
	return m_piClearEventChance ? m_piClearEventChance[i] : 0;
}

int CvEventInfo::getTechFlavorValue(int i) const
{
	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piTechFlavorValue ? m_piTechFlavorValue[i] : -1;
}

int CvEventInfo::getPlotExtraYield(int i) const
{
	FAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piPlotExtraYields ? m_piPlotExtraYields[i] : -1;
}

int CvEventInfo::getFreeSpecialistCount(int i) const
{
	FAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piFreeSpecialistCount ? m_piFreeSpecialistCount[i] : -1;
}

int CvEventInfo::getUnitCombatPromotion(int i) const
{
	FAssertMsg(i < GC.getNumUnitCombatInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitCombatPromotions ? m_piUnitCombatPromotions[i] : -1;
}

int CvEventInfo::getUnitClassPromotion(int i) const
{
	FAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_piUnitClassPromotions ? m_piUnitClassPromotions[i] : -1;
}

const CvWString& CvEventInfo::getWorldNews(int i) const
{
	FAssert(i >= 0 && i < (int)m_aszWorldNews.size());
	return m_aszWorldNews[i];
}

int CvEventInfo::getNumWorldNews() const
{
	return m_aszWorldNews.size();
}

int CvEventInfo::getBuildingYieldChange(int iBuildingClass, int iYield) const
{
	for (std::vector<BuildingYieldChange>::const_iterator it = m_aBuildingYieldChanges.begin(); it != m_aBuildingYieldChanges.end(); ++it)
	{
		if ((*it).eBuildingClass == (BuildingClassTypes)iBuildingClass && (*it).eYield == (YieldTypes)iYield)
		{
			return (*it).iChange;
		}
	}

	return 0;
}

int CvEventInfo::getNumBuildingYieldChanges() const
{
	return m_aBuildingYieldChanges.size();
}

int CvEventInfo::getBuildingCommerceChange(int iBuildingClass, int iCommerce) const
{
	for (std::vector<BuildingCommerceChange>::const_iterator it = m_aBuildingCommerceChanges.begin(); it != m_aBuildingCommerceChanges.end(); ++it)
	{
		if ((*it).eBuildingClass == (BuildingClassTypes)iBuildingClass && (*it).eCommerce == (CommerceTypes)iCommerce)
		{
			return (*it).iChange;
		}
	}

	return 0;
}

int CvEventInfo::getNumBuildingCommerceChanges() const
{
	return m_aBuildingCommerceChanges.size();
}

int CvEventInfo::getNumBuildingHappyChanges() const
{
	return m_aBuildingHappyChanges.size();
}

int CvEventInfo::getBuildingHappyChange(int iBuildingClass) const
{
	for (BuildingChangeArray::const_iterator it = m_aBuildingHappyChanges.begin(); it != m_aBuildingHappyChanges.end(); ++it)
	{
		if ((*it).first == (BuildingClassTypes)iBuildingClass)
		{
			return (*it).second;
		}
	}

	return 0;
}

int CvEventInfo::getNumBuildingHealthChanges() const
{
	return m_aBuildingHealthChanges.size();
}

int CvEventInfo::getBuildingHealthChange(int iBuildingClass) const
{
	for (BuildingChangeArray::const_iterator it = m_aBuildingHealthChanges.begin(); it != m_aBuildingHealthChanges.end(); ++it)
	{
		if ((*it).first == (BuildingClassTypes)iBuildingClass)
		{
			return (*it).second;
		}
	}

	return 0;
}

const char* CvEventInfo::getPythonCallback() const
{
	return m_szPythonCallback;
}

const char* CvEventInfo::getPythonExpireCheck() const
{
	return m_szPythonExpireCheck;
}

const char* CvEventInfo::getPythonCanDo() const
{
	return m_szPythonCanDo;
}

const char* CvEventInfo::getPythonHelp() const
{
	return m_szPythonHelp;
}

const wchar* CvEventInfo::getUnitNameKey() const
{
	return m_szUnitName;
}

const wchar* CvEventInfo::getQuestFailTextKey() const
{
	return m_szQuestFailText;
}

const wchar* CvEventInfo::getLocalInfoTextKey() const
{
	return m_szLocalInfoText;
}

const wchar* CvEventInfo::getOtherPlayerPopup() const
{
	return m_szOtherPlayerPopup;
}

void CvEventInfo::read(FDataStreamBase* stream)
{
	CvInfoBase::read(stream);

	uint uiFlag=0;
	stream->Read(&uiFlag);	// flags for expansion

	stream->Read(&m_bQuest);
	stream->Read(&m_bGlobal);
	stream->Read(&m_bTeam);
	stream->Read(&m_bCityEffect);
	stream->Read(&m_bOtherPlayerCityEffect);
	stream->Read(&m_bGoldToPlayer);
	stream->Read(&m_bGoldenAge);
	stream->Read(&m_bDeclareWar);
	stream->Read(&m_bDisbandUnit);
	stream->Read(&m_iGold);
	stream->Read(&m_iRandomGold);
	stream->Read(&m_iCulture);
	stream->Read(&m_iEspionagePoints);
	stream->Read(&m_iTech);
	stream->Read(&m_iTechPercent);
	stream->Read(&m_iTechCostPercent);
	stream->Read(&m_iTechMinTurnsLeft);
	stream->Read(&m_iPrereqTech);
	stream->Read(&m_iUnitClass);
	stream->Read(&m_iNumUnits);
	stream->Read(&m_iUnitExperience);
	stream->Read(&m_iUnitImmobileTurns);
	stream->Read(&m_iBuildingClass);
	stream->Read(&m_iBuildingChange);
	stream->Read(&m_iHappy);
	stream->Read(&m_iHealth);
	stream->Read(&m_iHurryAnger);
	stream->Read(&m_iHappyTurns);
	stream->Read(&m_iFood);
	stream->Read(&m_iFoodPercent);
	stream->Read(&m_iFeature);
	stream->Read(&m_iFeatureChange);
	stream->Read(&m_iImprovement);
	stream->Read(&m_iImprovementChange);
	stream->Read(&m_iBonus);
	stream->Read(&m_iBonusChange);
	stream->Read(&m_iRoute);
	stream->Read(&m_iRouteChange);
	stream->Read(&m_iBonusRevealed);
	stream->Read(&m_iBonusGift);
	stream->Read(&m_iConvertOwnCities);
	stream->Read(&m_iConvertOtherCities);
	stream->Read(&m_iMaxNumReligions);
	stream->Read(&m_iOurAttitudeModifier);
	stream->Read(&m_iAttitudeModifier);
	stream->Read(&m_iTheirEnemyAttitudeModifier);
	stream->Read(&m_iPopulationChange);
	stream->Read(&m_iRevoltTurns);
	stream->Read(&m_iMinPillage);
	stream->Read(&m_iMaxPillage);
	stream->Read(&m_iUnitPromotion);
	stream->Read(&m_iFreeUnitSupport);
	stream->Read(&m_iInflationModifier);
	stream->Read(&m_iSpaceProductionModifier);
	stream->Read(&m_iAIValue);

//FfH: Added by Kael 01/21/2008
	stream->Read(&m_iCrime);
	stream->Read(&m_iGlobalCounter);
	stream->Read(&m_iPrereqAlignment);
	stream->Read(&m_iPrereqBonus);
	stream->Read(&m_iPrereqCivilization);
	stream->Read(&m_iPrereqCorporation);
	stream->Read(&m_iPrereqReligion);
	stream->Read(&m_iPrereqStateReligion);
//FfH: End Add

	SAFE_DELETE_ARRAY(m_piTechFlavorValue);
	m_piTechFlavorValue = new int[GC.getNumFlavorTypes()];
	stream->Read(GC.getNumFlavorTypes(), m_piTechFlavorValue);

	SAFE_DELETE_ARRAY(m_piPlotExtraYields);
	m_piPlotExtraYields = new int[NUM_YIELD_TYPES];
	stream->Read(NUM_YIELD_TYPES, m_piPlotExtraYields);

	SAFE_DELETE_ARRAY(m_piFreeSpecialistCount);
	m_piFreeSpecialistCount = new int[GC.getNumSpecialistInfos()];
	stream->Read(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);

	SAFE_DELETE_ARRAY(m_piAdditionalEventChance);
	m_piAdditionalEventChance = new int[GC.getNumEventInfos()];
	stream->Read(GC.getNumEventInfos(), m_piAdditionalEventChance);

	SAFE_DELETE_ARRAY(m_piAdditionalEventTime);
	m_piAdditionalEventTime = new int[GC.getNumEventInfos()];
	stream->Read(GC.getNumEventInfos(), m_piAdditionalEventTime);

	SAFE_DELETE_ARRAY(m_piClearEventChance);
	m_piClearEventChance = new int[GC.getNumEventInfos()];
	stream->Read(GC.getNumEventInfos(), m_piClearEventChance);

	SAFE_DELETE_ARRAY(m_piUnitCombatPromotions);
	m_piUnitCombatPromotions = new int[GC.getNumUnitCombatInfos()];
	stream->Read(GC.getNumUnitCombatInfos(), m_piUnitCombatPromotions);

	SAFE_DELETE_ARRAY(m_piUnitClassPromotions);
	m_piUnitClassPromotions = new int[GC.getNumUnitClassInfos()];
	stream->Read(GC.getNumUnitClassInfos(), m_piUnitClassPromotions);

	int iNumElements;
	CvWString szText;
	stream->Read(&iNumElements);
	m_aszWorldNews.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		stream->ReadString(szText);
		m_aszWorldNews.push_back(szText);
	}

	stream->Read(&iNumElements);
	m_aBuildingYieldChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		BuildingYieldChange kChange;
		kChange.read(stream);
		m_aBuildingYieldChanges.push_back(kChange);
	}

	stream->Read(&iNumElements);
	m_aBuildingCommerceChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		BuildingCommerceChange kChange;
		kChange.read(stream);
		m_aBuildingCommerceChanges.push_back(kChange);
	}

	stream->Read(&iNumElements);
	m_aBuildingHappyChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		int iBuildingClass;
		stream->Read(&iBuildingClass);
		int iHappy;
		stream->Read(&iHappy);
		m_aBuildingHappyChanges.push_back(std::make_pair((BuildingClassTypes)iBuildingClass, iHappy));
	}

	stream->Read(&iNumElements);
	m_aBuildingHealthChanges.clear();
	for (int i = 0; i < iNumElements; ++i)
	{
		int iBuildingClass;
		stream->Read(&iBuildingClass);
		int iHealthy;
		stream->Read(&iHealthy);
		m_aBuildingHealthChanges.push_back(std::make_pair((BuildingClassTypes)iBuildingClass, iHealthy));
	}

	stream->ReadString(m_szUnitName);
	stream->ReadString(m_szOtherPlayerPopup);
	stream->ReadString(m_szQuestFailText);
	stream->ReadString(m_szLocalInfoText);
	stream->ReadString(m_szPythonCallback);
	stream->ReadString(m_szPythonExpireCheck);
	stream->ReadString(m_szPythonCanDo);
	stream->ReadString(m_szPythonHelp);
}

void CvEventInfo::write(FDataStreamBase* stream)
{
	CvInfoBase::write(stream);

	uint uiFlag=0;
	stream->Write(uiFlag);		// flag for expansion

	stream->Write(m_bQuest);
	stream->Write(m_bGlobal);
	stream->Write(m_bTeam);
	stream->Write(m_bCityEffect);
	stream->Write(m_bOtherPlayerCityEffect);
	stream->Write(m_bGoldToPlayer);
	stream->Write(m_bGoldenAge);
	stream->Write(m_bDeclareWar);
	stream->Write(m_bDisbandUnit);
	stream->Write(m_iGold);
	stream->Write(m_iRandomGold);
	stream->Write(m_iCulture);
	stream->Write(m_iEspionagePoints);
	stream->Write(m_iTech);
	stream->Write(m_iTechPercent);
	stream->Write(m_iTechCostPercent);
	stream->Write(m_iTechMinTurnsLeft);
	stream->Write(m_iPrereqTech);
	stream->Write(m_iUnitClass);
	stream->Write(m_iNumUnits);
	stream->Write(m_iUnitExperience);
	stream->Write(m_iUnitImmobileTurns);
	stream->Write(m_iBuildingClass);
	stream->Write(m_iBuildingChange);
	stream->Write(m_iHappy);
	stream->Write(m_iHealth);
	stream->Write(m_iHurryAnger);
	stream->Write(m_iHappyTurns);
	stream->Write(m_iFood);
	stream->Write(m_iFoodPercent);
	stream->Write(m_iFeature);
	stream->Write(m_iFeatureChange);
	stream->Write(m_iImprovement);
	stream->Write(m_iImprovementChange);
	stream->Write(m_iBonus);
	stream->Write(m_iBonusChange);
	stream->Write(m_iRoute);
	stream->Write(m_iRouteChange);
	stream->Write(m_iBonusRevealed);
	stream->Write(m_iBonusGift);
	stream->Write(m_iConvertOwnCities);
	stream->Write(m_iConvertOtherCities);
	stream->Write(m_iMaxNumReligions);
	stream->Write(m_iOurAttitudeModifier);
	stream->Write(m_iAttitudeModifier);
	stream->Write(m_iTheirEnemyAttitudeModifier);
	stream->Write(m_iPopulationChange);
	stream->Write(m_iRevoltTurns);
	stream->Write(m_iMinPillage);
	stream->Write(m_iMaxPillage);
	stream->Write(m_iUnitPromotion);
	stream->Write(m_iFreeUnitSupport);
	stream->Write(m_iInflationModifier);
	stream->Write(m_iSpaceProductionModifier);
	stream->Write(m_iAIValue);

//FfH: Added by Kael 01/21/2008
	stream->Write(m_iCrime);
	stream->Write(m_iGlobalCounter);
	stream->Write(m_iPrereqAlignment);
	stream->Write(m_iPrereqBonus);
	stream->Write(m_iPrereqCivilization);
	stream->Write(m_iPrereqCorporation);
	stream->Write(m_iPrereqReligion);
	stream->Write(m_iPrereqStateReligion);
//FfH: End Add

	stream->Write(GC.getNumFlavorTypes(), m_piTechFlavorValue);
	stream->Write(NUM_YIELD_TYPES, m_piPlotExtraYields);
	stream->Write(GC.getNumSpecialistInfos(), m_piFreeSpecialistCount);
	stream->Write(GC.getNumEventInfos(), m_piAdditionalEventChance);
	stream->Write(GC.getNumEventInfos(), m_piAdditionalEventTime);
	stream->Write(GC.getNumEventInfos(), m_piClearEventChance);
	stream->Write(GC.getNumUnitCombatInfos(), m_piUnitCombatPromotions);
	stream->Write(GC.getNumUnitClassInfos(), m_piUnitClassPromotions);

	stream->Write(m_aszWorldNews.size());
	for (std::vector<CvWString>::iterator it = m_aszWorldNews.begin(); it != m_aszWorldNews.end(); ++it)
	{
		stream->WriteString(*it);
	}

	stream->Write(m_aBuildingYieldChanges.size());
	for (std::vector<BuildingYieldChange>::iterator it = m_aBuildingYieldChanges.begin(); it != m_aBuildingYieldChanges.end(); ++it)
	{
		(*it).write(stream);
	}

	stream->Write(m_aBuildingCommerceChanges.size());
	for (std::vector<BuildingCommerceChange>::iterator it = m_aBuildingCommerceChanges.begin(); it != m_aBuildingCommerceChanges.end(); ++it)
	{
		(*it).write(stream);
	}

	stream->Write(m_aBuildingHappyChanges.size());
	for (BuildingChangeArray::iterator it = m_aBuildingHappyChanges.begin(); it != m_aBuildingHappyChanges.end(); ++it)
	{
		stream->Write((*it).first);
		stream->Write((*it).second);
	}

	stream->Write(m_aBuildingHealthChanges.size());
	for (BuildingChangeArray::iterator it = m_aBuildingHealthChanges.begin(); it != m_aBuildingHealthChanges.end(); ++it)
	{
		stream->Write((*it).first);
		stream->Write((*it).second);
	}

	stream->WriteString(m_szUnitName);
	stream->WriteString(m_szOtherPlayerPopup);
	stream->WriteString(m_szQuestFailText);
	stream->WriteString(m_szLocalInfoText);
	stream->WriteString(m_szPythonCallback);
	stream->WriteString(m_szPythonExpireCheck);
	stream->WriteString(m_szPythonCanDo);
	stream->WriteString(m_szPythonHelp);
}

bool CvEventInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;

	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_bQuest, "bQuest");
	pXML->GetChildXmlValByName(&m_bGlobal, "bGlobal");
	pXML->GetChildXmlValByName(&m_bTeam, "bTeam");
	pXML->GetChildXmlValByName(&m_bCityEffect, "bPickCity");
	pXML->GetChildXmlValByName(&m_bOtherPlayerCityEffect, "bPickOtherPlayerCity");
	pXML->GetChildXmlValByName(&m_bGoldToPlayer, "bGoldToPlayer");
	pXML->GetChildXmlValByName(&m_bGoldenAge, "bGoldenAge");
	pXML->GetChildXmlValByName(&m_bDeclareWar, "bDeclareWar");
	pXML->GetChildXmlValByName(&m_iGold, "iGold");
	pXML->GetChildXmlValByName(&m_iRandomGold, "iRandomGold");
	pXML->GetChildXmlValByName(&m_iCulture, "iCulture");
	pXML->GetChildXmlValByName(&m_iEspionagePoints, "iEspionagePoints");
	pXML->GetChildXmlValByName(szTextVal, "Tech");
	m_iTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iTechPercent, "iTechPercent");
	pXML->GetChildXmlValByName(&m_iTechCostPercent, "iTechCostPercent");
	pXML->GetChildXmlValByName(&m_iTechMinTurnsLeft, "iTechMinTurnsLeft");
	pXML->GetChildXmlValByName(szTextVal, "PrereqTech");
	m_iPrereqTech = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "UnitClass");
	m_iUnitClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iNumUnits, "iNumFreeUnits");
	pXML->GetChildXmlValByName(&m_bDisbandUnit, "bDisbandUnit");
	pXML->GetChildXmlValByName(&m_iUnitExperience, "iUnitExperience");
	pXML->GetChildXmlValByName(&m_iUnitImmobileTurns, "iUnitImmobileTurns");
	pXML->GetChildXmlValByName(szTextVal, "BuildingClass");
	m_iBuildingClass = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iBuildingChange, "iBuildingChange");

	pXML->GetChildXmlValByName(&m_iHappy, "iHappy");
	pXML->GetChildXmlValByName(&m_iHealth, "iHealth");
	pXML->GetChildXmlValByName(&m_iHurryAnger, "iHurryAnger");
	pXML->GetChildXmlValByName(&m_iHappyTurns, "iHappyTurns");
	pXML->GetChildXmlValByName(&m_iFood, "iFood");
	pXML->GetChildXmlValByName(&m_iFoodPercent, "iFoodPercent");

	pXML->GetChildXmlValByName(szTextVal, "FeatureType");
	m_iFeature = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iFeatureChange, "iFeatureChange");

	pXML->GetChildXmlValByName(szTextVal, "ImprovementType");
	m_iImprovement = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iImprovementChange, "iImprovementChange");

	pXML->GetChildXmlValByName(szTextVal, "BonusType");
	m_iBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iBonusChange, "iBonusChange");

	pXML->GetChildXmlValByName(szTextVal, "RouteType");
	m_iRoute = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iRouteChange, "iRouteChange");

	pXML->GetChildXmlValByName(szTextVal, "BonusRevealed");
	m_iBonusRevealed = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "BonusGift");
	m_iBonusGift = pXML->FindInInfoClass(szTextVal);

	pXML->SetVariableListTagPair(&m_piTechFlavorValue, "TechFlavors", GC.getFlavorTypes(), GC.getNumFlavorTypes());
	pXML->SetVariableListTagPair(&m_piPlotExtraYields, "PlotExtraYields", sizeof(GC.getYieldInfo((YieldTypes)0)), NUM_YIELD_TYPES, 0);
	pXML->SetVariableListTagPair(&m_piFreeSpecialistCount, "FreeSpecialistCounts", sizeof(GC.getSpecialistInfo((SpecialistTypes)0)), GC.getNumSpecialistInfos());

	pXML->GetChildXmlValByName(&m_iConvertOwnCities, "iConvertOwnCities");
	pXML->GetChildXmlValByName(&m_iConvertOtherCities, "iConvertOtherCities");
	pXML->GetChildXmlValByName(&m_iMaxNumReligions, "iMaxNumReligions",-1);
	pXML->GetChildXmlValByName(&m_iOurAttitudeModifier, "iOurAttitudeModifier");
	pXML->GetChildXmlValByName(&m_iAttitudeModifier, "iAttitudeModifier");
	pXML->GetChildXmlValByName(&m_iTheirEnemyAttitudeModifier, "iTheirEnemyAttitudeModifier");
	pXML->GetChildXmlValByName(&m_iPopulationChange, "iPopulationChange");
	pXML->GetChildXmlValByName(&m_iRevoltTurns, "iRevoltTurns");
	pXML->GetChildXmlValByName(&m_iMinPillage, "iMinPillage");
	pXML->GetChildXmlValByName(&m_iMaxPillage, "iMaxPillage");
	pXML->GetChildXmlValByName(szTextVal, "UnitPromotion");
	m_iUnitPromotion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(&m_iFreeUnitSupport, "iFreeUnitSupport");
	pXML->GetChildXmlValByName(&m_iInflationModifier, "iInflationMod");
	pXML->GetChildXmlValByName(&m_iSpaceProductionModifier, "iSpaceProductionMod");
	pXML->GetChildXmlValByName(&m_iAIValue, "iAIValue");

//FfH: Added by Kael 01/21/2008
	pXML->GetChildXmlValByName(&m_iCrime, "iCrime");
	pXML->GetChildXmlValByName(&m_iGlobalCounter, "iGlobalCounter");
	pXML->GetChildXmlValByName(szTextVal, "PrereqAlignment");
	m_iPrereqAlignment = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqBonus");
	m_iPrereqBonus = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCivilization");
	m_iPrereqCivilization = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqCorporation");
	m_iPrereqCorporation = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqReligion");
	m_iPrereqReligion = pXML->FindInInfoClass(szTextVal);
	pXML->GetChildXmlValByName(szTextVal, "PrereqStateReligion");
	m_iPrereqStateReligion = pXML->FindInInfoClass(szTextVal);
//FfH: End Add

	CvString* pszPromotions = NULL;
	FAssertMsg(NULL == m_piUnitCombatPromotions, "Memory leak");
	m_piUnitCombatPromotions = new int[GC.getNumUnitCombatInfos()];
	pXML->SetVariableListTagPair(&pszPromotions, "UnitCombatPromotions", sizeof(GC.getUnitCombatInfo((UnitCombatTypes)0)), GC.getNumUnitCombatInfos(), "NONE");
	for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
	{
		m_piUnitCombatPromotions[i] = pXML->FindInInfoClass(pszPromotions[i]);
	}
	SAFE_DELETE_ARRAY(pszPromotions);

	FAssertMsg(NULL == m_piUnitClassPromotions, "Memory leak");
	m_piUnitClassPromotions = new int[GC.getNumUnitClassInfos()];
	pXML->SetVariableListTagPair(&pszPromotions, "UnitClassPromotions", sizeof(GC.getUnitClassInfo((UnitClassTypes)0)), GC.getNumUnitClassInfos(), "NONE");
	for (int i = 0; i < GC.getNumUnitClassInfos(); ++i)
	{
		m_piUnitClassPromotions[i] = pXML->FindInInfoClass(pszPromotions[i]);
	}
	SAFE_DELETE_ARRAY(pszPromotions);

	pXML->GetChildXmlValByName(m_szUnitName, "UnitName");
	pXML->GetChildXmlValByName(m_szOtherPlayerPopup, "OtherPlayerPopup");
	pXML->GetChildXmlValByName(m_szQuestFailText, "QuestFailText");
	pXML->GetChildXmlValByName(m_szLocalInfoText, "LocalInfoText");
	pXML->GetChildXmlValByName(m_szPythonCallback, "PythonCallback");
	pXML->GetChildXmlValByName(m_szPythonExpireCheck, "PythonExpireCheck");
	pXML->GetChildXmlValByName(m_szPythonCanDo, "PythonCanDo");
	pXML->GetChildXmlValByName(m_szPythonHelp, "PythonHelp");

	m_aszWorldNews.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"WorldNewsTexts"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (pXML->GetChildXmlVal(szTextVal))
				{
					for (int j=0; j<iNumSibs; ++j)
					{
						m_aszWorldNews.push_back(szTextVal);
						if (!pXML->GetNextXmlVal(szTextVal))
						{
							break;
						}
					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingYieldChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraYields"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingYieldChange kChange;
							kChange.eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(szTextVal);
							kChange.eYield = (YieldTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(&kChange.iChange);
							m_aBuildingYieldChanges.push_back(kChange);

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingCommerceChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraCommerces"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingCommerceChange kChange;
							kChange.eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(szTextVal);
							kChange.eCommerce = (CommerceTypes)pXML->FindInInfoClass(szTextVal);
							pXML->GetNextXmlVal(&kChange.iChange);
							m_aBuildingCommerceChanges.push_back(kChange);

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingHappyChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraHappies"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingClassTypes eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							int iChange;
							pXML->GetNextXmlVal(&iChange);
							m_aBuildingHappyChanges.push_back(std::make_pair(eBuildingClass, iChange));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	m_aBuildingHealthChanges.clear();
	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"BuildingExtraHealths"))
	{
		if (pXML->SkipToNextVal())
		{
			int iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());

			if (0 < iNumSibs)
			{
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int j = 0; j < iNumSibs; ++j)
					{
						if (pXML->GetChildXmlVal(szTextVal))
						{
							BuildingClassTypes eBuildingClass = (BuildingClassTypes)pXML->FindInInfoClass(szTextVal);
							int iChange;
							pXML->GetNextXmlVal(&iChange);
							m_aBuildingHealthChanges.push_back(std::make_pair(eBuildingClass, iChange));

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());

						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}

					}

					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}

		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}

bool CvEventInfo::readPass2(CvXMLLoadUtility* pXML)
{
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
	pXML->SetVariableListTagPair(&m_piAdditionalEventChance, "AdditionalEvents", sizeof(GC.getEventInfo((EventTypes)0)), GC.getNumEventInfos(), 0);
	pXML->SetVariableListTagPair(&m_piAdditionalEventTime, "EventTimes", sizeof(GC.getEventInfo((EventTypes)0)), GC.getNumEventInfos(), 0);
	pXML->SetVariableListTagPair(&m_piClearEventChance, "ClearEvents", sizeof(GC.getEventInfo((EventTypes)0)), GC.getNumEventInfos(), 0);

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**	New Tag Defs	(EventInfos)																**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEventInfo::copyNonDefaults(CvEventInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isQuest()							== false)				m_bQuest						= pClassInfo->isQuest();
	if (isGlobal()							== false)				m_bGlobal						= pClassInfo->isGlobal();
	if (isTeam()							== false)				m_bTeam							= pClassInfo->isTeam();
	if (isCityEffect()						== false)				m_bCityEffect					= pClassInfo->isCityEffect();
	if (isOtherPlayerCityEffect()			== false)				m_bOtherPlayerCityEffect		= pClassInfo->isOtherPlayerCityEffect();
	if (isGoldToPlayer()					== false)				m_bGoldToPlayer					= pClassInfo->isGoldToPlayer();
	if (isGoldenAge()						== false)				m_bGoldenAge					= pClassInfo->isGoldenAge();
	if (isDeclareWar()						== false)				m_bDeclareWar					= pClassInfo->isDeclareWar();
	if (isDisbandUnit()						== false)				m_bDisbandUnit					= pClassInfo->isDisbandUnit();
	if (getGold()							== 0)					m_iGold							= pClassInfo->getGold();
	if (getRandomGold()						== 0)					m_iRandomGold					= pClassInfo->getRandomGold();
	if (getCulture()						== 0)					m_iCulture						= pClassInfo->getCulture();
	if (getEspionagePoints()				== 0)					m_iEspionagePoints				= pClassInfo->getEspionagePoints();
	if (getTechPercent()					== 0)					m_iTechPercent					= pClassInfo->getTechPercent();
	if (getTechCostPercent()				== 0)					m_iTechCostPercent				= pClassInfo->getTechCostPercent();
	if (getTechMinTurnsLeft()				== 0)					m_iTechMinTurnsLeft				= pClassInfo->getTechMinTurnsLeft();
	if (getNumUnits()						== 0)					m_iNumUnits						= pClassInfo->getNumUnits();
	if (getUnitExperience()					== 0)					m_iUnitExperience				= pClassInfo->getUnitExperience();
	if (getUnitImmobileTurns()				== 0)					m_iUnitImmobileTurns			= pClassInfo->getUnitImmobileTurns();
	if (getBuildingChange()					== 0)					m_iBuildingChange				= pClassInfo->getBuildingChange();
	if (getHappy()							== 0)					m_iHappy						= pClassInfo->getHappy();
	if (getHealth()							== 0)					m_iHealth						= pClassInfo->getHealth();
	if (getHurryAnger()						== 0)					m_iHurryAnger					= pClassInfo->getHurryAnger();
	if (getHappyTurns()						== 0)					m_iHappyTurns					= pClassInfo->getHappyTurns();
	if (getFood()							== 0)					m_iFood							= pClassInfo->getFood();
	if (getFoodPercent()					== 0)					m_iFoodPercent					= pClassInfo->getFoodPercent();
	if (getConvertOwnCities()				== 0)					m_iConvertOwnCities				= pClassInfo->getConvertOwnCities();
	if (getConvertOtherCities()				== 0)					m_iConvertOtherCities			= pClassInfo->getConvertOtherCities();
	if (getMaxNumReligions()				== 0)					m_iMaxNumReligions				= pClassInfo->getMaxNumReligions();
	if (getOurAttitudeModifier()			== 0)					m_iOurAttitudeModifier			= pClassInfo->getOurAttitudeModifier();
	if (getAttitudeModifier()				== 0)					m_iAttitudeModifier				= pClassInfo->getAttitudeModifier();
	if (getTheirEnemyAttitudeModifier()		== 0)					m_iTheirEnemyAttitudeModifier	= pClassInfo->getTheirEnemyAttitudeModifier();
	if (getPopulationChange()				== 0)					m_iPopulationChange				= pClassInfo->getPopulationChange();
	if (getRevoltTurns()					== 0)					m_iRevoltTurns					= pClassInfo->getRevoltTurns();
	if (getMinPillage()						== 0)					m_iMinPillage					= pClassInfo->getMinPillage();
	if (getMaxPillage()						== 0)					m_iMaxPillage					= pClassInfo->getMaxPillage();
	if (getFreeUnitSupport()				== 0)					m_iFreeUnitSupport				= pClassInfo->getFreeUnitSupport();
	if (getInflationModifier()				== 0)					m_iInflationModifier			= pClassInfo->getInflationModifier();
	if (getSpaceProductionModifier()		== 0)					m_iSpaceProductionModifier		= pClassInfo->getSpaceProductionModifier();
	if (getAIValue()						== 0)					m_iAIValue						= pClassInfo->getAIValue();
	if (getFeatureChange()					== 0)					m_iFeatureChange				= pClassInfo->getFeatureChange();
	if (getImprovementChange()				== 0)					m_iImprovementChange			= pClassInfo->getImprovementChange();
	if (getBonusChange()					== 0)					m_iBonusChange					= pClassInfo->getBonusChange();
	if (getRouteChange()					== 0)					m_iRouteChange					= pClassInfo->getRouteChange();
	if (getCrime()							== 0)					m_iCrime						= pClassInfo->getCrime();
	if (getGlobalCounter()					== 0)					m_iGlobalCounter				= pClassInfo->getGlobalCounter();
	if (getPrereqBonus()					== NO_BONUS)			m_iPrereqBonus					= pClassInfo->getPrereqBonus();
	if (getBonus()							== NO_BONUS)			m_iBonus						= pClassInfo->getBonus();
	if (getRoute()							== NO_ROUTE)			m_iRoute						= pClassInfo->getRoute();
	if (getBonusRevealed()					== NO_BONUS)			m_iBonusRevealed				= pClassInfo->getBonusRevealed();
	if (getBonusGift()						== NO_BONUS)			m_iBonusGift					= pClassInfo->getBonusGift();
	if (getTech()							== NO_TECH)				m_iTech							= pClassInfo->getTech();
	if (getPrereqTech()						== NO_TECH)				m_iPrereqTech					= pClassInfo->getPrereqTech();
	if (getFeature()						== NO_FEATURE)			m_iFeature						= pClassInfo->getFeature();
	if (getPrereqReligion()					== NO_RELIGION)			m_iPrereqReligion				= pClassInfo->getPrereqReligion();
	if (getPrereqStateReligion()			== NO_RELIGION)			m_iPrereqStateReligion			= pClassInfo->getPrereqStateReligion();
	if (getPrereqAlignment()				== NO_ALIGNMENT)		m_iPrereqAlignment				= pClassInfo->getPrereqAlignment();
	if (getUnitClass()						== NO_UNITCLASS)		m_iUnitClass					= pClassInfo->getUnitClass();
	if (getUnitPromotion()					== NO_PROMOTION)		m_iUnitPromotion				= pClassInfo->getUnitPromotion();
	if (getImprovement()					== NO_IMPROVEMENT)		m_iImprovement					= pClassInfo->getImprovement();
	if (getPrereqCorporation()				== NO_CORPORATION)		m_iPrereqCorporation			= pClassInfo->getPrereqCorporation();
	if (getPrereqCivilization()				== NO_CIVILIZATION)		m_iPrereqCivilization			= pClassInfo->getPrereqCivilization();
	if (getBuildingClass()					== NO_BUILDINGCLASS)	m_iBuildingClass				= pClassInfo->getBuildingClass();
	if (getUnitNameKey()					== wDefault)			m_szUnitName					= pClassInfo->getUnitNameKey();
	if (getOtherPlayerPopup()				== wDefault)			m_szOtherPlayerPopup			= pClassInfo->getOtherPlayerPopup();
	if (getQuestFailTextKey()				== wDefault)			m_szQuestFailText				= pClassInfo->getQuestFailTextKey();
	if (getLocalInfoTextKey()				== wDefault)			m_szLocalInfoText				= pClassInfo->getLocalInfoTextKey();
	if (getPythonCallback()					== cDefault)			m_szPythonCallback				= pClassInfo->getPythonCallback();
	if (getPythonExpireCheck()				== cDefault)			m_szPythonExpireCheck			= pClassInfo->getPythonExpireCheck();
	if (getPythonCanDo()					== cDefault)			m_szPythonCanDo					= pClassInfo->getPythonCanDo();
	if (getPythonHelp()						== cDefault)			m_szPythonHelp					= pClassInfo->getPythonHelp();
	for ( int i = 0; i < GC.getNumFlavorTypes(); i++)
	{
		if (m_piTechFlavorValue[i]			== 0)					m_piTechFlavorValue[i]			= pClassInfo->getTechFlavorValue(i);
	}
	for ( int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (m_piPlotExtraYields[i]			== 0)					m_piPlotExtraYields[i]			= pClassInfo->getPlotExtraYield(i);
	}
	for ( int i = 0; i < GC.getNumSpecialistInfos(); i++)
	{
		if (m_piFreeSpecialistCount[i]		== 0)					m_piFreeSpecialistCount[i]		= pClassInfo->getFreeSpecialistCount(i);
	}
	for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
	{
		if (m_piUnitCombatPromotions[i]		== NO_PROMOTION)		m_piUnitCombatPromotions[i]		= pClassInfo->getUnitCombatPromotion(i);
	}
	for (int i = 0; i < GC.getNumUnitClassInfos(); ++i)
	{
		if (m_piUnitClassPromotions[i]		== NO_PROMOTION)		m_piUnitClassPromotions[i]		= pClassInfo->getUnitClassPromotion(i);
	}
/**
	CvWString szwTextVal;
	for (int i = 0; i < pClassInfo->getNumWorldNews(); i++)
	{
		if (getWorldNews(i) == cDefault)
		{
		    szwTextVal = pClassInfo->getWorldNews(i);
		    m_aszWorldNews.push_back(szwTextVal);
		}
	}
	for (int iBuildingClass = 0; iBuildingClass < GC.getNumBuildingClassInfos(); iBuildingClass++)
	{
		for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
		{
			if (pClassInfo->getBuildingYieldChange(iBuildingClass, iYield) != 0)
			{
				BuildingYieldChange kChange;
				kChange.eBuildingClass = (BuildingClassTypes)iBuildingClass;
				kChange.eYield = (YieldTypes)iYield;
				kChange.iChange = pClassInfo->getBuildingYieldChange(iBuildingClass, iYield);
                m_aBuildingYieldChanges.push_back(kChange);
			}
		}

        for (int iCommerce = 0; iYield < NUM_COMMERCE_TYPES; iCommerce++)
		{
			if (pClassInfo->getBuildingCommerceChange(iBuildingClass, iCommerce) != 0)
			{
				BuildingCommerceChange kChange;
				kChange.eBuildingClass = (BuildingClassTypes)iBuildingClass;
				kChange.eCommerce = (CommerceTypes)iCommerce;
				kChange.iChange = pClassInfo->getBuildingCommerceChange(iBuildingClass, iCommerce);
                m_aBuildingCommerceChanges.push_back(kChange);
			}
		}
	}
**/
}
void CvEventInfo::copyNonDefaultsReadPass2(CvEventInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	bool bOver = pClassInfo->isForceOverwrite();
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	if(!m_piAdditionalEventChance)									pXML->InitList(&m_piAdditionalEventChance, GC.getNumEventInfos(), 0);
	if(!m_piAdditionalEventTime)									pXML->InitList(&m_piAdditionalEventTime, GC.getNumEventInfos(), 0);
	if(!m_piClearEventChance)										pXML->InitList(&m_piClearEventChance, GC.getNumEventInfos(), 0);
	for (int i = 0; i < GC.getNumEventInfos(); ++i)
	{
		if(bOver || pClassInfo->getAdditionalEventChance(i)	!= 0)	m_piAdditionalEventChance[i]	= pClassInfo->getAdditionalEventChance(i);
		if(bOver || pClassInfo->getAdditionalEventTime(i)	!= 0)	m_piAdditionalEventTime[i]		= pClassInfo->getAdditionalEventTime(i);
		if(bOver || pClassInfo->getClearEventChance(i)		!= 0)	m_piClearEventChance[i]			= pClassInfo->getClearEventChance(i);
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

//======================================================================================================
//					CvEspionageMissionInfo
//======================================================================================================

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   CvEspionageMissionInfo()
//
//  PURPOSE :   Default constructor
//
//------------------------------------------------------------------------------------------------------
CvEspionageMissionInfo::CvEspionageMissionInfo()
{
}

//------------------------------------------------------------------------------------------------------
//
//  FUNCTION:   ~CvEspionageMissionInfo()
//
//  PURPOSE :   Default destructor
//
//------------------------------------------------------------------------------------------------------
CvEspionageMissionInfo::~CvEspionageMissionInfo()
{
}

int CvEspionageMissionInfo::getCost() const
{
	return m_iCost;
}

bool CvEspionageMissionInfo::isPassive() const
{
	return m_bIsPassive;
}

bool CvEspionageMissionInfo::isTwoPhases() const
{
	return m_bIsTwoPhases;
}

bool CvEspionageMissionInfo::isTargetsCity() const
{
	return m_bTargetsCity;
}

bool CvEspionageMissionInfo::isSelectPlot() const
{
	return m_bSelectPlot;
}

int CvEspionageMissionInfo::getTechPrereq() const
{
	return m_iTechPrereq;
}

int CvEspionageMissionInfo::getVisibilityLevel() const
{
	return m_iVisibilityLevel;
}

bool CvEspionageMissionInfo::isInvestigateCity() const
{
	return m_bInvestigateCity;
}

bool CvEspionageMissionInfo::isSeeDemographics() const
{
	return m_bSeeDemographics;
}

bool CvEspionageMissionInfo::isNoActiveMissions() const
{
	return m_bNoActiveMissions;
}

bool CvEspionageMissionInfo::isSeeResearch() const
{
	return m_bSeeResearch;
}

bool CvEspionageMissionInfo::isDestroyImprovement() const
{
	return m_bDestroyImprovement;
}

int CvEspionageMissionInfo::getDestroyBuildingCostFactor() const
{
	return m_iDestroyBuildingCostFactor;
}

int CvEspionageMissionInfo::getDestroyUnitCostFactor() const
{
	return m_iDestroyUnitCostFactor;
}

int CvEspionageMissionInfo::getDestroyProjectCostFactor() const
{
	return m_iDestroyProjectCostFactor;
}

int CvEspionageMissionInfo::getDestroyProductionCostFactor() const
{
	return m_iDestroyProductionCostFactor;
}

int CvEspionageMissionInfo::getBuyUnitCostFactor() const
{
	return m_iBuyUnitCostFactor;
}

int CvEspionageMissionInfo::getBuyCityCostFactor() const
{
	return m_iBuyCityCostFactor;
}

int CvEspionageMissionInfo::getStealTreasuryTypes() const
{
	return m_iStealTreasuryTypes;
}

int CvEspionageMissionInfo::getCityInsertCultureAmountFactor() const
{
	return m_iCityInsertCultureAmountFactor;
}

int CvEspionageMissionInfo::getCityInsertCultureCostFactor() const
{
	return m_iCityInsertCultureCostFactor;
}

int CvEspionageMissionInfo::getCityPoisonWaterCounter() const
{
	return m_iCityPoisonWaterCounter;
}

int CvEspionageMissionInfo::getCityUnhappinessCounter() const
{
	return m_iCityUnhappinessCounter;
}

int CvEspionageMissionInfo::getCityRevoltCounter() const
{
	return m_iCityRevoltCounter;
}

int CvEspionageMissionInfo::getBuyTechCostFactor() const
{
	return m_iBuyTechCostFactor;
}

int CvEspionageMissionInfo::getSwitchCivicCostFactor() const
{
	return m_iSwitchCivicCostFactor;
}

int CvEspionageMissionInfo::getSwitchReligionCostFactor() const
{
	return m_iSwitchReligionCostFactor;
}

int CvEspionageMissionInfo::getPlayerAnarchyCounter() const
{
	return m_iPlayerAnarchyCounter;
}

int CvEspionageMissionInfo::getCounterespionageNumTurns() const
{
	return m_iCounterespionageNumTurns;
}

int CvEspionageMissionInfo::getCounterespionageMod() const
{
	return m_iCounterespionageMod;
}

int CvEspionageMissionInfo::getDifficultyMod() const
{
	return m_iDifficultyMod;
}

bool CvEspionageMissionInfo::read(CvXMLLoadUtility* pXML)
{
	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iCost, "iCost");
	pXML->GetChildXmlValByName(&m_bIsPassive, "bIsPassive");
	pXML->GetChildXmlValByName(&m_bIsTwoPhases, "bIsTwoPhases");
	pXML->GetChildXmlValByName(&m_bTargetsCity, "bTargetsCity");
	pXML->GetChildXmlValByName(&m_bSelectPlot, "bSelectPlot");

	pXML->GetChildXmlValByName(szTextVal, "TechPrereq");
	m_iTechPrereq = pXML->FindInInfoClass(szTextVal);

	pXML->GetChildXmlValByName(&m_iVisibilityLevel, "iVisibilityLevel");
	pXML->GetChildXmlValByName(&m_bInvestigateCity, "bInvestigateCity");
	pXML->GetChildXmlValByName(&m_bSeeDemographics, "bSeeDemographics");
	pXML->GetChildXmlValByName(&m_bNoActiveMissions, "bNoActiveMissions");
	pXML->GetChildXmlValByName(&m_bSeeResearch, "bSeeResearch");

	pXML->GetChildXmlValByName(&m_bDestroyImprovement, "bDestroyImprovement");
	pXML->GetChildXmlValByName(&m_iDestroyBuildingCostFactor, "iDestroyBuildingCostFactor");
	pXML->GetChildXmlValByName(&m_iDestroyUnitCostFactor, "iDestroyUnitCostFactor");
	pXML->GetChildXmlValByName(&m_iDestroyProjectCostFactor, "iDestroyProjectCostFactor");
	pXML->GetChildXmlValByName(&m_iDestroyProductionCostFactor, "iDestroyProductionCostFactor");
	pXML->GetChildXmlValByName(&m_iBuyUnitCostFactor, "iBuyUnitCostFactor");
	pXML->GetChildXmlValByName(&m_iBuyCityCostFactor, "iBuyCityCostFactor");
	pXML->GetChildXmlValByName(&m_iStealTreasuryTypes, "iStealTreasuryTypes");
	pXML->GetChildXmlValByName(&m_iCityInsertCultureAmountFactor, "iCityInsertCultureAmountFactor");
	pXML->GetChildXmlValByName(&m_iCityInsertCultureCostFactor, "iCityInsertCultureCostFactor");
	pXML->GetChildXmlValByName(&m_iCityPoisonWaterCounter, "iCityPoisonWaterCounter");
	pXML->GetChildXmlValByName(&m_iCityUnhappinessCounter, "iCityUnhappinessCounter");
	pXML->GetChildXmlValByName(&m_iCityRevoltCounter, "iCityRevoltCounter");
	pXML->GetChildXmlValByName(&m_iBuyTechCostFactor, "iBuyTechCostFactor");
	pXML->GetChildXmlValByName(&m_iSwitchCivicCostFactor, "iSwitchCivicCostFactor");
	pXML->GetChildXmlValByName(&m_iSwitchReligionCostFactor, "iSwitchReligionCostFactor");
	pXML->GetChildXmlValByName(&m_iPlayerAnarchyCounter, "iPlayerAnarchyCounter");
	pXML->GetChildXmlValByName(&m_iCounterespionageNumTurns, "iCounterespionageNumTurns");
	pXML->GetChildXmlValByName(&m_iCounterespionageMod, "iCounterespionageMod");
	pXML->GetChildXmlValByName(&m_iDifficultyMod, "iDifficultyMod");

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvEspionageMissionInfo::copyNonDefaults(CvEspionageMissionInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (isPassive()							== false)		m_bIsPassive						= pClassInfo->isPassive();
	if (isTwoPhases()						== false)		m_bIsTwoPhases						= pClassInfo->isTwoPhases();
	if (isTargetsCity()						== false)		m_bTargetsCity						= pClassInfo->isTargetsCity();
	if (isSelectPlot()						== false)		m_bSelectPlot						= pClassInfo->isSelectPlot();
	if (isInvestigateCity()					== false)		m_bInvestigateCity					= pClassInfo->isInvestigateCity();
	if (isSeeDemographics()					== false)		m_bSeeDemographics					= pClassInfo->isSeeDemographics();
	if (isNoActiveMissions()				== false)		m_bNoActiveMissions					= pClassInfo->isNoActiveMissions();
	if (isSeeResearch()						== false)		m_bSeeResearch						= pClassInfo->isSeeResearch();
	if (isDestroyImprovement()				== false)		m_bDestroyImprovement				= pClassInfo->isDestroyImprovement();
	if (getCost()							== 0)			m_iCost								= pClassInfo->getCost();
	if (getVisibilityLevel()				== 0)			m_iVisibilityLevel					= pClassInfo->getVisibilityLevel();
	if (getDestroyBuildingCostFactor()		== 0)			m_iDestroyBuildingCostFactor		= pClassInfo->getDestroyBuildingCostFactor();
	if (getDestroyUnitCostFactor()			== 0)			m_iDestroyUnitCostFactor			= pClassInfo->getDestroyUnitCostFactor();
	if (getDestroyProjectCostFactor()		== 0)			m_iDestroyProjectCostFactor			= pClassInfo->getDestroyProjectCostFactor();
	if (getDestroyProductionCostFactor()	== 0)			m_iDestroyProductionCostFactor		= pClassInfo->getDestroyProductionCostFactor();
	if (getBuyUnitCostFactor()				== 0)			m_iBuyUnitCostFactor				= pClassInfo->getBuyUnitCostFactor();
	if (getBuyCityCostFactor()				== 0)			m_iBuyCityCostFactor				= pClassInfo->getBuyCityCostFactor();
	if (getStealTreasuryTypes()				== 0)			m_iStealTreasuryTypes				= pClassInfo->getStealTreasuryTypes();
	if (getCityInsertCultureAmountFactor()	== 0)			m_iCityInsertCultureAmountFactor	= pClassInfo->getCityInsertCultureAmountFactor();
	if (getCityInsertCultureCostFactor()	== 0)			m_iCityInsertCultureCostFactor		= pClassInfo->getCityInsertCultureCostFactor();
	if (getCityPoisonWaterCounter()			== 0)			m_iCityPoisonWaterCounter			= pClassInfo->getCityPoisonWaterCounter();
	if (getCityUnhappinessCounter()			== 0)			m_iCityUnhappinessCounter			= pClassInfo->getCityUnhappinessCounter();
	if (getCityRevoltCounter()				== 0)			m_iCityRevoltCounter				= pClassInfo->getCityRevoltCounter();
	if (getBuyTechCostFactor()				== 0)			m_iBuyTechCostFactor				= pClassInfo->getBuyTechCostFactor();
	if (getSwitchCivicCostFactor()			== 0)			m_iSwitchCivicCostFactor			= pClassInfo->getSwitchCivicCostFactor();
	if (getSwitchReligionCostFactor()		== 0)			m_iSwitchReligionCostFactor			= pClassInfo->getSwitchReligionCostFactor();
	if (getPlayerAnarchyCounter()			== 0)			m_iPlayerAnarchyCounter				= pClassInfo->getPlayerAnarchyCounter();
	if (getCounterespionageNumTurns()		== 0)			m_iCounterespionageNumTurns			= pClassInfo->getCounterespionageNumTurns();
	if (getCounterespionageMod()			== 0)			m_iCounterespionageMod				= pClassInfo->getCounterespionageMod();
	if (getDifficultyMod()					== 0)			m_iDifficultyMod					= pClassInfo->getDifficultyMod();
	if (getTechPrereq()						== NO_TECH)		m_iTechPrereq						= pClassInfo->getTechPrereq();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/


//////////////////////////////////////////////////////////////////////////
//
//	CvUnitArtStyleTypeInfo
//  Graphic Flavor Units packages by Impaler[WrG]
//

CvUnitArtStyleTypeInfo::CvUnitArtStyleTypeInfo()
{
}

CvUnitArtStyleTypeInfo::~CvUnitArtStyleTypeInfo()
{
}

const TCHAR* CvUnitArtStyleTypeInfo::getEarlyArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j) const
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::const_iterator it = m_azEarlyArtDefineTags.begin(); it != m_azEarlyArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			return (*it).szTag;
		}
	}

	return NULL;
}

void CvUnitArtStyleTypeInfo::setEarlyArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j, const TCHAR* szVal)
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::iterator it = m_azEarlyArtDefineTags.begin(); it != m_azEarlyArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			(*it).szTag = szVal;
			return;
		}
	}

	ArtDefneTag kTag;
	kTag.iMeshIndex = i;
	kTag.iUnitType = j;
	kTag.szTag = szVal;
	m_azEarlyArtDefineTags.push_back(kTag);
}

const TCHAR* CvUnitArtStyleTypeInfo::getLateArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j) const
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::const_iterator it = m_azLateArtDefineTags.begin(); it != m_azLateArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			return (*it).szTag;
		}
	}

	return NULL;
}

void CvUnitArtStyleTypeInfo::setLateArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j, const TCHAR* szVal)
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::iterator it = m_azLateArtDefineTags.begin(); it != m_azLateArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			(*it).szTag = szVal;
			return;
		}
	}

	ArtDefneTag kTag;
	kTag.iMeshIndex = i;
	kTag.iUnitType = j;
	kTag.szTag = szVal;
	m_azLateArtDefineTags.push_back(kTag);
}

const TCHAR* CvUnitArtStyleTypeInfo::getMiddleArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j) const
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::const_iterator it = m_azMiddleArtDefineTags.begin(); it != m_azMiddleArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			return (*it).szTag;
		}
	}

	return NULL;
}

void CvUnitArtStyleTypeInfo::setMiddleArtDefineTag(int /*Mesh Index*/ i, int /*UnitType*/ j, const TCHAR* szVal)
{
	FAssertMsg(i < GC.getUnitInfo((UnitTypes) j).getGroupDefinitions(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	FAssertMsg(j < GC.getNumUnitInfos(), "Index out of bounds");
	FAssertMsg(j > -1, "Index out of bounds");

	for (ArtDefineArray::iterator it = m_azMiddleArtDefineTags.begin(); it != m_azMiddleArtDefineTags.end(); ++it)
	{
		if ((*it).iMeshIndex == i && (*it).iUnitType == j)
		{
			(*it).szTag = szVal;
			return;
		}
	}

	ArtDefneTag kTag;
	kTag.iMeshIndex = i;
	kTag.iUnitType = j;
	kTag.szTag = szVal;
	m_azMiddleArtDefineTags.push_back(kTag);
}

bool CvUnitArtStyleTypeInfo::read(CvXMLLoadUtility* pXML)
{
	int j, i;
	int iNumSibs;
	int iIndex; // UnitIndex
	int iMesh;  // Mesh Index

	CvString szTextVal;
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"StyleUnits"))
	{
		if (pXML->SkipToNextVal())
		{
			iNumSibs = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
			{
				if (0 < iNumSibs)
				{
					for (i = 0; i < iNumSibs; i++)
					{
						pXML->GetChildXmlValByName(szTextVal, "UnitType");
						iIndex = pXML->FindInInfoClass(szTextVal);

						if (iIndex > -1)
						{
							iMesh = GC.getUnitInfo((UnitTypes) iIndex).getGroupDefinitions();

							if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"UnitMeshGroup"))
							{
								for (j = 0; j < iMesh; j++)
								{
								    // Overwrite with the Style Art
									pXML->GetChildXmlValByName(szTextVal, "EarlyArtDefineTag");
									setEarlyArtDefineTag(j, iIndex, szTextVal);
									pXML->GetChildXmlValByName(szTextVal, "LateArtDefineTag");
									setLateArtDefineTag(j, iIndex, szTextVal);
									pXML->GetChildXmlValByName(szTextVal, "MiddleArtDefineTag");
									setMiddleArtDefineTag(j, iIndex, szTextVal);

									if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
									{
										break;
									}
								}
								gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
							}
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
				}
				gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvUnitArtStyleTypeInfo::copyNonDefaults(CvUnitArtStyleTypeInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	//A bit odd here.  Will only write the new information if previously it was blank?  Seems like it means you can only expand, but that it also relies on the
	//Group Definitions in UnitInfos to determine the size, so you need to have adjusted that first.  Art junk, so for all I know it needs to be this way.

	for (int iUnitIndex = 0; iUnitIndex < GC.getNumUnitInfos(); iUnitIndex++)
	{
		for (int iUnitMesh = 0; iUnitMesh < GC.getUnitInfo((UnitTypes) iUnitIndex).getGroupDefinitions(); iUnitMesh++ )
		{
			if (getEarlyArtDefineTag(iUnitMesh, iUnitIndex) == NULL)
			{
				if (pClassInfo->getEarlyArtDefineTag(iUnitMesh, iUnitIndex) != NULL)
				{
					setEarlyArtDefineTag(iUnitMesh, iUnitIndex, pClassInfo->getEarlyArtDefineTag(iUnitMesh, iUnitIndex));
				}
			}

			if (getLateArtDefineTag(iUnitMesh, iUnitIndex) == NULL)
			{
				if (pClassInfo->getLateArtDefineTag(iUnitMesh, iUnitIndex) != NULL)
				{
					setLateArtDefineTag(iUnitMesh, iUnitIndex, pClassInfo->getLateArtDefineTag(iUnitMesh, iUnitIndex));
				}
			}

			if (getMiddleArtDefineTag(iUnitMesh, iUnitIndex) == NULL)
			{
				if (pClassInfo->getMiddleArtDefineTag(iUnitMesh, iUnitIndex) != NULL)
				{
					setMiddleArtDefineTag(iUnitMesh, iUnitIndex, pClassInfo->getMiddleArtDefineTag(iUnitMesh, iUnitIndex));
				}
			}
		}
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

CvVoteSourceInfo::CvVoteSourceInfo() :
	m_iVoteInterval(0),
	m_iFreeSpecialist(NO_SPECIALIST),
	m_iCivic(NO_CIVIC),
	m_aiReligionYields(NULL),
	m_aiReligionCommerces(NULL)
{

}

CvVoteSourceInfo::~CvVoteSourceInfo()
{
	SAFE_DELETE_ARRAY(m_aiReligionYields);
	SAFE_DELETE_ARRAY(m_aiReligionCommerces);
}

int CvVoteSourceInfo::getVoteInterval() const
{
	return m_iVoteInterval;
}

int CvVoteSourceInfo::getFreeSpecialist() const
{
	return m_iFreeSpecialist;
}

int CvVoteSourceInfo::getCivic() const
{
	return m_iCivic;
}

int CvVoteSourceInfo::getReligionYield(int i) const
{
	FAssert(i >= 0 && i < NUM_YIELD_TYPES);
	return m_aiReligionYields[i];
}

int CvVoteSourceInfo::getReligionCommerce(int i) const
{
	FAssert(i >= 0 && i < NUM_COMMERCE_TYPES);
	return m_aiReligionCommerces[i];
}

const CvWString CvVoteSourceInfo::getPopupText() const
{
	return gDLL->getText(m_szPopupText);
}

const CvWString CvVoteSourceInfo::getSecretaryGeneralText() const
{
	return gDLL->getText(m_szSecretaryGeneralText);
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
const CvString& CvVoteSourceInfo::getCopyPopupText() const				{return m_szPopupText;}
const CvString& CvVoteSourceInfo::getCopySecretaryGeneralText() const	{return m_szSecretaryGeneralText;}
int CvVoteSourceInfo::getCivicVectorSize()								{return m_aszExtraXMLforPass3.size();}
CvString CvVoteSourceInfo::getCivicVectorElement(int i)					{return m_aszExtraXMLforPass3[i];}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

bool CvVoteSourceInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(&m_iVoteInterval, "iVoteInterval");
	pXML->GetChildXmlValByName(m_szPopupText, "PopupText");
	pXML->GetChildXmlValByName(m_szSecretaryGeneralText, "SecretaryGeneralText");

	CvString szTextVal;
	pXML->GetChildXmlValByName(szTextVal, "FreeSpecialist");
	m_iFreeSpecialist = GC.getInfoTypeForString(szTextVal);

	pXML->GetChildXmlValByName(szTextVal, "Civic");
	m_aszExtraXMLforPass3.push_back(szTextVal);

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ReligionYields"))
	{
		pXML->SetCommerce(&m_aiReligionYields);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_aiReligionYields, NUM_YIELD_TYPES);
	}

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"ReligionCommerces"))
	{
		pXML->SetCommerce(&m_aiReligionCommerces);
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	else
	{
		pXML->InitList(&m_aiReligionCommerces, NUM_COMMERCE_TYPES);
	}

	return true;
}

bool CvVoteSourceInfo::readPass3()
{
	if (m_aszExtraXMLforPass3.size() < 1)
	{
		FAssert(false);
		return false;
	}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/** Assuming the modder purposly added an entry to this tag, we want to take the last enty set  **/
/** by the modder and not the first as set by firaxis                                           **/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
/**								---- Start Original Code ----									**
	m_iCivic = GC.getInfoTypeForString(m_aszExtraXMLforPass3[0]);
	m_aszExtraXMLforPass3.clear();
/**								----  End Original Code  ----									**/
	int iSize = m_aszExtraXMLforPass3.size();
	for ( int i = 0; i < iSize; i++ )
	{
		if ( GC.getInfoTypeForString(m_aszExtraXMLforPass3[i], true) != -1)
		{
			m_iCivic = GC.getInfoTypeForString(m_aszExtraXMLforPass3[i]);
			break;
		}
	}
	m_aszExtraXMLforPass3.clear();
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

	return true;
}
/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvVoteSourceInfo::copyNonDefaults(CvVoteSourceInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getVoteInterval()			== 0)				m_iVoteInterval				= pClassInfo->getVoteInterval();
	if (getPopupText()				== wDefault)		m_szPopupText				= pClassInfo->getCopyPopupText();
	if (getSecretaryGeneralText()	== wDefault)		m_szSecretaryGeneralText	= pClassInfo->getCopySecretaryGeneralText();
	if (getFreeSpecialist()			== NO_SPECIALIST)	m_iFreeSpecialist			= pClassInfo->getFreeSpecialist();
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		if (getReligionYield(i)		== 0)				m_aiReligionYields[i]		= pClassInfo->getReligionYield(i);
	}
	for ( int i = 0; i < NUM_COMMERCE_TYPES; i++)
	{
		if (getReligionCommerce(i)	== 0)				m_aiReligionCommerces[i]	= pClassInfo->getReligionCommerce(i);
	}

	// Readpass3 stuff
	for ( int i = 0; i < pClassInfo->getCivicVectorSize(); i++ )
	{
														m_aszExtraXMLforPass3.push_back(		pClassInfo->getCivicVectorElement(i));
	}
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

CvMainMenuInfo::CvMainMenuInfo()
{

}

CvMainMenuInfo::~CvMainMenuInfo()
{
}

std::string CvMainMenuInfo::getScene() const
{
	return m_szScene;
}

std::string CvMainMenuInfo::getSceneNoShader() const
{
	return m_szSceneNoShader;
}

std::string CvMainMenuInfo::getSoundtrack() const
{
	return m_szSoundtrack;
}

std::string CvMainMenuInfo::getLoading() const
{
	return m_szLoading;
}

std::string CvMainMenuInfo::getLoadingSlideshow() const
{
	return m_szLoadingSlideshow;
}

bool CvMainMenuInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}

	pXML->GetChildXmlValByName(m_szScene, "Scene");
	pXML->GetChildXmlValByName(m_szSceneNoShader, "SceneNoShader");
	pXML->GetChildXmlValByName(m_szSoundtrack, "Soundtrack");
	pXML->GetChildXmlValByName(m_szLoading, "Loading");
	pXML->GetChildXmlValByName(m_szLoadingSlideshow, "LoadingSlideshow");

	return true;
}

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
void CvMainMenuInfo::copyNonDefaults(CvMainMenuInfo* pClassInfo, CvXMLLoadUtility* pXML)
{
	CvString cDefault = CvString::format("").GetCString();
	CvWString wDefault = CvWString::format(L"").GetCString();

	CvInfoBase::copyNonDefaults(pClassInfo, pXML);

	if (getScene()				== cDefault)	m_szScene				= pClassInfo->getScene();
	if (getSceneNoShader()		== cDefault)	m_szSceneNoShader		= pClassInfo->getSceneNoShader();
	if (getSoundtrack()			== cDefault)	m_szSoundtrack			= pClassInfo->getSoundtrack();
	if (getLoading()			== cDefault)	m_szLoading				= pClassInfo->getLoading();
	if (getLoadingSlideshow()	== cDefault)	m_szLoadingSlideshow	= pClassInfo->getLoadingSlideshow();
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/

/*************************************************************************************************/
/**	TrueModular								05/26/09	Written: Mr. Genie	Imported: Xienwolf	**/
/**																								**/
/**	Properly links Modular modifications to previous elements, and allows partial overwriting	**/
/*************************************************************************************************/
// Python Modular Loading
CvPythonModulesInfo::CvPythonModulesInfo():
m_bMainInterfaceScreen(false),
m_bCivicScreen(false),
m_bCorporationScreen(false),
m_bDomesticAdvisor(false),
m_bEspionageAdvisor(false),
m_bForeignAdvisor(false),
m_bMilitaryAdvisor(false),
m_bVictoryScreen(false),
m_iScreen(0)
{
}

CvPythonModulesInfo::~CvPythonModulesInfo()
{
}

bool CvPythonModulesInfo::isMainInterfaceScreen()
{
	return m_bMainInterfaceScreen;
}

bool CvPythonModulesInfo::isCivicScreen()
{
	return m_bCivicScreen;
}

bool CvPythonModulesInfo::isCorporationScreen()
{
	return m_bCorporationScreen;
}

bool CvPythonModulesInfo::isDomesticAdvisor()
{
	return m_bDomesticAdvisor;
}

bool CvPythonModulesInfo::isEspionageAdvisor()
{
	return m_bEspionageAdvisor;
}

bool CvPythonModulesInfo::isForeignAdvisor()
{
	return m_bForeignAdvisor;
}

bool CvPythonModulesInfo::isMilitaryAdvisor()
{
	return m_bMilitaryAdvisor;
}

bool CvPythonModulesInfo::isVictoryScreen()
{
	return m_bVictoryScreen;
}

int CvPythonModulesInfo::getScreen()
{
	return m_iScreen;
}

bool CvPythonModulesInfo::read(CvXMLLoadUtility* pXML)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	pXML->GetChildXmlValByName(&m_bMainInterfaceScreen, "bMainInterfaceScreen");
	pXML->GetChildXmlValByName(&m_bCivicScreen, "bCivicScreen");
	pXML->GetChildXmlValByName(&m_bCorporationScreen, "bCorporationScreen");
	pXML->GetChildXmlValByName(&m_bDomesticAdvisor, "bDomesticAdvisor");
	pXML->GetChildXmlValByName(&m_bEspionageAdvisor, "bEspionageAdvisor");
	pXML->GetChildXmlValByName(&m_bForeignAdvisor, "bForeignAdvisor");
	pXML->GetChildXmlValByName(&m_bMilitaryAdvisor, "bMilitaryAdvisor");
	pXML->GetChildXmlValByName(&m_bVictoryScreen, "bVictoryScreen");
	pXML->GetChildXmlValByName(&m_iScreen, "iScreen");
	return true;
}

// MLF loading
CvModLoadControlInfo::CvModLoadControlInfo():
m_iDirDepth(0)
{
}

CvModLoadControlInfo::~CvModLoadControlInfo()
{
}

bool CvModLoadControlInfo::isLoad(int i)
{
	FAssertMsg(i < getNumModules(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_bLoad[i];
}

void CvModLoadControlInfo::setLoad(int i, bool bLoad)
{
	FAssertMsg(i < getNumModules(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	m_bLoad[i] = bLoad;
}

int CvModLoadControlInfo::getNumModules()
{
	return m_iNumModules;
}

int CvModLoadControlInfo::getDirDepth()
{
	return m_iDirDepth;
}

std::string CvModLoadControlInfo::getModuleFolder(int i)
{
	FAssertMsg(i < getNumModules(), "Index out of bounds");
	FAssertMsg(i > -1, "Index out of bounds");
	return m_paszModuleFolder[i];
}

std::string CvModLoadControlInfo::getParentFolder()
{
	return m_paszParentFolder;
}

bool CvModLoadControlInfo::read(CvXMLLoadUtility* pXML, CvString szDirDepth, int iDirDepth)
{
	if (!CvInfoBase::read(pXML))
	{
		return false;
	}
	//Class variables
	m_iDirDepth = iDirDepth;
	m_paszParentFolder = szDirDepth; //verify previous level in CvXMLLoadUtility::getModLoadControlDirectory
	//method variables
	CvString szTextVal;
	std::string m_szDirDepth;
	bool bLoad;

	if (gDLL->getXMLIFace()->SetToChildByTagName(pXML->GetXML(),"Modules"))
	{
		if (pXML->SkipToNextVal())
		{
			m_iNumModules = gDLL->getXMLIFace()->GetNumChildren(pXML->GetXML());
			if (0 < m_iNumModules)
			{
				m_paszModuleFolder = new std::string[m_iNumModules];
				m_bLoad = new bool[m_iNumModules];
				if (gDLL->getXMLIFace()->SetToChild(pXML->GetXML()))
				{
					for (int iIndex = 0; iIndex < m_iNumModules; iIndex++)
					{
						m_bLoad[iIndex] = false;	// by default bLoad is false
						if (pXML->GetChildXmlVal(szTextVal))
						{
							pXML->GetNextXmlVal(&bLoad, true);
							if (bLoad)
							{
								m_bLoad[iIndex] = bLoad;	//this Module needs to be loaded
								m_szDirDepth = szDirDepth;
								m_szDirDepth.append(szTextVal);
								m_paszModuleFolder[iIndex] = m_szDirDepth.c_str();
								GC.setTotalNumModules();  //we need this for looping in the XMLLoad class
							}

							gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
						}

						if (!gDLL->getXMLIFace()->NextSibling(pXML->GetXML()))
						{
							break;
						}
					}
					gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
				}
			}
		}
		gDLL->getXMLIFace()->SetToParent(pXML->GetXML());
	}
	return true;
}
/*************************************************************************************************/
/**	TrueModular								END													**/
/*************************************************************************************************/
